/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 4 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
#pragma pack(push,8)
#line 5
#pragma pack(pop)
#line 6 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned short wchar_t;
#line 7 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned long ULONG_PTR;
#line 8 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned long *PULONG_PTR;
#line 9 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG_PTR SIZE_T;
#line 10 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef void *PVOID;
#line 11 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef char CHAR;
#line 12 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef short SHORT;
#line 13 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef long LONG;
#line 14 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef wchar_t WCHAR;
#line 15 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef WCHAR *PWSTR;
#line 16 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef WCHAR const   *PCWSTR;
#line 17 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef CHAR *PCHAR;
#line 18 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef CHAR const   *PCSTR;
#line 19 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef LONG *PLONG;
#line 20 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned char UCHAR;
#line 21 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned short USHORT;
#line 22 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned long ULONG;
#line 23 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef UCHAR *PUCHAR;
#line 24 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG *PULONG;
#line 25 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef void *HANDLE;
#line 26 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef HANDLE *PHANDLE;
#line 27 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef char CCHAR;
#line 28 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef short CSHORT;
#line 29 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG LCID;
#line 30 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef LONG NTSTATUS;
#line 31 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef long long LONGLONG;
#line 32 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct____missing_field_name_1 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 36 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_u_2 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 40 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union _LARGE_INTEGER {
   struct __anonstruct____missing_field_name_1 __annonCompField1 ;
   struct __anonstruct_u_2 u ;
   LONGLONG QuadPart ;
};
#line 45 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef union _LARGE_INTEGER LARGE_INTEGER;
#line 46 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef LARGE_INTEGER *PLARGE_INTEGER;
#line 47 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _LUID {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 51 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _LUID LUID;
#line 52 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
#line 53
enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1
} ;
#line 57 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _EVENT_TYPE EVENT_TYPE;
#line 58 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef char const   *PCSZ;
#line 59 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PCHAR Buffer ;
};
#line 64 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _STRING STRING;
#line 65 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef STRING *PSTRING;
#line 66 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef PSTRING PANSI_STRING;
#line 67 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _UNICODE_STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PWSTR Buffer ;
};
#line 72 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _UNICODE_STRING UNICODE_STRING;
#line 73 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef UNICODE_STRING *PUNICODE_STRING;
#line 74 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef UCHAR BOOLEAN;
#line 75 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef BOOLEAN *PBOOLEAN;
#line 76 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink ;
   struct _LIST_ENTRY *Blink ;
};
#line 80 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _LIST_ENTRY LIST_ENTRY;
#line 81 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _LIST_ENTRY *PLIST_ENTRY;
#line 82 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _OBJECT_ATTRIBUTES {
   ULONG Length ;
   HANDLE RootDirectory ;
   PUNICODE_STRING ObjectName ;
   ULONG Attributes ;
   PVOID SecurityDescriptor ;
   PVOID SecurityQualityOfService ;
};
#line 90 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
#line 91 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#line 92 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _GUID {
   unsigned long Data1 ;
   unsigned short Data2 ;
   unsigned short Data3 ;
   unsigned char Data4[8] ;
};
#line 98 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _GUID GUID;
#line 99 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef GUID const   *LPCGUID;
#line 100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef unsigned int size_t;
#line 101 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef UCHAR KIRQL;
#line 102 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef KIRQL *PKIRQL;
#line 103
enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3
} ;
#line 108 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _NT_PRODUCT_TYPE NT_PRODUCT_TYPE;
#line 109
struct _KTHREAD;
#line 109
struct _KTHREAD;
#line 110 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KTHREAD *PKTHREAD;
#line 111
struct _ETHREAD;
#line 111
struct _ETHREAD;
#line 112 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _ETHREAD *PETHREAD;
#line 113
struct _EPROCESS;
#line 113
struct _EPROCESS;
#line 114 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _EPROCESS *PEPROCESS;
#line 115
struct _KINTERRUPT;
#line 115
struct _KINTERRUPT;
#line 116 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KINTERRUPT *PKINTERRUPT;
#line 117
struct _IO_TIMER;
#line 117
struct _IO_TIMER;
#line 118 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_TIMER *PIO_TIMER;
#line 119
struct _OBJECT_TYPE;
#line 119
struct _OBJECT_TYPE;
#line 120 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
#line 121 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef CCHAR KPROCESSOR_MODE;
#line 122
struct _KAPC;
#line 122
struct _KAPC;
#line 123
struct _KAPC;
#line 124 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 );
#line 125 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KAPC {
   CSHORT Type ;
   CSHORT Size ;
   ULONG Spare0 ;
   struct _KTHREAD *Thread ;
   LIST_ENTRY ApcListEntry ;
   void (*KernelRoutine)(struct _KAPC *Apc , PKNORMAL_ROUTINE *NormalRoutine , PVOID *NormalContext ,
                         PVOID *SystemArgument1 , PVOID *SystemArgument2 ) ;
   void (*RundownRoutine)(struct _KAPC *Apc ) ;
   void (*NormalRoutine)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
   PVOID NormalContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   CCHAR ApcStateIndex ;
   KPROCESSOR_MODE ApcMode ;
   BOOLEAN Inserted ;
};
#line 142 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KAPC KAPC;
#line 143
struct _KDPC;
#line 143
struct _KDPC;
#line 144
struct _KDPC;
#line 145 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KDPC {
   CSHORT Type ;
   UCHAR Number ;
   UCHAR Importance ;
   LIST_ENTRY DpcListEntry ;
   void (*DeferredRoutine)(struct _KDPC *Dpc , PVOID DeferredContext , PVOID SystemArgument1 ,
                           PVOID SystemArgument2 ) ;
   PVOID DeferredContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   PULONG_PTR Lock ;
};
#line 157 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KDPC KDPC;
#line 158 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KDPC *PKDPC;
#line 159 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KDPC *PRKDPC;
#line 160 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _MDL {
   struct _MDL *Next ;
   CSHORT Size ;
   CSHORT MdlFlags ;
   struct _EPROCESS *Process ;
   PVOID MappedSystemVa ;
   PVOID StartVa ;
   ULONG ByteCount ;
   ULONG ByteOffset ;
};
#line 170 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _MDL MDL;
#line 171 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _MDL *PMDL;
#line 172 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef PVOID PACCESS_TOKEN;
#line 173 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef PVOID PSECURITY_DESCRIPTOR;
#line 174 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG ACCESS_MASK;
#line 175
#pragma pack(push,4)
#line 176 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _LUID_AND_ATTRIBUTES {
   LUID Luid ;
   ULONG Attributes ;
};
#line 180 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#line 181
#pragma pack(pop)
#line 182 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[1] ;
};
#line 187 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
#line 188
enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3
} ;
#line 194 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
#line 195 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
#line 196 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SECURITY_QUALITY_OF_SERVICE {
   ULONG Length ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
   BOOLEAN EffectiveOnly ;
};
#line 202 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
#line 203 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG SECURITY_INFORMATION;
#line 204 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG KAFFINITY;
#line 205 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef LONG KPRIORITY;
#line 206 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG_PTR KSPIN_LOCK;
#line 207 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef KSPIN_LOCK *PKSPIN_LOCK;
#line 208 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _RTL_QUERY_REGISTRY_TABLE {
   NTSTATUS (*QueryRoutine)(PWSTR ValueName , ULONG ValueType , PVOID ValueData ,
                            ULONG ValueLength , PVOID Context , PVOID EntryContext ) ;
   ULONG Flags ;
   PWSTR Name ;
   PVOID EntryContext ;
   ULONG DefaultType ;
   PVOID DefaultData ;
   ULONG DefaultLength ;
};
#line 219 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
#line 220 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
#line 221 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_6 {
   NTSTATUS Status ;
   PVOID Pointer ;
};
#line 225 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_STATUS_BLOCK {
   union __anonunion____missing_field_name_6 __annonCompField4 ;
   ULONG_PTR Information ;
};
#line 229 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
#line 230 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
#line 231
enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileMaximumInformation = 37
} ;
#line 270 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
#line 271 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   ULONG FileAttributes ;
};
#line 278 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
#line 279 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FILE_STANDARD_INFORMATION {
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG NumberOfLinks ;
   BOOLEAN DeletePending ;
   BOOLEAN Directory ;
};
#line 286 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
#line 287 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG FileAttributes ;
};
#line 296 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
#line 297
enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsMaximumInformation = 9
} ;
#line 308 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
#line 309
enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    MaximumInterfaceType = 16
} ;
#line 329 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
#line 330 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
#line 331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_ERROR_LOG_PACKET {
   UCHAR MajorFunctionCode ;
   UCHAR RetryCount ;
   USHORT DumpDataSize ;
   USHORT NumberOfStrings ;
   USHORT StringOffset ;
   USHORT EventCategory ;
   NTSTATUS ErrorCode ;
   ULONG UniqueErrorValue ;
   NTSTATUS FinalStatus ;
   ULONG SequenceNumber ;
   ULONG IoControlCode ;
   LARGE_INTEGER DeviceOffset ;
   ULONG DumpData[1] ;
};
#line 346 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_ERROR_LOG_PACKET IO_ERROR_LOG_PACKET;
#line 347 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_ERROR_LOG_PACKET *PIO_ERROR_LOG_PACKET;
#line 348 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KEY_VALUE_FULL_INFORMATION {
   ULONG TitleIndex ;
   ULONG Type ;
   ULONG DataOffset ;
   ULONG DataLength ;
   ULONG NameLength ;
   WCHAR Name[1] ;
};
#line 356 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
#line 357
enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation = 0,
    KeyValueFullInformation = 1,
    KeyValuePartialInformation = 2,
    KeyValueFullInformationAlign64 = 3,
    KeyValuePartialInformationAlign64 = 4
} ;
#line 364 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _KEY_VALUE_INFORMATION_CLASS KEY_VALUE_INFORMATION_CLASS;
#line 365 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CLIENT_ID {
   HANDLE UniqueProcess ;
   HANDLE UniqueThread ;
};
#line 369 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CLIENT_ID CLIENT_ID;
#line 370 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef CLIENT_ID *PCLIENT_ID;
#line 371
enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} ;
#line 381 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
#line 382
enum __anonenum_POWER_ACTION_11 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7
} ;
#line 392 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
#line 393
enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5
} ;
#line 401 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
#line 402 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union _POWER_STATE {
   SYSTEM_POWER_STATE SystemState ;
   DEVICE_POWER_STATE DeviceState ;
};
#line 406 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef union _POWER_STATE POWER_STATE;
#line 407
enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1
} ;
#line 411 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
#line 412 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KSYSTEM_TIME {
   ULONG LowPart ;
   LONG High1Time ;
   LONG High2Time ;
};
#line 417 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KSYSTEM_TIME KSYSTEM_TIME;
#line 418
enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2
} ;
#line 423 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ALTERNATIVE_ARCHITECTURE_TYPE;
#line 424 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KUSER_SHARED_DATA {
   ULONG volatile   TickCountLow ;
   ULONG TickCountMultiplier ;
   KSYSTEM_TIME volatile   InterruptTime ;
   KSYSTEM_TIME volatile   SystemTime ;
   KSYSTEM_TIME volatile   TimeZoneBias ;
   USHORT ImageNumberLow ;
   USHORT ImageNumberHigh ;
   WCHAR NtSystemRoot[260] ;
   ULONG MaxStackTraceDepth ;
   ULONG CryptoExponent ;
   ULONG TimeZoneId ;
   ULONG Reserved2[8] ;
   NT_PRODUCT_TYPE NtProductType ;
   BOOLEAN ProductTypeIsValid ;
   ULONG NtMajorVersion ;
   ULONG NtMinorVersion ;
   BOOLEAN ProcessorFeatures[64] ;
   ULONG Reserved1 ;
   ULONG Reserved3 ;
   ULONG volatile   TimeSlip ;
   ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
   LARGE_INTEGER SystemExpirationDate ;
   ULONG SuiteMask ;
   BOOLEAN KdDebuggerEnabled ;
};
#line 450 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KUSER_SHARED_DATA KUSER_SHARED_DATA;
#line 451 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef PVOID PASSIGNED_RESOURCE;
#line 452
#pragma pack(push,4)
#line 453 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Generic_16 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 457 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Port_17 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 461 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Interrupt_18 {
   ULONG Level ;
   ULONG Vector ;
   ULONG Affinity ;
};
#line 466 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Memory_19 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 470 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Dma_20 {
   ULONG Channel ;
   ULONG Port ;
   ULONG Reserved1 ;
};
#line 475 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_DevicePrivate_21 {
   ULONG Data[3] ;
};
#line 478 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_BusNumber_22 {
   ULONG Start ;
   ULONG Length ;
   ULONG Reserved ;
};
#line 483 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_DeviceSpecificData_23 {
   ULONG DataSize ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 488 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_u_15 {
   struct __anonstruct_Generic_16 Generic ;
   struct __anonstruct_Port_17 Port ;
   struct __anonstruct_Interrupt_18 Interrupt ;
   struct __anonstruct_Memory_19 Memory ;
   struct __anonstruct_Dma_20 Dma ;
   struct __anonstruct_DevicePrivate_21 DevicePrivate ;
   struct __anonstruct_BusNumber_22 BusNumber ;
   struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData ;
};
#line 498 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
   UCHAR Type ;
   UCHAR ShareDisposition ;
   USHORT Flags ;
   union __anonunion_u_15 u ;
};
#line 504 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 505 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 506
#pragma pack(pop)
#line 507 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CM_PARTIAL_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
};
#line 513 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
#line 514 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_LIST *PCM_PARTIAL_RESOURCE_LIST;
#line 515 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CM_FULL_RESOURCE_DESCRIPTOR {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
};
#line 520 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
#line 521 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR *PCM_FULL_RESOURCE_DESCRIPTOR;
#line 522 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CM_RESOURCE_LIST {
   ULONG Count ;
   CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
};
#line 526 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_RESOURCE_LIST CM_RESOURCE_LIST;
#line 527 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#line 528
#pragma pack(push,1)
#line 529
#pragma pack(pop)
#line 530 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Port_25 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 536 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Memory_26 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 542 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Interrupt_27 {
   ULONG MinimumVector ;
   ULONG MaximumVector ;
};
#line 546 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Dma_28 {
   ULONG MinimumChannel ;
   ULONG MaximumChannel ;
};
#line 550 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Generic_29 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 556 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_DevicePrivate_30 {
   ULONG Data[3] ;
};
#line 559 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_BusNumber_31 {
   ULONG Length ;
   ULONG MinBusNumber ;
   ULONG MaxBusNumber ;
   ULONG Reserved ;
};
#line 565 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_AssignedResource_32 {
   PASSIGNED_RESOURCE AssignedResource ;
};
#line 568 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_SubAllocateFrom_33 {
   UCHAR Type ;
   UCHAR Reserved[3] ;
   PASSIGNED_RESOURCE AssignedResource ;
   PHYSICAL_ADDRESS Transformation ;
};
#line 574 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_ConfigData_34 {
   ULONG Priority ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 579 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_u_24 {
   struct __anonstruct_Port_25 Port ;
   struct __anonstruct_Memory_26 Memory ;
   struct __anonstruct_Interrupt_27 Interrupt ;
   struct __anonstruct_Dma_28 Dma ;
   struct __anonstruct_Generic_29 Generic ;
   struct __anonstruct_DevicePrivate_30 DevicePrivate ;
   struct __anonstruct_BusNumber_31 BusNumber ;
   struct __anonstruct_AssignedResource_32 AssignedResource ;
   struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom ;
   struct __anonstruct_ConfigData_34 ConfigData ;
};
#line 591 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_RESOURCE_DESCRIPTOR {
   UCHAR Option ;
   UCHAR Type ;
   UCHAR ShareDisposition ;
   UCHAR Spare1 ;
   USHORT Flags ;
   USHORT Spare2 ;
   union __anonunion_u_24 u ;
};
#line 600 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
#line 601 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_RESOURCE_DESCRIPTOR *PIO_RESOURCE_DESCRIPTOR;
#line 602 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
};
#line 608 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
#line 609 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_RESOURCE_LIST *PIO_RESOURCE_LIST;
#line 610 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_RESOURCE_REQUIREMENTS_LIST {
   ULONG ListSize ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG SlotNumber ;
   ULONG Reserved[3] ;
   ULONG AlternativeLists ;
   IO_RESOURCE_LIST List[1] ;
};
#line 619 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
#line 620
enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    MaximumType = 40
} ;
#line 663 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
#line 664 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
#line 665
enum _KINTERRUPT_MODE {
    LevelSensitive = 0,
    Latched = 1
} ;
#line 669 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _KINTERRUPT_MODE KINTERRUPT_MODE;
#line 670
enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    Spare6 = 25,
    WrKernel = 26,
    MaximumWaitReason = 27
} ;
#line 700 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _KWAIT_REASON KWAIT_REASON;
#line 701 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DISPATCHER_HEADER {
   UCHAR Type ;
   UCHAR Absolute ;
   UCHAR Size ;
   UCHAR Inserted ;
   LONG SignalState ;
   LIST_ENTRY WaitListHead ;
};
#line 709 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
#line 710 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KDEVICE_QUEUE {
   CSHORT Type ;
   CSHORT Size ;
   LIST_ENTRY DeviceListHead ;
   KSPIN_LOCK Lock ;
   BOOLEAN Busy ;
};
#line 717 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
#line 718 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KDEVICE_QUEUE_ENTRY {
   LIST_ENTRY DeviceListEntry ;
   ULONG SortKey ;
   BOOLEAN Inserted ;
};
#line 723 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
#line 724 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KEVENT {
   DISPATCHER_HEADER Header ;
};
#line 727 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KEVENT KEVENT;
#line 728 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KEVENT *PKEVENT;
#line 729 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KEVENT *PRKEVENT;
#line 730 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _KSEMAPHORE {
   DISPATCHER_HEADER Header ;
   LONG Limit ;
};
#line 734 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KSEMAPHORE *PKSEMAPHORE;
#line 735 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
#line 736
enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6
} ;
#line 745 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
#line 746
enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38
} ;
#line 763 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _POOL_TYPE POOL_TYPE;
#line 764 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FAST_MUTEX {
   LONG Count ;
   PKTHREAD Owner ;
   ULONG Contention ;
   KEVENT Event ;
   ULONG OldIrql ;
};
#line 771 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FAST_MUTEX FAST_MUTEX;
#line 772 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FAST_MUTEX *PFAST_MUTEX;
#line 773 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef ULONG_PTR ERESOURCE_THREAD;
#line 774 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_38 {
   LONG OwnerCount ;
   ULONG TableSize ;
};
#line 778 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _OWNER_ENTRY {
   ERESOURCE_THREAD OwnerThread ;
   union __anonunion____missing_field_name_38 __annonCompField10 ;
};
#line 782 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _OWNER_ENTRY OWNER_ENTRY;
#line 783 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
#line 784 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_39 {
   PVOID Address ;
   ULONG_PTR CreatorBackTraceIndex ;
};
#line 788 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _ERESOURCE {
   LIST_ENTRY SystemResourcesList ;
   POWNER_ENTRY OwnerTable ;
   SHORT ActiveCount ;
   USHORT Flag ;
   PKSEMAPHORE SharedWaiters ;
   PKEVENT ExclusiveWaiters ;
   OWNER_ENTRY OwnerThreads[2] ;
   ULONG ContentionCount ;
   USHORT NumberOfSharedWaiters ;
   USHORT NumberOfExclusiveWaiters ;
   union __anonunion____missing_field_name_39 __annonCompField11 ;
   KSPIN_LOCK SpinLock ;
};
#line 802
enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32
} ;
#line 807 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
#line 808
struct _DRIVER_OBJECT;
#line 808
struct _DRIVER_OBJECT;
#line 809
struct _DRIVER_OBJECT;
#line 810 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SECURITY_SUBJECT_CONTEXT {
   PACCESS_TOKEN ClientToken ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   PACCESS_TOKEN PrimaryToken ;
   PVOID ProcessAuditId ;
};
#line 816 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
#line 817 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _INITIAL_PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[3] ;
};
#line 822 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
#line 823 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_Privileges_40 {
   INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
   PRIVILEGE_SET PrivilegeSet ;
};
#line 827 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _ACCESS_STATE {
   LUID OperationID ;
   BOOLEAN SecurityEvaluated ;
   BOOLEAN GenerateAudit ;
   BOOLEAN GenerateOnClose ;
   BOOLEAN PrivilegesAllocated ;
   ULONG Flags ;
   ACCESS_MASK RemainingDesiredAccess ;
   ACCESS_MASK PreviouslyGrantedAccess ;
   ACCESS_MASK OriginalDesiredAccess ;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   PVOID AuxData ;
   union __anonunion_Privileges_40 Privileges ;
   BOOLEAN AuditPrivileges ;
   UNICODE_STRING ObjectName ;
   UNICODE_STRING ObjectTypeName ;
};
#line 845 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _ACCESS_STATE *PACCESS_STATE;
#line 846
struct _DEVICE_OBJECT;
#line 846
struct _DEVICE_OBJECT;
#line 847
struct _DEVICE_OBJECT;
#line 848
struct _DRIVER_OBJECT;
#line 849
struct _FILE_OBJECT;
#line 849
struct _FILE_OBJECT;
#line 850
struct _FILE_OBJECT;
#line 851
struct _IRP;
#line 851
struct _IRP;
#line 852
struct _IRP;
#line 853
struct _SCSI_REQUEST_BLOCK;
#line 853
struct _SCSI_REQUEST_BLOCK;
#line 854
struct _SCSI_REQUEST_BLOCK;
#line 855 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp );
#line 856
struct _COMPRESSED_DATA_INFO;
#line 856
struct _COMPRESSED_DATA_INFO;
#line 857 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FAST_IO_DISPATCH {
   ULONG SizeOfFastIoDispatch ;
   BOOLEAN (*FastIoCheckIfPossible)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , BOOLEAN Wait , ULONG LockKey ,
                                    BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK IoStatus ,
                                    struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                         PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                          ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                          PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryBasicInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                   PFILE_BASIC_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                   struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryStandardInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                      PFILE_STANDARD_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoLock)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                         BOOLEAN FailImmediately , BOOLEAN ExclusiveLock , PIO_STATUS_BLOCK IoStatus ,
                         struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockSingle)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                 PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                                 PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAll)(struct _FILE_OBJECT *FileObject , PEPROCESS ProcessId ,
                              PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAllByKey)(struct _FILE_OBJECT *FileObject , PVOID ProcessId ,
                                   ULONG Key , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoDeviceControl)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                  PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                  ULONG OutputBufferLength , ULONG IoControlCode ,
                                  PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice , struct _DEVICE_OBJECT *TargetDevice ) ;
   BOOLEAN (*FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                         struct _FILE_NETWORK_OPEN_INFORMATION *Buffer ,
                                         struct _IO_STATUS_BLOCK *IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForModWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER EndingOffset ,
                                  struct _ERESOURCE **ResourceToRelease , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                      ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadComplete)(struct _FILE_OBJECT *FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*PrepareMdlWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                              ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteComplete)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                               PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoReadCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                   ULONG Length , ULONG LockKey , PVOID Buffer , PMDL *MdlChain ,
                                   PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                   ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWriteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , ULONG LockKey , PVOID Buffer ,
                                    PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                    ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadCompleteCompressed)(struct _FILE_OBJECT *FileObject , PMDL MdlChain ,
                                        struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteCompleteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                         PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryOpen)(struct _IRP *Irp , PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForModWrite)(struct _FILE_OBJECT *FileObject , struct _ERESOURCE *ResourceToRelease ,
                                  struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
};
#line 926 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
#line 927
enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3
} ;
#line 932 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
#line 933 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_SECURITY_CONTEXT {
   PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
   PACCESS_STATE AccessState ;
   ACCESS_MASK DesiredAccess ;
   ULONG FullCreateOptions ;
};
#line 939 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
#line 940 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _VPB {
   CSHORT Type ;
   CSHORT Size ;
   USHORT Flags ;
   USHORT VolumeLabelLength ;
   struct _DEVICE_OBJECT *DeviceObject ;
   struct _DEVICE_OBJECT *RealDevice ;
   ULONG SerialNumber ;
   ULONG ReferenceCount ;
   WCHAR VolumeLabel[(32U * sizeof(WCHAR )) / sizeof(WCHAR )] ;
};
#line 951 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _VPB *PVPB;
#line 952 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _WAIT_CONTEXT_BLOCK {
   KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
   IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ,
                                         PVOID MapRegisterBase , PVOID Context ) ;
   PVOID DeviceContext ;
   ULONG NumberOfMapRegisters ;
   PVOID DeviceObject ;
   PVOID CurrentIrp ;
   PKDPC BufferChainingDpc ;
};
#line 962 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
#line 963 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_Queue_43 {
   LIST_ENTRY ListEntry ;
   WAIT_CONTEXT_BLOCK Wcb ;
};
#line 967
struct _DEVOBJ_EXTENSION;
#line 967
struct _DEVOBJ_EXTENSION;
#line 968 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DEVICE_OBJECT {
   CSHORT Type ;
   USHORT Size ;
   LONG ReferenceCount ;
   struct _DRIVER_OBJECT *DriverObject ;
   struct _DEVICE_OBJECT *NextDevice ;
   struct _DEVICE_OBJECT *AttachedDevice ;
   struct _IRP *CurrentIrp ;
   PIO_TIMER Timer ;
   ULONG Flags ;
   ULONG Characteristics ;
   PVPB Vpb ;
   PVOID DeviceExtension ;
   ULONG DeviceType ;
   CCHAR StackSize ;
   union __anonunion_Queue_43 Queue ;
   ULONG AlignmentRequirement ;
   KDEVICE_QUEUE DeviceQueue ;
   KDPC Dpc ;
   ULONG ActiveThreadCount ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   KEVENT DeviceLock ;
   USHORT SectorSize ;
   USHORT Spare1 ;
   struct _DEVOBJ_EXTENSION *DeviceObjectExtension ;
   PVOID Reserved ;
};
#line 995 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
#line 996 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
#line 997 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DEVOBJ_EXTENSION {
   CSHORT Type ;
   USHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1002 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DRIVER_EXTENSION {
   struct _DRIVER_OBJECT *DriverObject ;
   NTSTATUS (*AddDevice)(struct _DRIVER_OBJECT *DriverObject , struct _DEVICE_OBJECT *PhysicalDeviceObject ) ;
   ULONG Count ;
   UNICODE_STRING ServiceKeyName ;
};
#line 1008 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
#line 1009 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DRIVER_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PVOID DriverStart ;
   ULONG DriverSize ;
   PVOID DriverSection ;
   PDRIVER_EXTENSION DriverExtension ;
   UNICODE_STRING DriverName ;
   PUNICODE_STRING HardwareDatabase ;
   PFAST_IO_DISPATCH FastIoDispatch ;
   NTSTATUS (*DriverInit)(struct _DRIVER_OBJECT *DriverObject , PUNICODE_STRING RegistryPath ) ;
   void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject ) ;
   PDRIVER_DISPATCH MajorFunction[28] ;
};
#line 1026 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
#line 1027 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
#line 1028 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SECTION_OBJECT_POINTERS {
   PVOID DataSectionObject ;
   PVOID SharedCacheMap ;
   PVOID ImageSectionObject ;
};
#line 1033 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
#line 1034 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
#line 1035 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_COMPLETION_CONTEXT {
   PVOID Port ;
   PVOID Key ;
};
#line 1039 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
#line 1040 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _FILE_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   PVPB Vpb ;
   PVOID FsContext ;
   PVOID FsContext2 ;
   PSECTION_OBJECT_POINTERS SectionObjectPointer ;
   PVOID PrivateCacheMap ;
   NTSTATUS FinalStatus ;
   struct _FILE_OBJECT *RelatedFileObject ;
   BOOLEAN LockOperation ;
   BOOLEAN DeletePending ;
   BOOLEAN ReadAccess ;
   BOOLEAN WriteAccess ;
   BOOLEAN DeleteAccess ;
   BOOLEAN SharedRead ;
   BOOLEAN SharedWrite ;
   BOOLEAN SharedDelete ;
   ULONG Flags ;
   UNICODE_STRING FileName ;
   LARGE_INTEGER CurrentByteOffset ;
   ULONG Waiters ;
   ULONG Busy ;
   PVOID LastLock ;
   KEVENT Lock ;
   KEVENT Event ;
   PIO_COMPLETION_CONTEXT CompletionContext ;
};
#line 1069 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _FILE_OBJECT *PFILE_OBJECT;
#line 1070 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_AssociatedIrp_44 {
   struct _IRP *MasterIrp ;
   LONG IrpCount ;
   PVOID SystemBuffer ;
};
#line 1075 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_AsynchronousParameters_46 {
   void (*UserApcRoutine)(PVOID ApcContext , PIO_STATUS_BLOCK IoStatusBlock , ULONG Reserved ) ;
   PVOID UserApcContext ;
};
#line 1080 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_Overlay_45 {
   struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters ;
   LARGE_INTEGER AllocationSize ;
};
#line 1084 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct____missing_field_name_50 {
   PVOID DriverContext[4] ;
};
#line 1087 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_49 {
   KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
   struct __anonstruct____missing_field_name_50 __annonCompField14 ;
};
#line 1091
struct _IO_STACK_LOCATION;
#line 1091
struct _IO_STACK_LOCATION;
#line 1092 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_52 {
   struct _IO_STACK_LOCATION *CurrentStackLocation ;
   ULONG PacketType ;
};
#line 1096 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct____missing_field_name_51 {
   LIST_ENTRY ListEntry ;
   union __anonunion____missing_field_name_52 __annonCompField16 ;
};
#line 1100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Overlay_48 {
   union __anonunion____missing_field_name_49 __annonCompField15 ;
   PETHREAD Thread ;
   PCHAR AuxiliaryBuffer ;
   struct __anonstruct____missing_field_name_51 __annonCompField17 ;
   PFILE_OBJECT OriginalFileObject ;
};
#line 1107 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_Tail_47 {
   struct __anonstruct_Overlay_48 Overlay ;
   KAPC Apc ;
   PVOID CompletionKey ;
};
#line 1112 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IRP {
   CSHORT Type ;
   USHORT Size ;
   PMDL MdlAddress ;
   ULONG Flags ;
   union __anonunion_AssociatedIrp_44 AssociatedIrp ;
   LIST_ENTRY ThreadListEntry ;
   IO_STATUS_BLOCK IoStatus ;
   KPROCESSOR_MODE RequestorMode ;
   BOOLEAN PendingReturned ;
   CHAR StackCount ;
   CHAR CurrentLocation ;
   BOOLEAN Cancel ;
   KIRQL CancelIrql ;
   CCHAR ApcEnvironment ;
   UCHAR AllocationFlags ;
   PIO_STATUS_BLOCK UserIosb ;
   PKEVENT UserEvent ;
   union __anonunion_Overlay_45 Overlay ;
   void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   PVOID UserBuffer ;
   union __anonunion_Tail_47 Tail ;
};
#line 1135 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IRP IRP;
#line 1136 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IRP *PIRP;
#line 1137
enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4
} ;
#line 1144 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
#line 1145 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DEVICE_RELATIONS {
   ULONG Count ;
   PDEVICE_OBJECT Objects[1] ;
};
#line 1149 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_RELATIONS DEVICE_RELATIONS;
#line 1150 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_RELATIONS *PDEVICE_RELATIONS;
#line 1151
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3
} ;
#line 1157 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
#line 1158 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _INTERFACE {
   USHORT Size ;
   USHORT Version ;
   PVOID Context ;
   void (*InterfaceReference)(PVOID Context ) ;
   void (*InterfaceDereference)(PVOID Context ) ;
};
#line 1165 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _INTERFACE *PINTERFACE;
#line 1166 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DEVICE_CAPABILITIES {
   USHORT Size ;
   USHORT Version ;
   ULONG DeviceD1 : 1 ;
   ULONG DeviceD2 : 1 ;
   ULONG LockSupported : 1 ;
   ULONG EjectSupported : 1 ;
   ULONG Removable : 1 ;
   ULONG DockDevice : 1 ;
   ULONG UniqueID : 1 ;
   ULONG SilentInstall : 1 ;
   ULONG RawDeviceOK : 1 ;
   ULONG SurpriseRemovalOK : 1 ;
   ULONG WakeFromD0 : 1 ;
   ULONG WakeFromD1 : 1 ;
   ULONG WakeFromD2 : 1 ;
   ULONG WakeFromD3 : 1 ;
   ULONG HardwareDisabled : 1 ;
   ULONG NonDynamic : 1 ;
   ULONG WarmEjectSupported : 1 ;
   ULONG Reserved : 15 ;
   ULONG Address ;
   ULONG UINumber ;
   DEVICE_POWER_STATE DeviceState[7] ;
   SYSTEM_POWER_STATE SystemWake ;
   DEVICE_POWER_STATE DeviceWake ;
   ULONG D1Latency ;
   ULONG D2Latency ;
   ULONG D3Latency ;
};
#line 1196 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
#line 1197 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _POWER_SEQUENCE {
   ULONG SequenceD1 ;
   ULONG SequenceD2 ;
   ULONG SequenceD3 ;
};
#line 1202 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
#line 1203
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4
} ;
#line 1210 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
#line 1211
enum __anonenum_DEVICE_TEXT_TYPE_54 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1
} ;
#line 1215 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#line 1216
#pragma pack(push,4)
#line 1217 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Create_56 {
   PIO_SECURITY_CONTEXT SecurityContext ;
   ULONG Options ;
   USHORT FileAttributes ;
   USHORT ShareAccess ;
   ULONG EaLength ;
};
#line 1224 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Read_57 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1229 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Write_58 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1234 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryFile_59 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
};
#line 1238 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct____missing_field_name_62 {
   BOOLEAN ReplaceIfExists ;
   BOOLEAN AdvanceOnly ;
};
#line 1242 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion____missing_field_name_61 {
   struct __anonstruct____missing_field_name_62 __annonCompField18 ;
   ULONG ClusterCount ;
   HANDLE DeleteHandle ;
};
#line 1247 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_SetFile_60 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
   PFILE_OBJECT FileObject ;
   union __anonunion____missing_field_name_61 __annonCompField19 ;
};
#line 1253 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryVolume_63 {
   ULONG Length ;
   FS_INFORMATION_CLASS FsInformationClass ;
};
#line 1257 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_DeviceIoControl_64 {
   ULONG OutputBufferLength ;
   ULONG InputBufferLength ;
   ULONG IoControlCode ;
   PVOID Type3InputBuffer ;
};
#line 1263 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QuerySecurity_65 {
   SECURITY_INFORMATION SecurityInformation ;
   ULONG Length ;
};
#line 1267 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_SetSecurity_66 {
   SECURITY_INFORMATION SecurityInformation ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
};
#line 1271 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_MountVolume_67 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1275 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_VerifyVolume_68 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1279 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Scsi_69 {
   struct _SCSI_REQUEST_BLOCK *Srb ;
};
#line 1282 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryDeviceRelations_70 {
   DEVICE_RELATION_TYPE Type ;
};
#line 1285 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryInterface_71 {
   GUID const   *InterfaceType ;
   USHORT Size ;
   USHORT Version ;
   PINTERFACE Interface ;
   PVOID InterfaceSpecificData ;
};
#line 1292 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_DeviceCapabilities_72 {
   PDEVICE_CAPABILITIES Capabilities ;
};
#line 1295 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_FilterResourceRequirements_73 {
   PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList ;
};
#line 1298 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_ReadWriteConfig_74 {
   ULONG WhichSpace ;
   PVOID Buffer ;
   ULONG Offset ;
   ULONG Length ;
};
#line 1304 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_SetLock_75 {
   BOOLEAN Lock ;
};
#line 1307 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryId_76 {
   BUS_QUERY_ID_TYPE IdType ;
};
#line 1310 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_QueryDeviceText_77 {
   DEVICE_TEXT_TYPE DeviceTextType ;
   LCID LocaleId ;
};
#line 1314 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_UsageNotification_78 {
   BOOLEAN InPath ;
   BOOLEAN Reserved[3] ;
   DEVICE_USAGE_NOTIFICATION_TYPE Type ;
};
#line 1319 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_WaitWake_79 {
   SYSTEM_POWER_STATE PowerState ;
};
#line 1322 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_PowerSequence_80 {
   PPOWER_SEQUENCE PowerSequence ;
};
#line 1325 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Power_81 {
   ULONG SystemContext ;
   POWER_STATE_TYPE Type ;
   POWER_STATE State ;
   POWER_ACTION ShutdownType ;
};
#line 1331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_StartDevice_82 {
   PCM_RESOURCE_LIST AllocatedResources ;
   PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
};
#line 1335 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_WMI_83 {
   ULONG_PTR ProviderId ;
   PVOID DataPath ;
   ULONG BufferSize ;
   PVOID Buffer ;
};
#line 1341 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_Others_84 {
   PVOID Argument1 ;
   PVOID Argument2 ;
   PVOID Argument3 ;
   PVOID Argument4 ;
};
#line 1347 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union __anonunion_Parameters_55 {
   struct __anonstruct_Create_56 Create ;
   struct __anonstruct_Read_57 Read ;
   struct __anonstruct_Write_58 Write ;
   struct __anonstruct_QueryFile_59 QueryFile ;
   struct __anonstruct_SetFile_60 SetFile ;
   struct __anonstruct_QueryVolume_63 QueryVolume ;
   struct __anonstruct_DeviceIoControl_64 DeviceIoControl ;
   struct __anonstruct_QuerySecurity_65 QuerySecurity ;
   struct __anonstruct_SetSecurity_66 SetSecurity ;
   struct __anonstruct_MountVolume_67 MountVolume ;
   struct __anonstruct_VerifyVolume_68 VerifyVolume ;
   struct __anonstruct_Scsi_69 Scsi ;
   struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations ;
   struct __anonstruct_QueryInterface_71 QueryInterface ;
   struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities ;
   struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements ;
   struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig ;
   struct __anonstruct_SetLock_75 SetLock ;
   struct __anonstruct_QueryId_76 QueryId ;
   struct __anonstruct_QueryDeviceText_77 QueryDeviceText ;
   struct __anonstruct_UsageNotification_78 UsageNotification ;
   struct __anonstruct_WaitWake_79 WaitWake ;
   struct __anonstruct_PowerSequence_80 PowerSequence ;
   struct __anonstruct_Power_81 Power ;
   struct __anonstruct_StartDevice_82 StartDevice ;
   struct __anonstruct_WMI_83 WMI ;
   struct __anonstruct_Others_84 Others ;
};
#line 1376 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_STACK_LOCATION {
   UCHAR MajorFunction ;
   UCHAR MinorFunction ;
   UCHAR Flags ;
   UCHAR Control ;
   union __anonunion_Parameters_55 Parameters ;
   PDEVICE_OBJECT DeviceObject ;
   PFILE_OBJECT FileObject ;
   NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
   PVOID Context ;
};
#line 1387 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
#line 1388 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#line 1389
#pragma pack(pop)
#line 1390 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _CONFIGURATION_INFORMATION {
   ULONG DiskCount ;
   ULONG FloppyCount ;
   ULONG CdRomCount ;
   ULONG TapeCount ;
   ULONG ScsiPortCount ;
   ULONG SerialCount ;
   ULONG ParallelCount ;
   BOOLEAN AtDiskPrimaryAddressClaimed ;
   BOOLEAN AtDiskSecondaryAddressClaimed ;
   ULONG Version ;
   ULONG MediumChangerCount ;
};
#line 1403 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CONFIGURATION_INFORMATION CONFIGURATION_INFORMATION;
#line 1404 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
#line 1405 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_REMOVE_LOCK_COMMON_BLOCK {
   BOOLEAN Removed ;
   BOOLEAN Reserved[3] ;
   LONG IoCount ;
   KEVENT RemoveEvent ;
};
#line 1411 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK IO_REMOVE_LOCK_COMMON_BLOCK;
#line 1412 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _IO_REMOVE_LOCK {
   IO_REMOVE_LOCK_COMMON_BLOCK Common ;
};
#line 1415 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_REMOVE_LOCK IO_REMOVE_LOCK;
#line 1416 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _IO_REMOVE_LOCK *PIO_REMOVE_LOCK;
#line 1417 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _OBJECT_HANDLE_INFORMATION {
   ULONG HandleAttributes ;
   ACCESS_MASK GrantedAccess ;
};
#line 1421 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
#line 1422 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARPORT_REMOVAL_RELATIONS {
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PUNICODE_STRING DeviceName ;
};
#line 1427 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARPORT_REMOVAL_RELATIONS PARPORT_REMOVAL_RELATIONS;
#line 1428 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARPORT_REMOVAL_RELATIONS *PPARPORT_REMOVAL_RELATIONS;
#line 1429 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_PARCHIP_INFO {
   PUCHAR Controller ;
   PUCHAR EcrController ;
   ULONG HardwareModes ;
   NTSTATUS (*ParChipSetMode)(PVOID SetChipContext , UCHAR ChipMode ) ;
   NTSTATUS (*ParChipClearMode)(PVOID ClearChipContext , UCHAR ChipMode ) ;
   PVOID Context ;
   BOOLEAN success ;
};
#line 1438 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_PARCHIP_INFO PARALLEL_PARCHIP_INFO;
#line 1439 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_PORT_INFORMATION {
   PHYSICAL_ADDRESS OriginalController ;
   PUCHAR Controller ;
   ULONG SpanOfController ;
   BOOLEAN (*TryAllocatePort)(PVOID TryAllocateContext ) ;
   void (*FreePort)(PVOID FreeContext ) ;
   ULONG (*QueryNumWaiters)(PVOID QueryAllocsContext ) ;
   PVOID Context ;
};
#line 1448 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_PORT_INFORMATION PARALLEL_PORT_INFORMATION;
#line 1449 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_PORT_INFORMATION *PPARALLEL_PORT_INFORMATION;
#line 1450 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_PNP_INFORMATION {
   PHYSICAL_ADDRESS OriginalEcpController ;
   PUCHAR EcpController ;
   ULONG SpanOfEcpController ;
   ULONG PortNumber ;
   ULONG HardwareCapabilities ;
   NTSTATUS (*TrySetChipMode)(PVOID SetChipContext , UCHAR ChipMode ) ;
   NTSTATUS (*ClearChipMode)(PVOID ClearChipContext , UCHAR ChipMode ) ;
   ULONG FifoDepth ;
   ULONG FifoWidth ;
   PHYSICAL_ADDRESS EppControllerPhysicalAddress ;
   ULONG SpanOfEppController ;
   ULONG Ieee1284_3DeviceCount ;
   NTSTATUS (*TrySelectDevice)(PVOID TrySelectContext , PVOID TrySelectCommand ) ;
   NTSTATUS (*DeselectDevice)(PVOID DeselectContext , PVOID DeselectCommand ) ;
   PVOID Context ;
   ULONG CurrentMode ;
   PWSTR PortName ;
};
#line 1469 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_PNP_INFORMATION PARALLEL_PNP_INFORMATION;
#line 1470 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_PNP_INFORMATION *PPARALLEL_PNP_INFORMATION;
#line 1471 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_1284_COMMAND {
   UCHAR ID ;
   UCHAR Port ;
   ULONG CommandFlags ;
};
#line 1476 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_1284_COMMAND PARALLEL_1284_COMMAND;
#line 1477 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_1284_COMMAND *PPARALLEL_1284_COMMAND;
#line 1478 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_CHIP_MODE {
   UCHAR ModeFlags ;
   BOOLEAN success ;
};
#line 1482 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_CHIP_MODE PARALLEL_CHIP_MODE;
#line 1483 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE {
   BOOLEAN (*InterruptServiceRoutine)(struct _KINTERRUPT *Interrupt , PVOID ServiceContext ) ;
   PVOID InterruptServiceContext ;
   void (*DeferredPortCheckRoutine)(PVOID DeferredContext ) ;
   PVOID DeferredPortCheckContext ;
};
#line 1489 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE PARALLEL_INTERRUPT_SERVICE_ROUTINE;
#line 1490 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE *PPARALLEL_INTERRUPT_SERVICE_ROUTINE;
#line 1491 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARALLEL_INTERRUPT_INFORMATION {
   PKINTERRUPT InterruptObject ;
   BOOLEAN (*TryAllocatePortAtInterruptLevel)(PVOID TryAllocateContext ) ;
   void (*FreePortFromInterruptLevel)(PVOID FreeContext ) ;
   PVOID Context ;
};
#line 1497 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_INTERRUPT_INFORMATION PARALLEL_INTERRUPT_INFORMATION;
#line 1498 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARALLEL_INTERRUPT_INFORMATION *PPARALLEL_INTERRUPT_INFORMATION;
#line 1499 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _MORE_PARALLEL_PORT_INFORMATION {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG InterruptLevel ;
   ULONG InterruptVector ;
   KAFFINITY InterruptAffinity ;
   KINTERRUPT_MODE InterruptMode ;
};
#line 1507 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _MORE_PARALLEL_PORT_INFORMATION MORE_PARALLEL_PORT_INFORMATION;
#line 1508 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _MORE_PARALLEL_PORT_INFORMATION *PMORE_PARALLEL_PORT_INFORMATION;
#line 1509 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct __anonstruct_WMIGUIDREGINFO_114 {
   LPCGUID Guid ;
   ULONG InstanceCount ;
   ULONG Flags ;
};
#line 1514 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct __anonstruct_WMIGUIDREGINFO_114 WMIGUIDREGINFO;
#line 1515 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct __anonstruct_WMIGUIDREGINFO_114 *PWMIGUIDREGINFO;
#line 1516
enum __anonenum_WMIENABLEDISABLECONTROL_115 {
    WmiEventControl = 0,
    WmiDataBlockControl = 1
} ;
#line 1520 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_WMIENABLEDISABLECONTROL_115 WMIENABLEDISABLECONTROL;
#line 1521 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _WMILIB_CONTEXT {
   ULONG GuidCount ;
   PWMIGUIDREGINFO GuidList ;
   NTSTATUS (*QueryWmiRegInfo)(PDEVICE_OBJECT DeviceObject , PULONG RegFlags , PUNICODE_STRING InstanceName ,
                               PUNICODE_STRING *RegistryPath , PUNICODE_STRING MofResourceName ,
                               PDEVICE_OBJECT *Pdo ) ;
   NTSTATUS (*QueryWmiDataBlock)(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                                 ULONG InstanceIndex , ULONG InstanceCount , PULONG InstanceLengthArray ,
                                 ULONG BufferAvail , PUCHAR Buffer ) ;
   NTSTATUS (*SetWmiDataBlock)(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                               ULONG InstanceIndex , ULONG BufferSize , PUCHAR Buffer ) ;
   NTSTATUS (*SetWmiDataItem)(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                              ULONG InstanceIndex , ULONG DataItemId , ULONG BufferSize ,
                              PUCHAR Buffer ) ;
   NTSTATUS (*ExecuteWmiMethod)(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                                ULONG InstanceIndex , ULONG MethodId , ULONG InBufferSize ,
                                ULONG OutBufferSize , PUCHAR Buffer ) ;
   NTSTATUS (*WmiFunctionControl)(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                                  WMIENABLEDISABLECONTROL Function , BOOLEAN Enable ) ;
};
#line 1541 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _WMILIB_CONTEXT WMILIB_CONTEXT;
#line 1542 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _WMILIB_CONTEXT *PWMILIB_CONTEXT;
#line 1543
enum __anonenum_SYSCTL_IRP_DISPOSITION_116 {
    IrpProcessed = 0,
    IrpNotCompleted = 1,
    IrpNotWmi = 2,
    IrpForward = 3
} ;
#line 1549 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_SYSCTL_IRP_DISPOSITION_116 SYSCTL_IRP_DISPOSITION;
#line 1550 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef enum __anonenum_SYSCTL_IRP_DISPOSITION_116 *PSYSCTL_IRP_DISPOSITION;
#line 1551 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _PARPORT_WMI_ALLOC_FREE_COUNTS {
   ULONG PortAllocates ;
   ULONG PortFrees ;
};
#line 1555 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS PARPORT_WMI_ALLOC_FREE_COUNTS;
#line 1556 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _DEVICE_EXTENSION {
   ULONG ExtensionSignatureBegin ;
   ULONG DeviceStateFlags ;
   PDEVICE_OBJECT DeviceObject ;
   PDRIVER_OBJECT DriverObject ;
   PDEVICE_OBJECT PhysicalDeviceObject ;
   PDEVICE_OBJECT ParentDeviceObject ;
   LONG OpenCloseRefCount ;
   LIST_ENTRY RemovalRelationsList ;
   LIST_ENTRY WorkQueue ;
   LONG WorkQueueCount ;
   PARALLEL_PORT_INFORMATION PortInfo ;
   PARALLEL_PNP_INFORMATION PnpInfo ;
   ULONG AddressSpace ;
   ULONG EcpAddressSpace ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   BOOLEAN FoundInterrupt ;
   KIRQL InterruptLevel ;
   ULONG InterruptVector ;
   KAFFINITY InterruptAffinity ;
   KINTERRUPT_MODE InterruptMode ;
   ULONG DmaChannel ;
   ULONG DmaPort ;
   USHORT DmaWidth ;
   LIST_ENTRY IsrList ;
   PKINTERRUPT InterruptObject ;
   ULONG InterruptRefCount ;
   KDPC FreePortDpc ;
   BOOLEAN UnMapRegisters ;
   BOOLEAN NationalChecked ;
   BOOLEAN NationalChipFound ;
   BOOLEAN FilterMode ;
   UCHAR EcrPortData ;
   PARALLEL_PARCHIP_INFO ChipInfo ;
   UNICODE_STRING DeviceName ;
   UNICODE_STRING SymbolicLinkName ;
   DEVICE_POWER_STATE DeviceState ;
   SYSTEM_POWER_STATE SystemState ;
   IO_REMOVE_LOCK RemoveLock ;
   FAST_MUTEX ExtensionFastMutex ;
   FAST_MUTEX OpenCloseMutex ;
   WMILIB_CONTEXT WmiLibContext ;
   PARPORT_WMI_ALLOC_FREE_COUNTS WmiPortAllocFreeCounts ;
   BOOLEAN CheckedForGenericEpp ;
   BOOLEAN spare[3] ;
   ULONG ExtensionSignatureEnd ;
};
#line 1604 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_EXTENSION DEVICE_EXTENSION;
#line 1605 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _DEVICE_EXTENSION *PDEVICE_EXTENSION;
#line 1606 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SYNCHRONIZED_COUNT_CONTEXT {
   PLONG Count ;
   LONG NewCount ;
};
#line 1610 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SYNCHRONIZED_COUNT_CONTEXT SYNCHRONIZED_COUNT_CONTEXT;
#line 1611 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SYNCHRONIZED_LIST_CONTEXT {
   PLIST_ENTRY List ;
   PLIST_ENTRY NewEntry ;
};
#line 1615 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SYNCHRONIZED_LIST_CONTEXT SYNCHRONIZED_LIST_CONTEXT;
#line 1616 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SYNCHRONIZED_LIST_CONTEXT *PSYNCHRONIZED_LIST_CONTEXT;
#line 1617 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _SYNCHRONIZED_DISCONNECT_CONTEXT {
   PDEVICE_EXTENSION Extension ;
   PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo ;
};
#line 1621 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SYNCHRONIZED_DISCONNECT_CONTEXT SYNCHRONIZED_DISCONNECT_CONTEXT;
#line 1622 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _SYNCHRONIZED_DISCONNECT_CONTEXT *PSYNCHRONIZED_DISCONNECT_CONTEXT;
#line 1623 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _ISR_LIST_ENTRY {
   LIST_ENTRY ListEntry ;
   BOOLEAN (*ServiceRoutine)(struct _KINTERRUPT *Interrupt , PVOID ServiceContext ) ;
   PVOID ServiceContext ;
   void (*DeferredPortCheckRoutine)(PVOID DeferredContext ) ;
   PVOID CheckContext ;
};
#line 1630 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _ISR_LIST_ENTRY ISR_LIST_ENTRY;
#line 1631 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _ISR_LIST_ENTRY *PISR_LIST_ENTRY;
#line 1632 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _REMOVAL_RELATIONS_LIST_ENTRY {
   LIST_ENTRY ListEntry ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   UNICODE_STRING DeviceName ;
};
#line 1638 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _REMOVAL_RELATIONS_LIST_ENTRY REMOVAL_RELATIONS_LIST_ENTRY;
#line 1639 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
typedef struct _REMOVAL_RELATIONS_LIST_ENTRY *PREMOVAL_RELATIONS_LIST_ENTRY;
#line 1640
#pragma pack(push,8)
#line 1641
#pragma pack(pop)
#line 1642
struct _KAPC;
#line 1643
struct _KDPC;
#line 1644
#pragma pack(push,4)
#line 1645
#pragma pack(pop)
#line 1646
#pragma pack(push,4)
#line 1647
#pragma pack(pop)
#line 1648
#pragma pack(push,1)
#line 1649
#pragma pack(pop)
#line 1650
struct _DRIVER_OBJECT;
#line 1651
struct _DEVICE_OBJECT;
#line 1652
struct _DRIVER_OBJECT;
#line 1653
struct _FILE_OBJECT;
#line 1654
struct _IRP;
#line 1655
struct _SCSI_REQUEST_BLOCK;
#line 1656
#pragma pack(push,4)
#line 1657
#pragma pack(pop)
#line 1658
#pragma pack(push,8)
#line 1659
#pragma pack(pop)
#line 1660
struct _KAPC;
#line 1661
struct _KDPC;
#line 1662
#pragma pack(push,4)
#line 1663
#pragma pack(pop)
#line 1664
#pragma pack(push,4)
#line 1665
#pragma pack(pop)
#line 1666
#pragma pack(push,1)
#line 1667
#pragma pack(pop)
#line 1668
struct _DRIVER_OBJECT;
#line 1669
struct _DEVICE_OBJECT;
#line 1670
struct _DRIVER_OBJECT;
#line 1671
struct _FILE_OBJECT;
#line 1672
struct _IRP;
#line 1673
struct _SCSI_REQUEST_BLOCK;
#line 1674
#pragma pack(push,4)
#line 1675
#pragma pack(pop)
#line 1676
#pragma pack(push,8)
#line 1677
#pragma pack(pop)
#line 1678
struct _KAPC;
#line 1679
struct _KDPC;
#line 1680
#pragma pack(push,4)
#line 1681
#pragma pack(pop)
#line 1682
#pragma pack(push,4)
#line 1683
#pragma pack(pop)
#line 1684
#pragma pack(push,1)
#line 1685
#pragma pack(pop)
#line 1686
struct _DRIVER_OBJECT;
#line 1687
struct _DEVICE_OBJECT;
#line 1688
struct _DRIVER_OBJECT;
#line 1689
struct _FILE_OBJECT;
#line 1690
struct _IRP;
#line 1691
struct _SCSI_REQUEST_BLOCK;
#line 1692
#pragma pack(push,4)
#line 1693
#pragma pack(pop)
#line 1694
#pragma pack(push,8)
#line 1695
#pragma pack(pop)
#line 1696
struct _KAPC;
#line 1697
struct _KDPC;
#line 1698
#pragma pack(push,4)
#line 1699
#pragma pack(pop)
#line 1700
#pragma pack(push,4)
#line 1701
#pragma pack(pop)
#line 1702
#pragma pack(push,1)
#line 1703
#pragma pack(pop)
#line 1704
struct _DRIVER_OBJECT;
#line 1705
struct _DEVICE_OBJECT;
#line 1706
struct _DRIVER_OBJECT;
#line 1707
struct _FILE_OBJECT;
#line 1708
struct _IRP;
#line 1709
struct _SCSI_REQUEST_BLOCK;
#line 1710
#pragma pack(push,4)
#line 1711
#pragma pack(pop)
#line 1712
#pragma pack(push,8)
#line 1713
#pragma pack(pop)
#line 1714
struct _KAPC;
#line 1715
struct _KDPC;
#line 1716
#pragma pack(push,4)
#line 1717
#pragma pack(pop)
#line 1718
#pragma pack(push,4)
#line 1719
#pragma pack(pop)
#line 1720
#pragma pack(push,1)
#line 1721
#pragma pack(pop)
#line 1722
struct _DRIVER_OBJECT;
#line 1723
struct _DEVICE_OBJECT;
#line 1724
struct _DRIVER_OBJECT;
#line 1725
struct _FILE_OBJECT;
#line 1726
struct _IRP;
#line 1727
struct _SCSI_REQUEST_BLOCK;
#line 1728
#pragma pack(push,4)
#line 1729
#pragma pack(pop)
#line 1730
#pragma pack(push,8)
#line 1731
#pragma pack(pop)
#line 1732
struct _KAPC;
#line 1733
struct _KDPC;
#line 1734
#pragma pack(push,4)
#line 1735
#pragma pack(pop)
#line 1736
#pragma pack(push,4)
#line 1737
#pragma pack(pop)
#line 1738
#pragma pack(push,1)
#line 1739
#pragma pack(pop)
#line 1740
struct _DRIVER_OBJECT;
#line 1741
struct _DEVICE_OBJECT;
#line 1742
struct _DRIVER_OBJECT;
#line 1743
struct _FILE_OBJECT;
#line 1744
struct _IRP;
#line 1745
struct _SCSI_REQUEST_BLOCK;
#line 1746
#pragma pack(push,4)
#line 1747
#pragma pack(pop)
#line 1748
#pragma pack(push,8)
#line 1749
#pragma pack(pop)
#line 1750
struct _KAPC;
#line 1751
struct _KDPC;
#line 1752
#pragma pack(push,4)
#line 1753
#pragma pack(pop)
#line 1754
#pragma pack(push,4)
#line 1755
#pragma pack(pop)
#line 1756
#pragma pack(push,1)
#line 1757
#pragma pack(pop)
#line 1758
struct _DRIVER_OBJECT;
#line 1759
struct _DEVICE_OBJECT;
#line 1760
struct _DRIVER_OBJECT;
#line 1761
struct _FILE_OBJECT;
#line 1762
struct _IRP;
#line 1763
struct _SCSI_REQUEST_BLOCK;
#line 1764
#pragma pack(push,4)
#line 1765
#pragma pack(pop)
#line 1766
#pragma pack(push,8)
#line 1767
#pragma pack(pop)
#line 1768
struct _KAPC;
#line 1769
struct _KDPC;
#line 1770
#pragma pack(push,4)
#line 1771
#pragma pack(pop)
#line 1772
#pragma pack(push,4)
#line 1773
#pragma pack(pop)
#line 1774
#pragma pack(push,1)
#line 1775
#pragma pack(pop)
#line 1776
struct _DRIVER_OBJECT;
#line 1777
struct _DEVICE_OBJECT;
#line 1778
struct _DRIVER_OBJECT;
#line 1779
struct _FILE_OBJECT;
#line 1780
struct _IRP;
#line 1781
struct _SCSI_REQUEST_BLOCK;
#line 1782
#pragma pack(push,4)
#line 1783
#pragma pack(pop)
#line 1784
#pragma pack(push,8)
#line 1785
#pragma pack(pop)
#line 1786
struct _KAPC;
#line 1787
struct _KDPC;
#line 1788
#pragma pack(push,4)
#line 1789
#pragma pack(pop)
#line 1790
#pragma pack(push,4)
#line 1791
#pragma pack(pop)
#line 1792
#pragma pack(push,1)
#line 1793
#pragma pack(pop)
#line 1794
struct _DRIVER_OBJECT;
#line 1795
struct _DEVICE_OBJECT;
#line 1796
struct _DRIVER_OBJECT;
#line 1797
struct _FILE_OBJECT;
#line 1798
struct _IRP;
#line 1799
struct _SCSI_REQUEST_BLOCK;
#line 1800
#pragma pack(push,4)
#line 1801
#pragma pack(pop)
#line 1802
#pragma pack(push,8)
#line 1803
#pragma pack(pop)
#line 1804
struct _KAPC;
#line 1805
struct _KDPC;
#line 1806
#pragma pack(push,4)
#line 1807
#pragma pack(pop)
#line 1808
#pragma pack(push,4)
#line 1809
#pragma pack(pop)
#line 1810
#pragma pack(push,1)
#line 1811
#pragma pack(pop)
#line 1812
struct _DRIVER_OBJECT;
#line 1813
struct _DEVICE_OBJECT;
#line 1814
struct _DRIVER_OBJECT;
#line 1815
struct _FILE_OBJECT;
#line 1816
struct _IRP;
#line 1817
struct _SCSI_REQUEST_BLOCK;
#line 1818
#pragma pack(push,4)
#line 1819
#pragma pack(pop)
#line 1820
#pragma pack(push,8)
#line 1821
#pragma pack(pop)
#line 1822
struct _KAPC;
#line 1823
struct _KDPC;
#line 1824
#pragma pack(push,4)
#line 1825
#pragma pack(pop)
#line 1826
#pragma pack(push,4)
#line 1827
#pragma pack(pop)
#line 1828
#pragma pack(push,1)
#line 1829
#pragma pack(pop)
#line 1830
struct _DRIVER_OBJECT;
#line 1831
struct _DEVICE_OBJECT;
#line 1832
struct _DRIVER_OBJECT;
#line 1833
struct _FILE_OBJECT;
#line 1834
struct _IRP;
#line 1835
struct _SCSI_REQUEST_BLOCK;
#line 1836
#pragma pack(push,4)
#line 1837
#pragma pack(pop)
#line 1838
#pragma pack(push,8)
#line 1839
#pragma pack(pop)
#line 1840
struct _KAPC;
#line 1841
struct _KDPC;
#line 1842
#pragma pack(push,4)
#line 1843
#pragma pack(pop)
#line 1844
#pragma pack(push,4)
#line 1845
#pragma pack(pop)
#line 1846
#pragma pack(push,1)
#line 1847
#pragma pack(pop)
#line 1848
struct _DRIVER_OBJECT;
#line 1849
struct _DEVICE_OBJECT;
#line 1850
struct _DRIVER_OBJECT;
#line 1851
struct _FILE_OBJECT;
#line 1852
struct _IRP;
#line 1853
struct _SCSI_REQUEST_BLOCK;
#line 1854
#pragma pack(push,4)
#line 1855
#pragma pack(pop)
#line 1856
#pragma pack(push,8)
#line 1857
#pragma pack(pop)
#line 1858
struct _KAPC;
#line 1859
struct _KDPC;
#line 1860
#pragma pack(push,4)
#line 1861
#pragma pack(pop)
#line 1862
#pragma pack(push,4)
#line 1863
#pragma pack(pop)
#line 1864
#pragma pack(push,1)
#line 1865
#pragma pack(pop)
#line 1866
struct _DRIVER_OBJECT;
#line 1867
struct _DEVICE_OBJECT;
#line 1868
struct _DRIVER_OBJECT;
#line 1869
struct _FILE_OBJECT;
#line 1870
struct _IRP;
#line 1871
struct _SCSI_REQUEST_BLOCK;
#line 1872
#pragma pack(push,4)
#line 1873
#pragma pack(pop)
#line 1874
#pragma pack(push,8)
#line 1875
#pragma pack(pop)
#line 1876
struct _KAPC;
#line 1877
struct _KDPC;
#line 1878
#pragma pack(push,4)
#line 1879
#pragma pack(pop)
#line 1880
#pragma pack(push,4)
#line 1881
#pragma pack(pop)
#line 1882
#pragma pack(push,1)
#line 1883
#pragma pack(pop)
#line 1884
struct _DRIVER_OBJECT;
#line 1885
struct _DEVICE_OBJECT;
#line 1886
struct _DRIVER_OBJECT;
#line 1887
struct _FILE_OBJECT;
#line 1888
struct _IRP;
#line 1889
struct _SCSI_REQUEST_BLOCK;
#line 1890
#pragma pack(push,4)
#line 1891
#pragma pack(pop)
#line 1892
#pragma pack(push,8)
#line 1893
#pragma pack(pop)
#line 1894
struct _KAPC;
#line 1895
struct _KDPC;
#line 1896
#pragma pack(push,4)
#line 1897
#pragma pack(pop)
#line 1898
#pragma pack(push,4)
#line 1899
#pragma pack(pop)
#line 1900
#pragma pack(push,1)
#line 1901
#pragma pack(pop)
#line 1902
struct _DRIVER_OBJECT;
#line 1903
struct _DEVICE_OBJECT;
#line 1904
struct _DRIVER_OBJECT;
#line 1905
struct _FILE_OBJECT;
#line 1906
struct _IRP;
#line 1907
struct _SCSI_REQUEST_BLOCK;
#line 1908
#pragma pack(push,4)
#line 1909
#pragma pack(pop)
#line 1910
#pragma pack(push,8)
#line 1911
#pragma pack(pop)
#line 1912
struct _KAPC;
#line 1913
struct _KDPC;
#line 1914
#pragma pack(push,4)
#line 1915
#pragma pack(pop)
#line 1916
#pragma pack(push,4)
#line 1917
#pragma pack(pop)
#line 1918
#pragma pack(push,1)
#line 1919
#pragma pack(pop)
#line 1920
struct _DRIVER_OBJECT;
#line 1921
struct _DEVICE_OBJECT;
#line 1922
struct _DRIVER_OBJECT;
#line 1923
struct _FILE_OBJECT;
#line 1924
struct _IRP;
#line 1925
struct _SCSI_REQUEST_BLOCK;
#line 1926
#pragma pack(push,4)
#line 1927
#pragma pack(pop)
#line 1932
#pragma warning(push)
#line 1933
#pragma warning(disable:4035)
#line 1934
#pragma warning(pop)
#line 1936
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 1937
extern void *memset(void * , int  , size_t  ) ;
#line 1938
extern void *memmove(void * , void const   * , size_t  ) ;
#line 1939
#pragma warning(disable:4103)
#line 1940
#pragma warning(disable:4103)
#line 1941
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) ;
#line 1946
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) ;
#line 1949
extern NTSTATUS RtlIntegerToUnicodeString(ULONG Value , ULONG Base , PUNICODE_STRING String ) ;
#line 1952
extern NTSTATUS RtlUnicodeStringToInteger(PUNICODE_STRING String , ULONG Base , PULONG Value ) ;
#line 1955
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) ;
#line 1957
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) ;
#line 1959
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) ;
#line 1962
extern LONG RtlCompareUnicodeString(PUNICODE_STRING String1 , PUNICODE_STRING String2 ,
                                    BOOLEAN CaseInSensitive ) ;
#line 1965
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) ;
#line 1967
extern NTSTATUS RtlAppendUnicodeStringToString(PUNICODE_STRING Destination , PUNICODE_STRING Source ) ;
#line 1969
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) ;
#line 1970
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) ;
#line 1973
#pragma warning(push)
#line 1974
#pragma warning(disable:4035)
#line 1975
#pragma warning(pop)
#line 1976
extern UCHAR READ_PORT_UCHAR(PUCHAR Port ) ;
#line 1977
extern void WRITE_PORT_UCHAR(PUCHAR Port , UCHAR Value ) ;
#line 1978
extern LONG InterlockedIncrement(PLONG Addend ) ;
#line 1979
extern LONG InterlockedDecrement(PLONG Addend ) ;
#line 1980
extern LONG InterlockedExchange(PLONG Target , LONG Value ) ;
#line 1982
#pragma warning(disable:4035)
#line 1983
#pragma warning(push)
#line 1984
#pragma warning(disable:4164)
#line 1985
#pragma function(_enable)
#line 1986
#pragma function(_disable)
#line 1987
#pragma warning(pop)
#line 1988
#pragma warning(disable:4103)
#line 1989
#pragma warning(disable:4103)
#line 1990
#pragma warning(disable:4103)
#line 1991
#pragma warning(disable:4103)
#line 1992
extern void KeInitializeDpc(PRKDPC Dpc , void (*DeferredRoutine)(struct _KDPC *Dpc ,
                                                                 PVOID DeferredContext ,
                                                                 PVOID SystemArgument1 ,
                                                                 PVOID SystemArgument2 ) ,
                            PVOID DeferredContext ) ;
#line 1997
extern BOOLEAN KeInsertQueueDpc(PRKDPC Dpc , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
#line 1999
extern BOOLEAN KeSynchronizeExecution(PKINTERRUPT Interrupt , BOOLEAN (*SynchronizeRoutine)(PVOID SynchronizeContext ) ,
                                      PVOID SynchronizeContext ) ;
#line 2002
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) ;
#line 2004
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) ;
#line 2006
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) ;
#line 2008
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) ;
#line 2010
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) ;
#line 2013
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) ;
#line 2017
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 2018
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) ;
#line 2020
extern ULONG KeQueryTimeIncrement(void) ;
#line 2021
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
#line 2024
void ExFreePool(PVOID P ) ;
#line 2025
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) ;
#line 2026
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) ;
#line 2027
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 2030
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 2033
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) ;
#line 2035
void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 2036
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) ;
#line 2042
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 2044
void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 2045
void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 2046
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 2047
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) ;
#line 2054
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#line 2055
#pragma warning(disable:4103)
#line 2056
#pragma warning(disable:4103)
#line 2057
extern void IoAcquireCancelSpinLock(PKIRQL Irql ) ;
#line 2058
extern PVOID IoAllocateErrorLogEntry(PVOID IoObject , UCHAR EntrySize ) ;
#line 2060
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) ;
#line 2063
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 2065
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 2071
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 2080
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2082
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) ;
#line 2084
extern NTSTATUS IoConnectInterrupt(PKINTERRUPT *InterruptObject , BOOLEAN (*ServiceRoutine)(struct _KINTERRUPT *Interrupt ,
                                                                                            PVOID ServiceContext ) ,
                                   PVOID ServiceContext , PKSPIN_LOCK SpinLock , ULONG Vector ,
                                   KIRQL Irql , KIRQL SynchronizeIrql , KINTERRUPT_MODE InterruptMode ,
                                   BOOLEAN ShareVector , KAFFINITY ProcessorEnableMask ,
                                   BOOLEAN FloatingSave ) ;
#line 2095
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
#line 2100
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 2102
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 2103
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
#line 2104
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 2105
extern void IoDisconnectInterrupt(PKINTERRUPT InterruptObject ) ;
#line 2106
void IoFreeIrp(PIRP Irp ) ;
#line 2107
void IoFreeMdl(PMDL Mdl ) ;
#line 2108
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
#line 2109
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) ;
#line 2127
void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 2128
extern NTSTATUS IoReportResourceUsage(PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
                                      PCM_RESOURCE_LIST DriverList , ULONG DriverListSize ,
                                      PDEVICE_OBJECT DeviceObject , PCM_RESOURCE_LIST DeviceList ,
                                      ULONG DeviceListSize , BOOLEAN OverrideConflict ,
                                      PBOOLEAN ConflictDetected ) ;
#line 2137
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
#line 2138
extern void IoInitializeRemoveLockEx(PIO_REMOVE_LOCK Lock , ULONG AllocateTag , ULONG MaxLockedMinutes ,
                                     ULONG HighWatermark , ULONG RemlockSize ) ;
#line 2143
NTSTATUS IoAcquireRemoveLockEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag , PCSTR File ,
                               ULONG Line , ULONG RemlockSize ) ;
#line 2148
extern void IoReleaseRemoveLockEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag , ULONG RemlockSize ) ;
#line 2151
extern void IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ,
                                         ULONG RemlockSize ) ;
#line 2154
extern void IoWriteErrorLogEntry(PVOID ElEntry ) ;
#line 2155
extern NTSTATUS IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject , ULONG Action ) ;
#line 2157
extern NTSTATUS IoOpenDeviceRegistryKey(PDEVICE_OBJECT DeviceObject , ULONG DevInstKeyType ,
                                        ACCESS_MASK DesiredAccess , PHANDLE DevInstRegKey ) ;
#line 2161
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) ;
#line 2165
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) ;
#line 2167
extern void KeStallExecutionProcessor(ULONG MicroSeconds ) ;
#line 2168
#pragma warning(disable:4200)
#line 2169
#pragma warning(default:4200)
#line 2170
extern NTSTATUS PoRequestPowerIrp(PDEVICE_OBJECT DeviceObject , UCHAR MinorFunction ,
                                  POWER_STATE PowerState , void (*CompletionFunction)(PDEVICE_OBJECT DeviceObject ,
                                                                                      UCHAR MinorFunction ,
                                                                                      POWER_STATE PowerState ,
                                                                                      PVOID Context ,
                                                                                      PIO_STATUS_BLOCK IoStatus ) ,
                                  PVOID Context , PIRP *Irp ) ;
#line 2180
extern POWER_STATE PoSetPowerState(PDEVICE_OBJECT DeviceObject , POWER_STATE_TYPE Type ,
                                   POWER_STATE State ) ;
#line 2183
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2185
void PoStartNextPowerIrp(PIRP Irp ) ;
#line 2186
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) ;
#line 2192
extern void ObfReferenceObject(PVOID Object ) ;
#line 2193
void ObfDereferenceObject(PVOID Object ) ;
#line 2194
NTSTATUS ZwClose(HANDLE Handle ) ;
#line 2195
extern NTSTATUS ZwQueryValueKey(HANDLE KeyHandle , PUNICODE_STRING ValueName , KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass ,
                                PVOID KeyValueInformation , ULONG Length , PULONG ResultLength ) ;
#line 2201
extern NTSTATUS ZwSetValueKey(HANDLE KeyHandle , PUNICODE_STRING ValueName , ULONG TitleIndex ,
                              ULONG Type , PVOID Data , ULONG DataSize ) ;
#line 2207
struct _GUID  const  GUID_PARALLEL_DEVICE ;
#line 2208
struct _GUID  const  GUID_PARCLASS_DEVICE ;
#line 2210
extern NTSTATUS WmiCompleteRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp , NTSTATUS Status ,
                                   ULONG BufferUsed , CCHAR PriorityBoost ) ;
#line 2212
NTSTATUS WmiSystemControl(PWMILIB_CONTEXT WmiLibInfo , PDEVICE_OBJECT DeviceObject ,
                          PIRP Irp , PSYSCTL_IRP_DISPOSITION IrpDisposition ) ;
#line 2214
void PptCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) ;
#line 2215
ULONG PptDebugLevel ;
#line 2216
ULONG PptBreakOn ;
#line 2217
UNICODE_STRING RegistryPath ;
#line 2218
UCHAR PptDot3Retries ;
#line 2219
union _LARGE_INTEGER  const  PhysicalZero ;
#line 2220
LONG PortInfoReferenceCount ;
#line 2221
PFAST_MUTEX PortInfoMutex ;
#line 2222
extern int s ;
#line 2223 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int UNLOADED  ;
#line 2224 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int NP  ;
#line 2225 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int DC  ;
#line 2226 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int SKIP1  ;
#line 2227 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int SKIP2  ;
#line 2228 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int MPR1  ;
#line 2229 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int MPR3  ;
#line 2230 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int IPC  ;
#line 2231 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int pended  ;
#line 2232 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context )  ;
#line 2233 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int compRegistered  ;
#line 2234 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int lowerDriverReturn  ;
#line 2235 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int setEventCalled  ;
#line 2236 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int customIrp  ;
#line 2237 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int myStatus  ;
#line 2238 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int routine  ;
#line 2239 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void errorFn(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 2247
NTSTATUS PptWmiInitWmi(PDEVICE_OBJECT DeviceObject ) ;
#line 2248
NTSTATUS PptDispatchSystemControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2249
void PptPnpInitDispatchFunctionTable(void) ;
#line 2250
NTSTATUS PptPnpAddDevice(PDRIVER_OBJECT pDriverObject , PDEVICE_OBJECT pPhysicalDeviceObject ) ;
#line 2251
NTSTATUS PptDispatchPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2252
NTSTATUS PptFailRequest(PIRP Irp , NTSTATUS Status ) ;
#line 2253
NTSTATUS PptDispatchPreProcessIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2254
NTSTATUS PptDispatchPostProcessIrp(void) ;
#line 2255
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING pRegistryPath ) ;
#line 2256
void PptUnload(PDRIVER_OBJECT DriverObject ) ;
#line 2257
NTSTATUS PptSynchCompletionRoutine(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT Event ) ;
#line 2258
void PptLogError(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT DeviceObject , PHYSICAL_ADDRESS P1 ,
                 PHYSICAL_ADDRESS P2 , ULONG SequenceNumber , UCHAR MajorFunctionCode ,
                 UCHAR RetryCount , ULONG UniqueErrorValue , NTSTATUS FinalStatus ,
                 NTSTATUS SpecificIOStatus ) ;
#line 2262
NTSTATUS PptConnectInterrupt(PDEVICE_EXTENSION Extension ) ;
#line 2263
void PptDisconnectInterrupt(PDEVICE_EXTENSION Extension ) ;
#line 2264
NTSTATUS PptDispatchCreate(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2265
NTSTATUS PptDispatchClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2266
BOOLEAN PptSynchronizedIncrement(PVOID SyncContext ) ;
#line 2267
BOOLEAN PptSynchronizedDecrement(PVOID SyncContext ) ;
#line 2268
BOOLEAN PptSynchronizedRead(PVOID SyncContext ) ;
#line 2269
BOOLEAN PptSynchronizedQueue(PVOID Context ) ;
#line 2270
BOOLEAN PptSynchronizedDisconnect(PVOID Context ) ;
#line 2271
void PptCancelRoutine(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2272
void PptFreePortDpc(PKDPC Dpc , PVOID Extension , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
#line 2273
BOOLEAN PptTryAllocatePortAtInterruptLevel(PVOID Context ) ;
#line 2274
void PptFreePortFromInterruptLevel(PVOID Context ) ;
#line 2275
BOOLEAN PptInterruptService(PKINTERRUPT Interrupt , PVOID Extension ) ;
#line 2276
BOOLEAN PptTryAllocatePort(PVOID Extension ) ;
#line 2277
BOOLEAN PptTraversePortCheckList(PVOID Extension ) ;
#line 2278
void PptFreePort(PVOID Extension ) ;
#line 2279
ULONG PptQueryNumWaiters(PVOID Extension ) ;
#line 2280
NTSTATUS PptDispatchInternalDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2281
NTSTATUS PptDispatchCleanup(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2282
BOOLEAN PptIsNecR98Machine(void) ;
#line 2283
NTSTATUS PptDispatchPower(PDEVICE_OBJECT pDeviceObject , PIRP pIrp ) ;
#line 2284
void PptRegInitDriverSettings(PUNICODE_STRING RegistryPath___0 ) ;
#line 2285
PWSTR PptGetPortNameFromPhysicalDeviceObject(PDEVICE_OBJECT PhysicalDeviceObject ) ;
#line 2286
PVOID PptSetCancelRoutine(PIRP Irp , void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject ,
                                                           struct _IRP *Irp ) ) ;
#line 2288
NTSTATUS PptAcquireRemoveLockOrFailIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2289
void PptDebugDumpPnpIrpInfo(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2290
NTSTATUS PptAcquireRemoveLock(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) ;
#line 2291
void PptReleaseRemoveLock(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) ;
#line 2292
void PptReleaseRemoveLockAndWait(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) ;
#line 2293
void PptDebugDumpResourceList(PIO_RESOURCE_LIST ResourceList ) ;
#line 2294
void PptDebugDumpResourceRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) ;
#line 2295
NTSTATUS PptDetectChipFilter(PDEVICE_EXTENSION Extension ) ;
#line 2296
NTSTATUS PptDetectPortType(PDEVICE_EXTENSION Extension ) ;
#line 2297
NTSTATUS PptSetChipMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) ;
#line 2298
NTSTATUS PptClearChipMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) ;
#line 2299
ULONG PptInitiate1284_3(PVOID Extension ) ;
#line 2300
NTSTATUS PptTrySelectDevice(PVOID Context , PVOID TrySelectCommand ) ;
#line 2301
NTSTATUS PptDeselectDevice(PVOID Context , PVOID DeselectCommand ) ;
#line 2302
ULONG Ppt1284_3AssignAddress(PDEVICE_EXTENSION DeviceExtension ) ;
#line 2303
BOOLEAN PptSend1284_3Command(PDEVICE_EXTENSION DeviceExtension , UCHAR Command ) ;
#line 2304
NTSTATUS PptTrySelectLegacyZip(PVOID Context , PVOID TrySelectCommand ) ;
#line 2305
NTSTATUS PptDeselectLegacyZip(PVOID Context , PVOID DeselectCommand ) ;
#line 2306
void PptDumpRemovalRelationsList(PDEVICE_EXTENSION Extension ) ;
#line 2307
NTSTATUS PptRegGetDeviceParameterDword(PDEVICE_OBJECT Pdo , PWSTR ParameterName ,
                                       PULONG ParameterValue ) ;
#line 2309
NTSTATUS PptRegSetDeviceParameterDword(PDEVICE_OBJECT Pdo , PWSTR ParameterName ,
                                       PULONG ParameterValue ) ;
#line 2311
NTSTATUS PptBuildParallelPortDeviceName(ULONG Number , PUNICODE_STRING DeviceName ) ;
#line 2312
NTSTATUS PptInitializeDeviceExtension(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ,
                                      PDEVICE_OBJECT DeviceObject , PUNICODE_STRING UniNameString ,
                                      PWSTR PortName , ULONG PortNumber ) ;
#line 2315
NTSTATUS PptGetPortNumberFromLptName(PWSTR PortName , PULONG PortNumber ) ;
#line 2316
PDEVICE_OBJECT PptBuildDeviceObject(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) ;
#line 2317
void PptDetectEppPort(PDEVICE_EXTENSION Extension ) ;
#line 2318
void PptCleanRemovalRelationsList(PDEVICE_EXTENSION Extension ) ;
#line 2319
BOOLEAN CheckPort(PUCHAR wPortAddr , UCHAR bMask , UCHAR bValue , USHORT usTimeDelay ) ;
#line 2320 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchCleanup(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  KIRQL cancelIrql ;

  {
#line 2325
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 2328
  if (extension->DeviceStateFlags & 4096UL) {
    goto targetExit;
  } else {

  }
  {
#line 2334
  IoAcquireCancelSpinLock(& cancelIrql);
  }
  targetExit: 
  {
#line 2339
  myStatus = 0;
#line 2340
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 2341
  Irp->IoStatus.Information = 0UL;
#line 2342
  PptCompleteRequest(Irp, (char)0);
  }
#line 2344
  return (0L);
}
}
#line 2351
#pragma warning(push)
#line 2352
#pragma warning(disable:4035)
#line 2353
#pragma warning(pop)
#line 2355
#pragma warning(disable:4103)
#line 2356
#pragma warning(disable:4103)
#line 2357
#pragma warning(push)
#line 2358
#pragma warning(disable:4035)
#line 2359
#pragma warning(pop)
#line 2360
#pragma warning(disable:4035)
#line 2361
#pragma warning(push)
#line 2362
#pragma warning(disable:4164)
#line 2363
#pragma function(_enable)
#line 2364
#pragma function(_disable)
#line 2365
#pragma warning(pop)
#line 2366
#pragma warning(disable:4103)
#line 2367
#pragma warning(disable:4103)
#line 2368
#pragma warning(disable:4103)
#line 2369
#pragma warning(disable:4103)
#line 2370
#pragma warning(disable:4103)
#line 2371
#pragma warning(disable:4103)
#line 2372
#pragma warning(disable:4200)
#line 2373
#pragma warning(default:4200)
#line 2375 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PCHAR PnpIrpName[25]  = 
#line 2375
  {      (PCHAR )"IRP_MN_START_DEVICE                 0x00",      (PCHAR )"IRP_MN_QUERY_REMOVE_DEVICE          0x01",      (PCHAR )"IRP_MN_REMOVE_DEVICE                0x02",      (PCHAR )"IRP_MN_CANCEL_REMOVE_DEVICE         0x03", 
        (PCHAR )"IRP_MN_STOP_DEVICE                  0x04",      (PCHAR )"IRP_MN_QUERY_STOP_DEVICE            0x05",      (PCHAR )"IRP_MN_CANCEL_STOP_DEVICE           0x06",      (PCHAR )"IRP_MN_QUERY_DEVICE_RELATIONS       0x07", 
        (PCHAR )"IRP_MN_QUERY_INTERFACE              0x08",      (PCHAR )"IRP_MN_QUERY_CAPABILITIES           0x09",      (PCHAR )"IRP_MN_QUERY_RESOURCES              0x0A",      (PCHAR )"IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B", 
        (PCHAR )"IRP_MN_QUERY_DEVICE_TEXT            0x0C",      (PCHAR )"IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D",      (PCHAR )" unused MinorFunction               0x0E",      (PCHAR )"IRP_MN_READ_CONFIG                  0x0F", 
        (PCHAR )"IRP_MN_WRITE_CONFIG                 0x10",      (PCHAR )"IRP_MN_EJECT                        0x11",      (PCHAR )"IRP_MN_SET_LOCK                     0x12",      (PCHAR )"IRP_MN_QUERY_ID                     0x13", 
        (PCHAR )"IRP_MN_QUERY_PNP_DEVICE_STATE       0x14",      (PCHAR )"IRP_MN_QUERY_BUS_INFORMATION        0x15",      (PCHAR )"IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16",      (PCHAR )"IRP_MN_SURPRISE_REMOVAL             0x17", 
        (PCHAR )"IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18"};
#line 2383 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDebugDumpPnpIrpInfo(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  PIO_STACK_LOCATION irpStack ;
  PCHAR irpName ;

  {
#line 2389
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 2390
  irpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 2391
  if ((int )irpStack->MinorFunction <= 24) {
#line 2392
    irpName = PnpIrpName[irpStack->MinorFunction];
  } else {
#line 2396
    irpName = (CHAR *)" - MinorFunction > 0x18 - don\'t handle  ";
  }
#line 2400
  return;
}
}
#line 2403 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptAcquireRemoveLock(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) 
{ NTSTATUS status ;

  {
  {
#line 2408
  status = IoAcquireRemoveLockEx(RemoveLock, Tag, "debug.c", 69UL, (unsigned long )sizeof(IO_REMOVE_LOCK ));
  }
#line 2410
  return (status);
}
}
#line 2413 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptReleaseRemoveLock(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) 
{ 

  {
  {
#line 2418
  IoReleaseRemoveLockEx(RemoveLock, Tag, (unsigned long )sizeof(IO_REMOVE_LOCK ));
  }
#line 2420
  return;
}
}
#line 2423 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptReleaseRemoveLockAndWait(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ) 
{ 

  {
  {
#line 2428
  IoReleaseRemoveLockAndWaitEx(RemoveLock, Tag, (unsigned long )sizeof(IO_REMOVE_LOCK ));
  }
#line 2430
  return;
}
}
#line 2433 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDebugDumpResourceList(PIO_RESOURCE_LIST ResourceList ) 
{ ULONG count ;
  ULONG i ;
  PIO_RESOURCE_DESCRIPTOR curDesc ;

  {
#line 2439
  count = ResourceList->Count;
#line 2442
  i = 0UL;
#line 2443
  curDesc = ResourceList->Descriptors;
  {
#line 2445
  while (1) {
    while_0_continue: /* CIL Label */ ;

#line 2447
    if (i < count) {

    } else {
      goto while_4_break;
    }
#line 2452
    if ((int )curDesc->Type == 2) {
      goto switch_5_2;
    } else {
#line 2455
      if ((int )curDesc->Type == 4) {
        goto switch_5_4;
      } else {
#line 2458
        if ((int )curDesc->Type == 1) {
          goto switch_5_1;
        } else {
#line 2461
          if ((int )curDesc->Type == 0) {
            goto switch_5_0;
          } else {
            goto switch_5_default;
#line 2466
            if (0) {
              switch_5_2: ;
              goto switch_5_break;
              switch_5_4: ;
              goto switch_5_break;
              switch_5_1: ;
              goto switch_5_break;
              switch_5_0: ;
              goto switch_5_break;
              switch_5_default: ;
            } else {
              switch_5_break: ;
            }
          }
        }
      }
    }
#line 2494
    i += 1UL;
#line 2495
    curDesc += 1;
  }
  while_0_break: /* CIL Label */ ;
  }
  while_4_break: ;
#line 2499
  return;
}
}
#line 2502 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDebugDumpResourceRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) 
{ ULONG listCount ;
  PIO_RESOURCE_LIST curList ;
  ULONG i ;

  {
#line 2508
  listCount = ResourceRequirementsList->AlternativeLists;
#line 2511
  i = 0UL;
#line 2512
  curList = ResourceRequirementsList->List;
  {
#line 2514
  while (1) {
    while_1_continue: /* CIL Label */ ;

#line 2516
    if (i < listCount) {

    } else {
      goto while_12_break;
    }
    {
#line 2524
    PptDebugDumpResourceList(curList);
#line 2525
    curList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 2526
    i += 1UL;
    }
  }
  while_1_break: /* CIL Label */ ;
  }
  while_12_break: ;
#line 2531
  return;
}
}
#line 2538
#pragma warning(push)
#line 2539
#pragma warning(disable:4035)
#line 2540
#pragma warning(pop)
#line 2542
#pragma warning(disable:4103)
#line 2543
#pragma warning(disable:4103)
#line 2544
#pragma warning(push)
#line 2545
#pragma warning(disable:4035)
#line 2546
#pragma warning(pop)
#line 2547
#pragma warning(disable:4035)
#line 2548
#pragma warning(push)
#line 2549
#pragma warning(disable:4164)
#line 2550
#pragma function(_enable)
#line 2551
#pragma function(_disable)
#line 2552
#pragma warning(pop)
#line 2553
#pragma warning(disable:4103)
#line 2554
#pragma warning(disable:4103)
#line 2555
#pragma warning(disable:4103)
#line 2556
#pragma warning(disable:4103)
#line 2557
#pragma warning(disable:4103)
#line 2558
#pragma warning(disable:4103)
#line 2559
#pragma warning(disable:4200)
#line 2560
#pragma warning(default:4200)
#line 2562 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptLogError(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT DeviceObject , PHYSICAL_ADDRESS P1 ,
                 PHYSICAL_ADDRESS P2 , ULONG SequenceNumber , UCHAR MajorFunctionCode ,
                 UCHAR RetryCount , ULONG UniqueErrorValue , NTSTATUS FinalStatus ,
                 NTSTATUS SpecificIOStatus ) 
{ PIO_ERROR_LOG_PACKET ErrorLogEntry ;
  PVOID ObjectToUse ;
  SHORT DumpToAllocate ;
  PVOID tmp ;

  {
#line 2574
  if ((unsigned int )((CHAR *)DeviceObject) != (unsigned int )((CHAR *)((void *)0))) {
#line 2575
    ObjectToUse = (void *)DeviceObject;
  } else {
#line 2577
    ObjectToUse = (void *)DriverObject;
  }
#line 2579
  DumpToAllocate = (short)0;
#line 2580
  if (P1.__annonCompField1.LowPart != 0UL) {
#line 2581
    DumpToAllocate = (short )sizeof(PHYSICAL_ADDRESS );
  } else {
#line 2583
    if (P1.__annonCompField1.HighPart != 0L) {
#line 2584
      DumpToAllocate = (short )sizeof(PHYSICAL_ADDRESS );
    } else {

    }
  }
#line 2589
  if (P2.__annonCompField1.LowPart != 0UL) {
#line 2590
    DumpToAllocate = (short )((int )DumpToAllocate + (int )((short )sizeof(PHYSICAL_ADDRESS )));
  } else {
#line 2592
    if (P2.__annonCompField1.HighPart != 0L) {
#line 2593
      DumpToAllocate = (short )((int )DumpToAllocate + (int )((short )sizeof(PHYSICAL_ADDRESS )));
    } else {

    }
  }
  {
#line 2599
  tmp = IoAllocateErrorLogEntry(ObjectToUse, (unsigned char )(sizeof(IO_ERROR_LOG_PACKET ) + (unsigned int )DumpToAllocate));
#line 2600
  ErrorLogEntry = (struct _IO_ERROR_LOG_PACKET *)tmp;
  }
#line 2602
  if (! ErrorLogEntry) {
#line 2603
    return;
  } else {

  }
#line 2607
  ErrorLogEntry->ErrorCode = SpecificIOStatus;
#line 2608
  ErrorLogEntry->SequenceNumber = SequenceNumber;
#line 2609
  ErrorLogEntry->MajorFunctionCode = MajorFunctionCode;
#line 2610
  ErrorLogEntry->RetryCount = RetryCount;
#line 2611
  ErrorLogEntry->UniqueErrorValue = UniqueErrorValue;
#line 2612
  ErrorLogEntry->FinalStatus = FinalStatus;
#line 2613
  ErrorLogEntry->DumpDataSize = (unsigned short )DumpToAllocate;
#line 2614
  if (DumpToAllocate) {
    {
#line 2616
    memcpy((void *)(ErrorLogEntry->DumpData), (void const   *)(& P1), sizeof(PHYSICAL_ADDRESS ));
    }
#line 2618
    if ((unsigned int )DumpToAllocate > sizeof(PHYSICAL_ADDRESS )) {
      {
#line 2620
      memcpy((void *)((UCHAR *)(ErrorLogEntry->DumpData) + sizeof(PHYSICAL_ADDRESS )),
             (void const   *)(& P2), sizeof(PHYSICAL_ADDRESS ));
      }
    } else {

    }
  } else {

  }
  {
#line 2630
  IoWriteErrorLogEntry((void *)ErrorLogEntry);
  }
#line 2632
  return;
}
}
#line 2639
#pragma warning(push)
#line 2640
#pragma warning(disable:4035)
#line 2641
#pragma warning(pop)
#line 2643
#pragma warning(disable:4103)
#line 2644
#pragma warning(disable:4103)
#line 2645
#pragma warning(push)
#line 2646
#pragma warning(disable:4035)
#line 2647
#pragma warning(pop)
#line 2648
#pragma warning(disable:4035)
#line 2649
#pragma warning(push)
#line 2650
#pragma warning(disable:4164)
#line 2651
#pragma function(_enable)
#line 2652
#pragma function(_disable)
#line 2653
#pragma warning(pop)
#line 2654
#pragma warning(disable:4103)
#line 2655
#pragma warning(disable:4103)
#line 2656
#pragma warning(disable:4103)
#line 2657
#pragma warning(disable:4103)
#line 2658
#pragma warning(disable:4103)
#line 2659
#pragma warning(disable:4103)
#line 2660
#pragma warning(disable:4200)
#line 2661
#pragma warning(default:4200)
#line 2663 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING pRegistryPath ) 
{ void *Buffer ;

  {
  {
#line 2668
  PptRegInitDriverSettings(pRegistryPath);
#line 2669
  Buffer = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )pRegistryPath->MaximumLength,
                                 1349673296UL);
  }
#line 2671
  if ((unsigned int )((void *)0) == (unsigned int )Buffer) {
#line 2674
    return (-1073741670L);
  } else {
    {
#line 2677
    memset((void *)RegistryPath.Buffer, 0, (unsigned int )pRegistryPath->MaximumLength);
#line 2678
    RegistryPath.Length = pRegistryPath->Length;
#line 2679
    RegistryPath.MaximumLength = pRegistryPath->MaximumLength;
#line 2680
    memmove((void *)RegistryPath.Buffer, (void const   *)pRegistryPath->Buffer, (unsigned int )pRegistryPath->Length);
    }
  }
  {
#line 2684
  PptPnpInitDispatchFunctionTable();
#line 2685
  DriverObject->MajorFunction[0] = & PptDispatchCreate;
#line 2686
  DriverObject->MajorFunction[2] = & PptDispatchClose;
#line 2687
  DriverObject->MajorFunction[15] = & PptDispatchInternalDeviceControl;
#line 2688
  DriverObject->MajorFunction[18] = & PptDispatchCleanup;
#line 2689
  DriverObject->MajorFunction[27] = & PptDispatchPnp;
#line 2690
  DriverObject->MajorFunction[22] = & PptDispatchPower;
#line 2691
  DriverObject->MajorFunction[23] = & PptDispatchSystemControl;
#line 2692
  (DriverObject->DriverExtension)->AddDevice = & PptPnpAddDevice;
#line 2693
  DriverObject->DriverUnload = & PptUnload;
  }
#line 2695
  return (0L);
}
}
#line 2698 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptUnload(PDRIVER_OBJECT DriverObject ) 
{ PDEVICE_OBJECT CurrentDevice ;
  PDEVICE_EXTENSION Extension ;
  PLIST_ENTRY Head ;
  PISR_LIST_ENTRY Entry ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;
  PCONFIGURATION_INFORMATION tmp ;

  {
#line 2710
  CurrentDevice = DriverObject->DeviceObject;
  {
#line 2712
  while (1) {
    while_2_continue: /* CIL Label */ ;

#line 2714
    if (CurrentDevice) {

    } else {
      goto while_17_break;
    }
#line 2719
    Extension = (struct _DEVICE_EXTENSION *)CurrentDevice->DeviceExtension;
#line 2720
    if (Extension->InterruptRefCount) {
      {
#line 2722
      PptDisconnectInterrupt(Extension);
      }
    } else {

    }
    {
#line 2728
    while (1) {
      while_3_continue: /* CIL Label */ ;

#line 2730
      if (! ((unsigned int )Extension->IsrList.Flink == (unsigned int )(& Extension->IsrList))) {

      } else {
        goto while_18_break;
      }
#line 2736
      Head = Extension->IsrList.Flink;
#line 2737
      _EX_Flink = (Extension->IsrList.Flink)->Flink;
#line 2738
      _EX_Blink = (Extension->IsrList.Flink)->Blink;
#line 2739
      _EX_Blink->Flink = _EX_Flink;
#line 2740
      _EX_Flink->Blink = _EX_Blink;
#line 2741
      Entry = (ISR_LIST_ENTRY *)((CHAR *)Head - (unsigned long )(& ((ISR_LIST_ENTRY *)0)->ListEntry));
    }
    while_3_break: /* CIL Label */ ;
    }
    while_18_break: 
    {
#line 2750
    tmp = IoGetConfigurationInformation();
#line 2751
    tmp->ParallelCount -= 1UL;
#line 2752
    CurrentDevice = DriverObject->DeviceObject;
    }
  }
  while_2_break: /* CIL Label */ ;
  }
  while_17_break: ;
#line 2757
  if (PortInfoMutex) {
#line 2760
    PortInfoMutex = (struct _FAST_MUTEX *)((void *)0);
  } else {

  }
#line 2768
  return;
}
}
#line 2775
#pragma warning(push)
#line 2776
#pragma warning(disable:4035)
#line 2777
#pragma warning(pop)
#line 2779
#pragma warning(disable:4103)
#line 2780
#pragma warning(disable:4103)
#line 2781
#pragma warning(push)
#line 2782
#pragma warning(disable:4035)
#line 2783
#pragma warning(pop)
#line 2784
#pragma warning(disable:4035)
#line 2785
#pragma warning(push)
#line 2786
#pragma warning(disable:4164)
#line 2787
#pragma function(_enable)
#line 2788
#pragma function(_disable)
#line 2789
#pragma warning(pop)
#line 2790
#pragma warning(disable:4103)
#line 2791
#pragma warning(disable:4103)
#line 2792
#pragma warning(disable:4103)
#line 2793
#pragma warning(disable:4103)
#line 2794
#pragma warning(disable:4103)
#line 2795
#pragma warning(disable:4103)
#line 2796
#pragma warning(disable:4200)
#line 2797
#pragma warning(default:4200)
#line 2799 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptCleanRemovalRelationsList(PDEVICE_EXTENSION Extension ) 
{ PLIST_ENTRY listHead ;
  PLIST_ENTRY thisListEntry ;
  PREMOVAL_RELATIONS_LIST_ENTRY node ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
#line 2808
  listHead = & Extension->RemovalRelationsList;
#line 2809
  thisListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 2810
  node = (struct _REMOVAL_RELATIONS_LIST_ENTRY *)((void *)0);
  {
#line 2814
  while (1) {
    while_4_continue: /* CIL Label */ ;

#line 2816
    if (! ((unsigned int )listHead->Flink == (unsigned int )listHead)) {

    } else {
      goto while_19_break;
    }
#line 2821
    thisListEntry = listHead->Flink;
#line 2822
    _EX_Flink = (listHead->Flink)->Flink;
#line 2823
    _EX_Blink = (listHead->Flink)->Blink;
#line 2824
    _EX_Blink->Flink = _EX_Flink;
#line 2825
    _EX_Flink->Blink = _EX_Blink;
#line 2826
    node = (REMOVAL_RELATIONS_LIST_ENTRY *)((CHAR *)thisListEntry - (unsigned long )(& ((REMOVAL_RELATIONS_LIST_ENTRY *)0)->ListEntry));
  }
  while_4_break: /* CIL Label */ ;
  }
  while_19_break: ;
#line 2839
  return;
}
}
#line 2842 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptAddPptRemovalRelation(PDEVICE_EXTENSION Extension , PPARPORT_REMOVAL_RELATIONS PptRemovalRelations ) 
{ PREMOVAL_RELATIONS_LIST_ENTRY node ;
  PVOID tmp ;
  PVOID tmp___0 ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_ListHead ;

  {
  {
#line 2851
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )sizeof(REMOVAL_RELATIONS_LIST_ENTRY ),
                              1349673296UL);
#line 2852
  node = (struct _REMOVAL_RELATIONS_LIST_ENTRY *)tmp;
  }
#line 2856
  if (! node) {
#line 2859
    return (-1073741670L);
  } else {

  }
  {
#line 2864
  node->DeviceObject = PptRemovalRelations->DeviceObject;
#line 2865
  node->Flags = PptRemovalRelations->Flags;
#line 2866
  memset((void *)(& node->DeviceName), 0, sizeof(UNICODE_STRING ));
#line 2867
  tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )(PptRemovalRelations->DeviceName)->MaximumLength,
                                  1349673296UL);
#line 2869
  node->DeviceName.Buffer = (WCHAR *)tmp___0;
  }
#line 2871
  if (! node->DeviceName.Buffer) {
#line 2877
    return (-1073741670L);
  } else {

  }
#line 2882
  node->DeviceName.MaximumLength = (PptRemovalRelations->DeviceName)->MaximumLength;
#line 2885
  _EX_ListHead = & Extension->RemovalRelationsList;
#line 2886
  _EX_Blink = _EX_ListHead->Blink;
#line 2887
  node->ListEntry.Flink = _EX_ListHead;
#line 2888
  node->ListEntry.Blink = _EX_Blink;
#line 2889
  _EX_Blink->Flink = & node->ListEntry;
#line 2890
  _EX_ListHead->Blink = & node->ListEntry;
#line 2893
  return (0L);
}
}
#line 2896 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptRemovePptRemovalRelation(PDEVICE_EXTENSION Extension , PPARPORT_REMOVAL_RELATIONS PptRemovalRelations ) 
{ PDEVICE_OBJECT callerDevObj ;
  PLIST_ENTRY listHead ;
  PDEVICE_OBJECT listDevObj ;
  PLIST_ENTRY thisListEntry ;
  PLIST_ENTRY firstListEntry ;
  BOOLEAN found ;
  BOOLEAN done ;
  PREMOVAL_RELATIONS_LIST_ENTRY node ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;
  PLIST_ENTRY _EX_Blink___0 ;
  PLIST_ENTRY _EX_ListHead ;

  {
#line 2911
  callerDevObj = PptRemovalRelations->DeviceObject;
#line 2912
  listHead = & Extension->RemovalRelationsList;
#line 2913
  listDevObj = (struct _DEVICE_OBJECT *)((void *)0);
#line 2914
  thisListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 2915
  firstListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 2916
  found = (unsigned char)0;
#line 2917
  done = (unsigned char)0;
#line 2918
  node = (struct _REMOVAL_RELATIONS_LIST_ENTRY *)((void *)0);
#line 2924
  if ((unsigned int )listHead->Flink == (unsigned int )listHead) {
#line 2930
    return (0L);
  } else {

  }
  {
#line 2942
  while (1) {
    while_5_continue: /* CIL Label */ ;

#line 2944
    if (! done) {

    } else {
      goto while_27_break;
    }
#line 2949
    thisListEntry = listHead->Flink;
#line 2950
    _EX_Flink = (listHead->Flink)->Flink;
#line 2951
    _EX_Blink = (listHead->Flink)->Blink;
#line 2952
    _EX_Blink->Flink = _EX_Flink;
#line 2953
    _EX_Flink->Blink = _EX_Blink;
#line 2954
    node = (REMOVAL_RELATIONS_LIST_ENTRY *)((CHAR *)thisListEntry - (unsigned long )(& ((REMOVAL_RELATIONS_LIST_ENTRY *)0)->ListEntry));
#line 2955
    if ((unsigned int )node->DeviceObject == (unsigned int )callerDevObj) {
#line 2958
      found = (unsigned char)1;
#line 2959
      done = (unsigned char)1;
    } else {
#line 2961
      if ((unsigned int )firstListEntry == (unsigned int )thisListEntry) {
#line 2964
        done = (unsigned char)1;
      } else {
#line 2966
        if (! firstListEntry) {
#line 2969
          firstListEntry = thisListEntry;
        } else {

        }
      }
    }
#line 2975
    if (! found) {
#line 2976
      _EX_ListHead = listHead;
#line 2977
      _EX_Blink___0 = _EX_ListHead->Blink;
#line 2978
      node->ListEntry.Flink = _EX_ListHead;
#line 2979
      node->ListEntry.Blink = _EX_Blink___0;
#line 2980
      _EX_Blink___0->Flink = & node->ListEntry;
#line 2981
      _EX_ListHead->Blink = & node->ListEntry;
    } else {

    }
  }
  while_5_break: /* CIL Label */ ;
  }
  while_27_break: ;
#line 2991
  if (found) {

  } else {

  }
#line 3001
  return (0L);
}
}
#line 3004 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDumpRemovalRelationsList(PDEVICE_EXTENSION Extension ) 
{ PLIST_ENTRY listHead ;
  PLIST_ENTRY thisListEntry ;
  PLIST_ENTRY firstListEntry ;
  BOOLEAN done ;
  PREMOVAL_RELATIONS_LIST_ENTRY node ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;
  PLIST_ENTRY _EX_Flink___0 ;
  PLIST_ENTRY _EX_ListHead ;
  PLIST_ENTRY _EX_Blink___0 ;
  PLIST_ENTRY _EX_ListHead___0 ;

  {
#line 3018
  listHead = & Extension->RemovalRelationsList;
#line 3019
  thisListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 3020
  firstListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 3021
  done = (unsigned char)0;
#line 3022
  node = (struct _REMOVAL_RELATIONS_LIST_ENTRY *)((void *)0);
#line 3028
  if ((unsigned int )listHead->Flink == (unsigned int )listHead) {
#line 3034
    return;
  } else {

  }
  {
#line 3040
  while (1) {
    while_6_continue: /* CIL Label */ ;

#line 3042
    if (! done) {

    } else {
      goto while_35_break;
    }
#line 3047
    thisListEntry = listHead->Flink;
#line 3048
    _EX_Flink = (listHead->Flink)->Flink;
#line 3049
    _EX_Blink = (listHead->Flink)->Blink;
#line 3050
    _EX_Blink->Flink = _EX_Flink;
#line 3051
    _EX_Flink->Blink = _EX_Blink;
#line 3052
    node = (REMOVAL_RELATIONS_LIST_ENTRY *)((CHAR *)thisListEntry - (unsigned long )(& ((REMOVAL_RELATIONS_LIST_ENTRY *)0)->ListEntry));
#line 3053
    if ((unsigned int )firstListEntry == (unsigned int )thisListEntry) {
#line 3054
      _EX_ListHead = listHead;
#line 3055
      _EX_Flink___0 = _EX_ListHead->Flink;
#line 3056
      node->ListEntry.Flink = _EX_Flink___0;
#line 3057
      node->ListEntry.Blink = _EX_ListHead;
#line 3058
      _EX_Flink___0->Blink = & node->ListEntry;
#line 3059
      _EX_ListHead->Flink = & node->ListEntry;
#line 3060
      done = (unsigned char)1;
    } else {
#line 3066
      _EX_ListHead___0 = listHead;
#line 3067
      _EX_Blink___0 = _EX_ListHead___0->Blink;
#line 3068
      node->ListEntry.Flink = _EX_ListHead___0;
#line 3069
      node->ListEntry.Blink = _EX_Blink___0;
#line 3070
      _EX_Blink___0->Flink = & node->ListEntry;
#line 3071
      _EX_ListHead___0->Blink = & node->ListEntry;
    }
#line 3073
    if (! firstListEntry) {
#line 3074
      firstListEntry = thisListEntry;
    } else {

    }
  }
  while_6_break: /* CIL Label */ ;
  }
  while_35_break: ;
#line 3084
  return;
}
}
#line 3087 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDumpPptRemovalRelationsStruct(PPARPORT_REMOVAL_RELATIONS PptRemovalRelations ) 
{ 

  {
#line 3091
  return;
}
}
#line 3094 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchInternalDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION IrpSp ;
  PDEVICE_EXTENSION Extension ;
  NTSTATUS Status ;
  PPARALLEL_PORT_INFORMATION PortInfo ;
  PPARALLEL_PNP_INFORMATION PnpInfo ;
  PMORE_PARALLEL_PORT_INFORMATION MorePortInfo ;
  KIRQL CancelIrql ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  PPARALLEL_INTERRUPT_SERVICE_ROUTINE IsrInfo ;
  PPARALLEL_INTERRUPT_INFORMATION InterruptInfo ;
  PISR_LIST_ENTRY IsrListEntry ;
  SYNCHRONIZED_LIST_CONTEXT ListContext ;
  SYNCHRONIZED_DISCONNECT_CONTEXT DisconnectContext ;
  BOOLEAN DisconnectInterrupt ;
  NTSTATUS tmp ;
  PPARPORT_REMOVAL_RELATIONS removalRelations ;
  PPARPORT_REMOVAL_RELATIONS removalRelations___0 ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_ListHead ;
  ULONG EnableConnectInterruptIoctl ;
  PVOID tmp___0 ;
  BOOLEAN tmp___1 ;
  PLIST_ENTRY _EX_Blink___0 ;
  PLIST_ENTRY _EX_ListHead___0 ;

  {
#line 3121
  Extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3124
  if (Irp->UserEvent) {

  } else {

  }
#line 3129
  if (Extension->DeviceStateFlags & 4096UL) {
    {
#line 3133
    tmp = PptFailRequest(Irp, -1073741738L);
    }
#line 3135
    return (tmp);
  } else {

  }
  {
#line 3140
  Status = PptAcquireRemoveLockOrFailIrp(DeviceObject, Irp);
  }
#line 3142
  if (! (Status >= 0L)) {
#line 3145
    return (Status);
  } else {

  }
#line 3149
  IrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3150
  Irp->IoStatus.Information = 0UL;
#line 3151
  if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (50 << 2))) {
    goto switch_41_exp_0;
  } else {
#line 3154
    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (51 << 2))) {
      goto switch_41_exp_1;
    } else {
#line 3157
      if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (40 << 2))) {
        goto switch_41_exp_2;
      } else {
#line 3160
        if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (11 << 2))) {
          goto switch_41_exp_3;
        } else {
#line 3163
          if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (12 << 2))) {
            goto switch_41_exp_4;
          } else {
#line 3166
            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (15 << 2))) {
              goto switch_41_exp_5;
            } else {
#line 3169
              if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (21 << 2))) {
                goto switch_41_exp_6;
              } else {
#line 3172
                if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (17 << 2))) {
                  goto switch_41_exp_7;
                } else {
#line 3175
                  if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (13 << 2))) {
                    goto switch_41_exp_8;
                  } else {
#line 3178
                    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (14 << 2))) {
                      goto switch_41_exp_9;
                    } else {
#line 3181
                      if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (19 << 2))) {
                        goto switch_41_exp_10;
                      } else {
#line 3184
                        if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (20 << 2))) {
                          goto switch_41_exp_11;
                        } else {
#line 3187
                          if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (22 << 2))) {
                            goto switch_41_exp_12;
                          } else {
#line 3190
                            if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (23 << 2))) {
                              goto switch_41_exp_13;
                            } else {
#line 3193
                              if (IrpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((22 << 16) | (24 << 2))) {
                                goto switch_41_exp_14;
                              } else {
                                goto switch_41_default;
#line 3198
                                if (0) {
                                  switch_41_exp_0: ;
#line 3202
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARPORT_REMOVAL_RELATIONS )) {
#line 3205
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3208
                                    removalRelations = (struct _PARPORT_REMOVAL_RELATIONS *)Irp->AssociatedIrp.SystemBuffer;
#line 3210
                                    PptDumpRemovalRelationsList(Extension);
#line 3211
                                    PptAddPptRemovalRelation(Extension, removalRelations);
#line 3212
                                    PptDumpRemovalRelationsList(Extension);
#line 3216
                                    Status = 0L;
                                    }
                                  }
                                  {
#line 3219
                                  Irp->IoStatus.__annonCompField4.Status = Status;
#line 3220
                                  myStatus = (int )Status;
#line 3221
                                  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 3222
                                  PptCompleteRequest(Irp, (char)0);
                                  }
#line 3224
                                  return (Status);
                                  switch_41_exp_1: ;
#line 3228
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARPORT_REMOVAL_RELATIONS )) {
#line 3231
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3234
                                    removalRelations___0 = (struct _PARPORT_REMOVAL_RELATIONS *)Irp->AssociatedIrp.SystemBuffer;
#line 3236
                                    PptDumpRemovalRelationsList(Extension);
#line 3237
                                    PptRemovePptRemovalRelation(Extension, removalRelations___0);
#line 3238
                                    PptDumpRemovalRelationsList(Extension);
#line 3242
                                    Status = 0L;
                                    }
                                  }
                                  {
#line 3245
                                  Irp->IoStatus.__annonCompField4.Status = Status;
#line 3246
                                  myStatus = (int )Status;
#line 3247
                                  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 3248
                                  PptCompleteRequest(Irp, (char)0);
                                  }
#line 3250
                                  return (Status);
                                  switch_41_exp_2: 
                                  {
#line 3253
                                  PptFreePort((void *)Extension);
#line 3254
                                  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3255
                                  myStatus = 0;
#line 3256
                                  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 3257
                                  PptCompleteRequest(Irp, (char)0);
                                  }
#line 3259
                                  return (0L);
                                  switch_41_exp_3: 
                                  {
#line 3262
                                  IoAcquireCancelSpinLock(& CancelIrql);
                                  }
#line 3264
                                  if (Irp->Cancel) {
#line 3265
                                    Status = -1073741536L;
                                  } else {
#line 3267
                                    SyncContext.Count = & Extension->WorkQueueCount;
#line 3268
                                    if (Extension->InterruptRefCount) {
                                      {
#line 3270
                                      KeSynchronizeExecution(Extension->InterruptObject,
                                                             & PptSynchronizedIncrement,
                                                             (void *)(& SyncContext));
                                      }
                                    } else {
                                      {
#line 3276
                                      PptSynchronizedIncrement((void *)(& SyncContext));
                                      }
                                    }
#line 3279
                                    if (SyncContext.NewCount) {
                                      {
#line 3281
                                      PptSetCancelRoutine(Irp, & PptCancelRoutine);
                                      }
#line 3283
                                      if (pended == 0) {
#line 3284
                                        pended = 1;
                                      } else {
                                        {
#line 3287
                                        errorFn();
                                        }
                                      }
#line 3290
                                      (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 3291
                                      _EX_ListHead = & Extension->WorkQueue;
#line 3292
                                      _EX_Blink = _EX_ListHead->Blink;
#line 3293
                                      Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink = _EX_ListHead;
#line 3294
                                      Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink = _EX_Blink;
#line 3295
                                      _EX_Blink->Flink = & Irp->Tail.Overlay.__annonCompField17.ListEntry;
#line 3296
                                      _EX_ListHead->Blink = & Irp->Tail.Overlay.__annonCompField17.ListEntry;
#line 3297
                                      Status = 259L;
                                    } else {
#line 3299
                                      Extension->WmiPortAllocFreeCounts.PortAllocates += 1UL;
#line 3300
                                      Status = 0L;
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_4: ;
#line 3310
                                  if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(PARALLEL_PORT_INFORMATION )) {
#line 3311
                                    Status = -1073741789L;
                                  } else {
#line 3313
                                    Irp->IoStatus.Information = (unsigned long )sizeof(PARALLEL_PORT_INFORMATION );
#line 3314
                                    PortInfo = (struct _PARALLEL_PORT_INFORMATION *)Irp->AssociatedIrp.SystemBuffer;
#line 3315
                                    *PortInfo = Extension->PortInfo;
#line 3316
                                    Status = 0L;
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_5: 
#line 3322
                                  Status = 0L;
                                  goto switch_41_break;
                                  switch_41_exp_6: ;
#line 3327
                                  if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(PARALLEL_PNP_INFORMATION )) {
#line 3328
                                    Status = -1073741789L;
                                  } else {
#line 3330
                                    Irp->IoStatus.Information = (unsigned long )sizeof(PARALLEL_PNP_INFORMATION );
#line 3331
                                    PnpInfo = (struct _PARALLEL_PNP_INFORMATION *)Irp->AssociatedIrp.SystemBuffer;
#line 3332
                                    *PnpInfo = Extension->PnpInfo;
#line 3333
                                    Status = 0L;
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_7: ;
#line 3339
                                  if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(MORE_PARALLEL_PORT_INFORMATION )) {
#line 3340
                                    Status = -1073741789L;
                                  } else {
#line 3342
                                    Irp->IoStatus.Information = (unsigned long )sizeof(MORE_PARALLEL_PORT_INFORMATION );
#line 3343
                                    MorePortInfo = (struct _MORE_PARALLEL_PORT_INFORMATION *)Irp->AssociatedIrp.SystemBuffer;
#line 3344
                                    MorePortInfo->InterfaceType = Extension->InterfaceType;
#line 3345
                                    MorePortInfo->BusNumber = Extension->BusNumber;
#line 3346
                                    MorePortInfo->InterruptLevel = (unsigned long )Extension->InterruptLevel;
#line 3347
                                    MorePortInfo->InterruptVector = Extension->InterruptVector;
#line 3348
                                    MorePortInfo->InterruptAffinity = Extension->InterruptAffinity;
#line 3349
                                    MorePortInfo->InterruptMode = Extension->InterruptMode;
#line 3350
                                    Status = 0L;
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_8: 
#line 3356
                                  EnableConnectInterruptIoctl = 0UL;
#line 3359
                                  if (0UL == EnableConnectInterruptIoctl) {
#line 3362
                                    Status = -1073741823L;
                                    goto targetExit;
                                  } else {

                                  }
#line 3368
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE )) {
#line 3369
                                    Status = -1073741789L;
                                  } else {
#line 3371
                                    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(PARALLEL_INTERRUPT_INFORMATION )) {
#line 3372
                                      Status = -1073741789L;
                                    } else {
                                      {
#line 3375
                                      IsrInfo = (struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE *)Irp->AssociatedIrp.SystemBuffer;
#line 3376
                                      InterruptInfo = (struct _PARALLEL_INTERRUPT_INFORMATION *)Irp->AssociatedIrp.SystemBuffer;
#line 3377
                                      IoAcquireCancelSpinLock(& CancelIrql);
                                      }
#line 3379
                                      if (Extension->InterruptRefCount) {
#line 3381
                                        Extension->InterruptRefCount += 1UL;
#line 3383
                                        Status = 0L;
                                      } else {
                                        {
#line 3388
                                        Status = PptConnectInterrupt(Extension);
                                        }
#line 3390
                                        if (Status >= 0L) {
                                          {
#line 3392
                                          IoAcquireCancelSpinLock(& CancelIrql);
#line 3393
                                          Extension->InterruptRefCount += 1UL;
                                          }
                                        } else {

                                        }
                                      }
#line 3400
                                      if (Status >= 0L) {
                                        {
#line 3402
                                        tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )0,
                                                                        (unsigned long )sizeof(ISR_LIST_ENTRY ),
                                                                        1349673296UL);
#line 3404
                                        IsrListEntry = (struct _ISR_LIST_ENTRY *)tmp___0;
                                        }
#line 3406
                                        if (IsrListEntry) {
                                          {
#line 3408
                                          IsrListEntry->ServiceRoutine = IsrInfo->InterruptServiceRoutine;
#line 3409
                                          IsrListEntry->ServiceContext = IsrInfo->InterruptServiceContext;
#line 3410
                                          IsrListEntry->DeferredPortCheckRoutine = IsrInfo->DeferredPortCheckRoutine;
#line 3411
                                          IsrListEntry->CheckContext = IsrInfo->DeferredPortCheckContext;
#line 3412
                                          ListContext.List = & Extension->IsrList;
#line 3413
                                          ListContext.NewEntry = & IsrListEntry->ListEntry;
#line 3414
                                          KeSynchronizeExecution(Extension->InterruptObject,
                                                                 & PptSynchronizedQueue,
                                                                 (void *)(& ListContext));
#line 3417
                                          InterruptInfo->InterruptObject = Extension->InterruptObject;
#line 3418
                                          InterruptInfo->TryAllocatePortAtInterruptLevel = & PptTryAllocatePortAtInterruptLevel;
#line 3419
                                          InterruptInfo->FreePortFromInterruptLevel = & PptFreePortFromInterruptLevel;
#line 3420
                                          InterruptInfo->Context = (void *)Extension;
#line 3421
                                          Irp->IoStatus.Information = (unsigned long )sizeof(PARALLEL_INTERRUPT_INFORMATION );
#line 3422
                                          Status = 0L;
                                          }
                                        } else {
#line 3425
                                          Status = -1073741670L;
                                        }
                                      } else {

                                      }
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_9: ;
#line 3436
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_INTERRUPT_SERVICE_ROUTINE )) {
#line 3437
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3440
                                    IsrInfo = (struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE *)Irp->AssociatedIrp.SystemBuffer;
#line 3441
                                    IoAcquireCancelSpinLock(& CancelIrql);
                                    }
#line 3443
                                    if (Extension->InterruptRefCount) {
                                      {
#line 3446
                                      DisconnectContext.Extension = Extension;
#line 3447
                                      DisconnectContext.IsrInfo = IsrInfo;
#line 3448
                                      tmp___1 = KeSynchronizeExecution(Extension->InterruptObject,
                                                                       & PptSynchronizedDisconnect,
                                                                       (void *)(& DisconnectContext));
                                      }
#line 3452
                                      if (tmp___1) {
                                        {
#line 3454
                                        Status = 0L;
#line 3455
                                        IoAcquireCancelSpinLock(& CancelIrql);
#line 3456
                                        Extension->InterruptRefCount -= 1UL;
                                        }
#line 3458
                                        if (Extension->InterruptRefCount == 0UL) {
#line 3459
                                          DisconnectInterrupt = (unsigned char)1;
                                        } else {
#line 3461
                                          DisconnectInterrupt = (unsigned char)0;
                                        }
                                      } else {
#line 3467
                                        Status = -1073741811L;
#line 3468
                                        DisconnectInterrupt = (unsigned char)0;
                                      }
                                    } else {
#line 3473
                                      DisconnectInterrupt = (unsigned char)0;
#line 3474
                                      Status = -1073741811L;
                                    }
#line 3477
                                    if (DisconnectInterrupt) {
                                      {
#line 3479
                                      PptDisconnectInterrupt(Extension);
                                      }
                                    } else {

                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_10: ;
#line 3489
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_CHIP_MODE )) {
#line 3490
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3495
                                    Status = PptSetChipMode(Extension, ((struct _PARALLEL_CHIP_MODE *)Irp->AssociatedIrp.SystemBuffer)->ModeFlags);
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_11: ;
#line 3502
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_CHIP_MODE )) {
#line 3503
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3508
                                    Status = PptClearChipMode(Extension, ((struct _PARALLEL_CHIP_MODE *)Irp->AssociatedIrp.SystemBuffer)->ModeFlags);
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_12: 
                                  {
#line 3516
                                  Extension->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3((void *)Extension);
#line 3517
                                  Status = 0L;
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_13: ;
#line 3523
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_1284_COMMAND )) {
#line 3526
                                    Status = -1073741789L;
                                  } else {
#line 3528
                                    if (Irp->Cancel) {
#line 3529
                                      Status = -1073741536L;
                                    } else {
                                      {
#line 3532
                                      Status = PptTrySelectDevice((void *)Extension,
                                                                  Irp->AssociatedIrp.SystemBuffer);
#line 3533
                                      IoAcquireCancelSpinLock(& CancelIrql);
                                      }
#line 3535
                                      if (Status == 259L) {
                                        {
#line 3537
                                        PptSetCancelRoutine(Irp, & PptCancelRoutine);
                                        }
#line 3539
                                        if (pended == 0) {
#line 3540
                                          pended = 1;
                                        } else {
                                          {
#line 3543
                                          errorFn();
                                          }
                                        }
#line 3546
                                        (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 3547
                                        _EX_ListHead___0 = & Extension->WorkQueue;
#line 3548
                                        _EX_Blink___0 = _EX_ListHead___0->Blink;
#line 3549
                                        Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink = _EX_ListHead___0;
#line 3550
                                        Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink = _EX_Blink___0;
#line 3551
                                        _EX_Blink___0->Flink = & Irp->Tail.Overlay.__annonCompField17.ListEntry;
#line 3552
                                        _EX_ListHead___0->Blink = & Irp->Tail.Overlay.__annonCompField17.ListEntry;
                                      } else {

                                      }
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_exp_14: ;
#line 3567
                                  if (IrpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(PARALLEL_1284_COMMAND )) {
#line 3570
                                    Status = -1073741789L;
                                  } else {
                                    {
#line 3573
                                    Status = PptDeselectDevice((void *)Extension,
                                                               Irp->AssociatedIrp.SystemBuffer);
                                    }
                                  }
                                  goto switch_41_break;
                                  switch_41_default: 
#line 3580
                                  Status = -1073741811L;
                                  goto switch_41_break;
                                } else {
                                  switch_41_break: ;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  targetExit: 
#line 3602
  if (Status != 259L) {
    {
#line 3604
    Irp->IoStatus.__annonCompField4.Status = Status;
#line 3605
    myStatus = (int )Status;
#line 3606
    PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 3607
    PptCompleteRequest(Irp, (char)0);
    }
  } else {

  }
#line 3612
  return (Status);
}
}
#line 3619
#pragma warning(push)
#line 3620
#pragma warning(disable:4035)
#line 3621
#pragma warning(pop)
#line 3623
#pragma warning(disable:4103)
#line 3624
#pragma warning(disable:4103)
#line 3625
#pragma warning(push)
#line 3626
#pragma warning(disable:4035)
#line 3627
#pragma warning(pop)
#line 3628
#pragma warning(disable:4035)
#line 3629
#pragma warning(push)
#line 3630
#pragma warning(disable:4164)
#line 3631
#pragma function(_enable)
#line 3632
#pragma function(_disable)
#line 3633
#pragma warning(pop)
#line 3634
#pragma warning(disable:4103)
#line 3635
#pragma warning(disable:4103)
#line 3636
#pragma warning(disable:4103)
#line 3637
#pragma warning(disable:4103)
#line 3638
#pragma warning(disable:4103)
#line 3639
#pragma warning(disable:4103)
#line 3640
#pragma warning(disable:4200)
#line 3641
#pragma warning(default:4200)
#line 3643 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptIsNecR98Machine(void) 
{ UNICODE_STRING Path ;
  RTL_QUERY_REGISTRY_TABLE ParamTable[2] ;
  NTSTATUS Status ;
  UNICODE_STRING identifierString ;
  UNICODE_STRING necR98Identifier ;
  UNICODE_STRING necR98JIdentifier ;
  PVOID tmp ;
  LONG tmp___0 ;
  LONG tmp___1 ;

  {
  {
#line 3656
  identifierString.Length = (unsigned short)0;
#line 3657
  identifierString.MaximumLength = (unsigned short)32;
#line 3658
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )identifierString.MaximumLength,
                              1349673296UL);
#line 3659
  identifierString.Buffer = (WCHAR *)tmp;
  }
#line 3661
  if (! identifierString.Buffer) {
#line 3662
    return ((unsigned char)0);
  } else {

  }
  {
#line 3667
  memset((void *)(ParamTable), 0, sizeof(ParamTable));
#line 3668
  ParamTable[0].Flags = 36UL;
#line 3669
  ParamTable[0].EntryContext = (void *)(& identifierString);
#line 3670
  ParamTable[0].DefaultType = 1UL;
#line 3671
  ParamTable[0].DefaultData = (void *)(& Path);
#line 3672
  ParamTable[0].DefaultLength = 0UL;
#line 3673
  Status = RtlQueryRegistryValues(0UL, (WCHAR const   *)Path.Buffer, ParamTable, (void *)0,
                                  (void *)0);
  }
#line 3675
  if (Status >= 0L) {
    {
#line 3677
    tmp___0 = RtlCompareUnicodeString(& identifierString, & necR98Identifier, (unsigned char)0);
    }
#line 3679
    if (tmp___0 == 0L) {
      goto _L;
    } else {
      {
#line 3683
      tmp___1 = RtlCompareUnicodeString(& identifierString, & necR98JIdentifier, (unsigned char)0);
      }
#line 3685
      if (tmp___1 == 0L) {
        _L: ;
#line 3692
        return ((unsigned char)1);
      } else {

      }
    }
  } else {
#line 3703
    return ((unsigned char)0);
  }
#line 3710
  return ((unsigned char)0);
}
}
#line 3717
#pragma warning(push)
#line 3718
#pragma warning(disable:4035)
#line 3719
#pragma warning(pop)
#line 3721
#pragma warning(disable:4103)
#line 3722
#pragma warning(disable:4103)
#line 3723
#pragma warning(push)
#line 3724
#pragma warning(disable:4035)
#line 3725
#pragma warning(pop)
#line 3726
#pragma warning(disable:4035)
#line 3727
#pragma warning(push)
#line 3728
#pragma warning(disable:4164)
#line 3729
#pragma function(_enable)
#line 3730
#pragma function(_disable)
#line 3731
#pragma warning(pop)
#line 3732
#pragma warning(disable:4103)
#line 3733
#pragma warning(disable:4103)
#line 3734
#pragma warning(disable:4103)
#line 3735
#pragma warning(disable:4103)
#line 3736
#pragma warning(disable:4103)
#line 3737
#pragma warning(disable:4103)
#line 3738
#pragma warning(disable:4200)
#line 3739
#pragma warning(default:4200)
#line 3741 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchCreate(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS status ;
  NTSTATUS tmp ;

  {
#line 3747
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3748
  status = 0L;
#line 3749
  if (extension->DeviceStateFlags & 4096UL) {
    {
#line 3753
    tmp = PptFailRequest(Irp, -1073741738L);
    }
#line 3755
    return (tmp);
  } else {

  }
  {
#line 3760
  status = PptAcquireRemoveLockOrFailIrp(DeviceObject, Irp);
  }
#line 3762
  if (! (status >= 0L)) {
#line 3765
    return (status);
  } else {

  }
  {
#line 3771
  InterlockedIncrement(& extension->OpenCloseRefCount);
#line 3777
  PptReleaseRemoveLock(& extension->RemoveLock, (void *)Irp);
#line 3778
  Irp->IoStatus.__annonCompField4.Status = status;
#line 3779
  myStatus = (int )status;
#line 3780
  Irp->IoStatus.Information = 0UL;
#line 3781
  PptCompleteRequest(Irp, (char)0);
  }
#line 3783
  return (status);
}
}
#line 3786 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS status ;
  LONG tmp ;

  {
#line 3792
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3793
  if (extension->DeviceStateFlags & 4096UL) {
    {
#line 3795
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3796
    myStatus = 0;
#line 3797
    Irp->IoStatus.Information = 0UL;
#line 3798
    PptCompleteRequest(Irp, (char)0);
    }
#line 3800
    return (0L);
  } else {

  }
  {
#line 3805
  status = PptAcquireRemoveLock(& extension->RemoveLock, (void *)Irp);
  }
#line 3807
  if (! (status >= 0L)) {
    {
#line 3809
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3810
    myStatus = 0;
#line 3811
    Irp->IoStatus.Information = 0UL;
#line 3812
    PptCompleteRequest(Irp, (char)0);
    }
#line 3814
    return (0L);
  } else {

  }
#line 3821
  if (extension->OpenCloseRefCount > 0L) {
    {
#line 3823
    tmp = InterlockedDecrement(& extension->OpenCloseRefCount);
    }
#line 3825
    if (tmp < 0L) {
      {
#line 3827
      InterlockedIncrement(& extension->OpenCloseRefCount);
      }
    } else {

    }
  } else {

  }
  {
#line 3845
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3846
  myStatus = 0;
#line 3847
  Irp->IoStatus.Information = 0UL;
#line 3848
  PptCompleteRequest(Irp, (char)0);
#line 3849
  PptReleaseRemoveLock(& extension->RemoveLock, (void *)Irp);
  }
#line 3851
  return (0L);
}
}
#line 3858
#pragma warning(push)
#line 3859
#pragma warning(disable:4035)
#line 3860
#pragma warning(pop)
#line 3862
#pragma warning(disable:4103)
#line 3863
#pragma warning(disable:4103)
#line 3864
#pragma warning(push)
#line 3865
#pragma warning(disable:4035)
#line 3866
#pragma warning(pop)
#line 3867
#pragma warning(disable:4035)
#line 3868
#pragma warning(push)
#line 3869
#pragma warning(disable:4164)
#line 3870
#pragma function(_enable)
#line 3871
#pragma function(_disable)
#line 3872
#pragma warning(pop)
#line 3873
#pragma warning(disable:4103)
#line 3874
#pragma warning(disable:4103)
#line 3875
#pragma warning(disable:4103)
#line 3876
#pragma warning(disable:4103)
#line 3877
#pragma warning(disable:4103)
#line 3878
#pragma warning(disable:4103)
#line 3879
#pragma warning(disable:4200)
#line 3880
#pragma warning(default:4200)
#line 3881 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
static UCHAR ModeQualifier___6[7]  = {      (UCHAR )170,      (UCHAR )85,      (UCHAR )0,      (UCHAR )255, 
        (UCHAR )135,      (UCHAR )120,      (UCHAR )255};
#line 3884
BOOLEAN PptCheckIfStl1284_3(PDEVICE_EXTENSION DeviceExtension , ULONG ulDaisyIndex ,
                            BOOLEAN bNoStrobe ) ;
#line 3886
BOOLEAN PptCheckIfNon1284_3Present(PDEVICE_EXTENSION Extension ) ;
#line 3887
BOOLEAN PptCheckIfStlProductId(PDEVICE_EXTENSION DeviceExtension , ULONG ulDaisyIndex ) ;
#line 3888 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
ULONG PptInitiate1284_3(PVOID Extension ) 
{ ULONG deviceCount1 ;
  ULONG deviceCount2 ;
  ULONG loopCount ;
  ULONG maxTries ;

  {
#line 3895
  deviceCount1 = 0UL;
#line 3896
  deviceCount2 = 0UL;
#line 3897
  loopCount = 0UL;
#line 3898
  maxTries = 3UL;
  {
#line 3900
  while (1) {
    while_7_continue: /* CIL Label */ ;
    {
#line 3903
    KeStallExecutionProcessor(5UL);
#line 3904
    deviceCount1 = Ppt1284_3AssignAddress((struct _DEVICE_EXTENSION *)Extension);
#line 3905
    KeStallExecutionProcessor(5UL);
#line 3906
    deviceCount2 = Ppt1284_3AssignAddress((struct _DEVICE_EXTENSION *)Extension);
    }
#line 3908
    if (deviceCount1 != deviceCount2) {
#line 3909
      loopCount += 1UL;
#line 3910
      if (loopCount < maxTries) {

      } else {
        goto while_76_break;
      }
    } else {
      goto while_76_break;
    }
  }
  while_7_break: /* CIL Label */ ;
  }
  while_76_break: ;
#line 3921
  return (deviceCount2);
}
}
#line 3924 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptTrySelectDevice(PVOID Context , PVOID TrySelectCommand ) 
{ NTSTATUS Status ;
  PDEVICE_EXTENSION Extension ;
  PPARALLEL_1284_COMMAND Command ;
  BOOLEAN success ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  KIRQL CancelIrql ;
  UCHAR i ;
  UCHAR DeviceID ;
  NTSTATUS tmp ;

  {
#line 3936
  Status = 0L;
#line 3937
  Extension = (struct _DEVICE_EXTENSION *)Context;
#line 3938
  Command = (struct _PARALLEL_1284_COMMAND *)TrySelectCommand;
#line 3939
  success = (unsigned char)0;
#line 3942
  if (Command->CommandFlags & 4UL) {
    {
#line 3944
    tmp = PptTrySelectLegacyZip(Context, TrySelectCommand);
    }
#line 3946
    return (tmp);
  } else {
#line 3948
    if ((int )Command->ID == 5) {
      {
#line 3950
      tmp = PptTrySelectLegacyZip(Context, TrySelectCommand);
      }
#line 3952
      return (tmp);
    } else {

    }
  }
#line 3957
  DeviceID = Command->ID;
#line 3958
  if (! (Command->CommandFlags & 1UL)) {
#line 3959
    if ((unsigned long )DeviceID > Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 3962
      Status = -1073741811L;
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
#line 3968
    if (Command->CommandFlags & 2UL) {
#line 3969
      if (! (Command->CommandFlags & 1UL)) {
#line 3970
        if ((unsigned long )DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 3971
          i = (unsigned char)0;
          {
#line 3973
          while (1) {
            while_8_continue: /* CIL Label */ ;

#line 3975
            if ((int )i < (int )PptDot3Retries) {
#line 3976
              if (! success) {

              } else {
                goto while_79_break;
              }
            } else {
              goto while_79_break;
            }
            {
#line 3985
            success = PptSend1284_3Command(Extension, (unsigned char )(224 | (int )DeviceID));
#line 3986
            KeStallExecutionProcessor(5UL);
#line 3987
            i = (unsigned char )((int )i + 1);
            }
          }
          while_8_break: /* CIL Label */ ;
          }
          while_79_break: ;
#line 3992
          if (success) {
#line 3995
            Status = 0L;
          } else {
#line 3999
            Status = -1073741823L;
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
#line 4008
        Status = 0L;
      }
    } else {
      {
#line 4014
      IoAcquireCancelSpinLock(& CancelIrql);
#line 4015
      SyncContext.Count = & Extension->WorkQueueCount;
      }
#line 4017
      if (Extension->InterruptRefCount) {
        {
#line 4019
        KeSynchronizeExecution(Extension->InterruptObject, & PptSynchronizedIncrement,
                               (void *)(& SyncContext));
        }
      } else {
        {
#line 4024
        PptSynchronizedIncrement((void *)(& SyncContext));
        }
      }
#line 4027
      if (SyncContext.NewCount) {
#line 4030
        Status = 259L;
      } else {
#line 4038
        Extension->WmiPortAllocFreeCounts.PortAllocates += 1UL;
#line 4039
        if (! (Command->CommandFlags & 1UL)) {
#line 4040
          if ((unsigned long )DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 4041
            i = (unsigned char)0;
            {
#line 4043
            while (1) {
              while_9_continue: /* CIL Label */ ;

#line 4045
              if ((int )i < (int )PptDot3Retries) {
#line 4046
                if (! success) {

                } else {
                  goto while_85_break;
                }
              } else {
                goto while_85_break;
              }
              {
#line 4055
              success = PptSend1284_3Command(Extension, (unsigned char )(224 | (int )DeviceID));
#line 4056
              KeStallExecutionProcessor(5UL);
#line 4057
              i = (unsigned char )((int )i + 1);
              }
            }
            while_9_break: /* CIL Label */ ;
            }
            while_85_break: ;
#line 4062
            if (success) {
#line 4065
              Status = 0L;
            } else {
#line 4069
              Status = -1073741823L;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
#line 4078
          Status = 0L;
        }
      }
    }
  }
#line 4083
  return (Status);
}
}
#line 4086 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDeselectDevice(PVOID Context , PVOID DeselectCommand ) 
{ NTSTATUS Status ;
  PDEVICE_EXTENSION Extension ;
  PPARALLEL_1284_COMMAND Command ;
  BOOLEAN success ;
  UCHAR i ;
  UCHAR DeviceID ;
  NTSTATUS tmp ;

  {
#line 4096
  Status = 0L;
#line 4097
  Extension = (struct _DEVICE_EXTENSION *)Context;
#line 4098
  Command = (struct _PARALLEL_1284_COMMAND *)DeselectCommand;
#line 4099
  success = (unsigned char)0;
#line 4102
  if (Command->CommandFlags & 4UL) {
    {
#line 4104
    tmp = PptDeselectLegacyZip(Context, DeselectCommand);
    }
#line 4106
    return (tmp);
  } else {
#line 4108
    if ((int )Command->ID == 5) {
      {
#line 4110
      tmp = PptDeselectLegacyZip(Context, DeselectCommand);
      }
#line 4112
      return (tmp);
    } else {

    }
  }
#line 4117
  DeviceID = Command->ID;
#line 4118
  if (! (Command->CommandFlags & 1UL)) {
#line 4119
    if ((unsigned long )DeviceID > Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 4122
      Status = -1073741811L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
#line 4128
    if (! (Command->CommandFlags & 1UL)) {
#line 4129
      if ((unsigned long )DeviceID < Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 4130
        i = (unsigned char)0;
        {
#line 4132
        while (1) {
          while_10_continue: /* CIL Label */ ;

#line 4134
          if ((int )i < (int )PptDot3Retries) {
#line 4135
            if (! success) {

            } else {
              goto while_91_break;
            }
          } else {
            goto while_91_break;
          }
          {
#line 4144
          success = PptSend1284_3Command(Extension, (unsigned char)48);
#line 4145
          KeStallExecutionProcessor(5UL);
#line 4146
          i = (unsigned char )((int )i + 1);
          }
        }
        while_10_break: /* CIL Label */ ;
        }
        while_91_break: ;
#line 4151
        if (success) {
#line 4154
          if (! (Command->CommandFlags & 2UL)) {
            {
#line 4156
            PptFreePort((void *)Extension);
            }
          } else {

          }
#line 4161
          Status = 0L;
        } else {
#line 4165
          Status = -1073741823L;
        }
      } else {
        goto _L;
      }
    } else {
      _L: ;
#line 4174
      if (! (Command->CommandFlags & 2UL)) {
        {
#line 4176
        PptFreePort((void *)Extension);
        }
      } else {

      }
#line 4181
      Status = 0L;
    }
  }
#line 4184
  return (Status);
}
}
#line 4187 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
ULONG Ppt1284_3AssignAddress(PDEVICE_EXTENSION DeviceExtension ) 
{ UCHAR i ;
  UCHAR value ;
  UCHAR newvalue ;
  UCHAR status ;
  PUCHAR CurrentPort ;
  PUCHAR CurrentStatus ;
  PUCHAR CurrentControl ;
  ULONG Delay ;
  UCHAR number ;
  BOOLEAN lastdevice ;
  UCHAR idx ;
  UCHAR tmp ;
  BOOLEAN bStlNon1284_3Found ;
  BOOLEAN bStlNon1284_3Valid ;
  BOOLEAN tmp___0 ;
  BOOLEAN tmp___1 ;

  {
  {
#line 4207
  Delay = 5UL;
#line 4208
  number = (unsigned char)0;
#line 4209
  lastdevice = (unsigned char)0;
#line 4210
  CurrentPort = DeviceExtension->PortInfo.Controller;
#line 4211
  CurrentStatus = CurrentPort + 1;
#line 4212
  CurrentControl = CurrentPort + 2;
#line 4213
  value = READ_PORT_UCHAR(CurrentControl);
#line 4214
  newvalue = (unsigned char )(((int )value & -9) | 4);
#line 4215
  newvalue = (unsigned char )((int )newvalue & -33);
#line 4216
  WRITE_PORT_UCHAR(CurrentControl, newvalue);
#line 4217
  WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4218
  WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[i]);
#line 4219
  KeStallExecutionProcessor(Delay);
#line 4220
  status = READ_PORT_UCHAR(CurrentStatus);
  }
#line 4222
  if (((int )status & 184) == 184) {
    {
#line 4224
    WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[4]);
#line 4225
    KeStallExecutionProcessor(Delay);
#line 4226
    status = READ_PORT_UCHAR(CurrentStatus);
    }
#line 4228
    if (((int )status & 184) == 24) {
      {
#line 4230
      WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[5]);
#line 4231
      KeStallExecutionProcessor(Delay);
#line 4232
      status = READ_PORT_UCHAR(CurrentStatus);
      }
#line 4234
      if (((int )status & 48) == 48) {
        {
#line 4236
        KeStallExecutionProcessor(Delay);
        }
        {
#line 4239
        while (1) {
          while_11_continue: /* CIL Label */ ;

#line 4241
          if ((int )number < 4) {
#line 4242
            if (! lastdevice) {

            } else {
              goto while_95_break;
            }
          } else {
            goto while_95_break;
          }
          {
#line 4251
          WRITE_PORT_UCHAR(CurrentPort, number);
#line 4252
          number = (unsigned char )((int )number + 1);
#line 4253
          KeStallExecutionProcessor(Delay);
#line 4254
          tmp = READ_PORT_UCHAR(CurrentStatus);
          }
#line 4256
          if (((int )tmp & 128) == 0) {
#line 4257
            lastdevice = (unsigned char)1;
          } else {

          }
          {
#line 4262
          WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4263
          WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4264
          KeStallExecutionProcessor(Delay);
#line 4265
          WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4266
          KeStallExecutionProcessor(Delay);
          }
        }
        while_11_break: /* CIL Label */ ;
        }
        while_95_break: 
        {
#line 4272
        WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[6]);
        }
#line 4274
        if (number) {
          {
#line 4276
          bStlNon1284_3Found = PptCheckIfNon1284_3Present(DeviceExtension);
#line 4277
          bStlNon1284_3Valid = (unsigned char)0;
#line 4278
          idx = (unsigned char)0;
          }
          {
#line 4281
          while (1) {
            while_12_continue: /* CIL Label */ ;

#line 4283
            if ((int )idx < (int )number) {

            } else {
              goto while_96_break;
            }
            {
#line 4289
            tmp___0 = PptCheckIfStl1284_3(DeviceExtension, (unsigned long )idx, bStlNon1284_3Found);
            }
#line 4291
            if (1 == (int )tmp___0) {
              goto __Cont;
            } else {

            }
#line 4296
            if (1 == (int )bStlNon1284_3Found) {
              {
#line 4298
              tmp___1 = PptCheckIfStlProductId(DeviceExtension, (unsigned long )idx);
              }
#line 4300
              if (1 == (int )tmp___1) {
#line 4301
                bStlNon1284_3Valid = (unsigned char)1;
                goto __Cont;
              } else {

              }
            } else {

            }
            goto while_96_break;
            __Cont: 
#line 4311
            idx = (unsigned char )((int )idx + 1);
          }
          while_12_break: /* CIL Label */ ;
          }
          while_96_break: ;
#line 4315
          if (1 == (int )bStlNon1284_3Valid) {
#line 4316
            number = idx;
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 4333
  WRITE_PORT_UCHAR(CurrentControl, value);
  }
#line 4335
  return ((unsigned long )number);
}
}
#line 4338 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptCheckIfNon1284_3Present(PDEVICE_EXTENSION Extension ) 
{ BOOLEAN bReturnValue ;
  UCHAR i ;
  UCHAR value ;
  UCHAR newvalue ;
  UCHAR status ;
  ULONG Delay ;
  PUCHAR CurrentPort ;
  PUCHAR CurrentStatus ;
  PUCHAR CurrentControl ;
  UCHAR ucAckStatus ;

  {
  {
#line 4352
  bReturnValue = (unsigned char)0;
#line 4353
  Delay = 3UL;
#line 4354
  CurrentPort = Extension->PortInfo.Controller;
#line 4355
  CurrentStatus = CurrentPort + 1;
#line 4356
  CurrentControl = CurrentPort + 2;
#line 4357
  value = READ_PORT_UCHAR(CurrentControl);
#line 4358
  newvalue = (unsigned char )(((int )value & -9) | 4);
#line 4359
  newvalue = (unsigned char )((int )newvalue & -33);
#line 4360
  WRITE_PORT_UCHAR(CurrentControl, newvalue);
#line 4361
  WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4362
  WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[i]);
#line 4363
  KeStallExecutionProcessor(Delay);
#line 4364
  status = READ_PORT_UCHAR(CurrentStatus);
  }
#line 4366
  if (((int )status & 184) == 184) {
    {
#line 4368
    ucAckStatus = (unsigned char )((int )status & 64);
#line 4369
    WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[4]);
#line 4370
    KeStallExecutionProcessor(Delay);
#line 4371
    status = READ_PORT_UCHAR(CurrentStatus);
    }
#line 4373
    if (((int )status & 184) == 24) {
#line 4374
      if ((int )ucAckStatus != ((int )status & 64)) {
        {
#line 4376
        ucAckStatus = (unsigned char )((int )status & 64);
#line 4377
        WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[5]);
#line 4378
        KeStallExecutionProcessor(Delay);
#line 4379
        status = READ_PORT_UCHAR(CurrentStatus);
        }
#line 4381
        if (((int )status & 48) == 48) {
#line 4382
          bReturnValue = (unsigned char)1;
        } else {

        }
      } else {

      }
      {
#line 4390
      WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[6]);
      }
    } else {

    }
  } else {

  }
  {
#line 4399
  WRITE_PORT_UCHAR(CurrentControl, value);
  }
#line 4401
  return (bReturnValue);
}
}
#line 4404 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptCheckIfStl1284_3(PDEVICE_EXTENSION DeviceExtension , ULONG ulDaisyIndex ,
                            BOOLEAN bNoStrobe ) 
{ BOOLEAN bReturnValue ;
  UCHAR i ;
  UCHAR value ;
  UCHAR newvalue ;
  UCHAR status ;
  ULONG Delay ;
  UCHAR ucExpectedPattern ;
  UCHAR ucReadValue ;
  UCHAR ucReadPattern ;
  PUCHAR CurrentPort ;
  PUCHAR CurrentStatus ;
  PUCHAR CurrentControl ;

  {
  {
#line 4421
  bReturnValue = (unsigned char)0;
#line 4422
  Delay = 3UL;
#line 4423
  CurrentPort = DeviceExtension->PortInfo.Controller;
#line 4424
  CurrentStatus = CurrentPort + 1;
#line 4425
  CurrentControl = CurrentPort + 2;
#line 4426
  value = READ_PORT_UCHAR(CurrentControl);
#line 4427
  newvalue = (unsigned char )(((int )value & -9) | 4);
#line 4428
  newvalue = (unsigned char )((int )newvalue & -33);
#line 4429
  WRITE_PORT_UCHAR(CurrentControl, newvalue);
#line 4430
  WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4431
  WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[i]);
#line 4432
  KeStallExecutionProcessor(Delay);
#line 4433
  status = READ_PORT_UCHAR(CurrentStatus);
  }
#line 4435
  if (((int )status & 184) == 184) {
    {
#line 4437
    WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[4]);
#line 4438
    KeStallExecutionProcessor(Delay);
#line 4439
    status = READ_PORT_UCHAR(CurrentStatus);
    }
#line 4441
    if (((int )status & 184) == 24) {
      {
#line 4443
      WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[5]);
#line 4444
      KeStallExecutionProcessor(Delay);
#line 4445
      status = READ_PORT_UCHAR(CurrentStatus);
      }
#line 4447
      if (((int )status & 48) == 48) {
        {
#line 4449
        KeStallExecutionProcessor(Delay);
#line 4450
        WRITE_PORT_UCHAR(CurrentPort, (unsigned char )(136UL | ulDaisyIndex));
#line 4451
        KeStallExecutionProcessor(Delay);
        }
#line 4453
        if (ulDaisyIndex) {
#line 4454
          if ((int )bNoStrobe == 0) {
            {
#line 4456
            WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4457
            WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4458
            KeStallExecutionProcessor(Delay);
#line 4459
            WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4460
            KeStallExecutionProcessor(Delay);
            }
          } else {

          }
        } else {

        }
#line 4468
        ucExpectedPattern = (unsigned char)240;
#line 4469
        bReturnValue = (unsigned char)1;
        {
#line 4471
        while (1) {
          while_13_continue: /* CIL Label */ ;

#line 4473
          if (ucExpectedPattern) {

          } else {
            goto while_97_break;
          }
          {
#line 4479
          KeStallExecutionProcessor(Delay);
#line 4480
          WRITE_PORT_UCHAR(CurrentPort, (unsigned char )(128UL | ulDaisyIndex));
#line 4481
          KeStallExecutionProcessor(Delay);
#line 4482
          WRITE_PORT_UCHAR(CurrentPort, (unsigned char )(136UL | ulDaisyIndex));
#line 4483
          KeStallExecutionProcessor(Delay);
#line 4484
          ucReadValue = READ_PORT_UCHAR(CurrentStatus);
#line 4485
          ucReadPattern = (unsigned char )(((int )ucReadValue << 1) & 112);
#line 4486
          ucReadPattern = (unsigned char )((int )ucReadPattern | ((int )ucReadValue & 128));
          }
#line 4488
          if ((int )ucReadPattern != (int )ucExpectedPattern) {
#line 4489
            bReturnValue = (unsigned char)0;
            goto while_97_break;
          } else {

          }
#line 4494
          ucExpectedPattern = (unsigned char )((int )ucExpectedPattern - 16);
        }
        while_13_break: /* CIL Label */ ;
        }
        while_97_break: 
        {
#line 4499
        WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[6]);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 4511
  WRITE_PORT_UCHAR(CurrentControl, value);
  }
#line 4513
  return (bReturnValue);
}
}
#line 4516 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptCheckIfStlProductId(PDEVICE_EXTENSION DeviceExtension , ULONG ulDaisyIndex ) 
{ BOOLEAN bReturnValue ;
  UCHAR i ;
  UCHAR value ;
  UCHAR newvalue ;
  UCHAR status ;
  ULONG Delay ;
  UCHAR ucProdIdHiByteHiNibble ;
  UCHAR ucProdIdHiByteLoNibble ;
  UCHAR ucProdIdLoByteHiNibble ;
  UCHAR ucProdIdLoByteLoNibble ;
  UCHAR ucProdIdHiByte ;
  UCHAR ucProdIdLoByte ;
  USHORT usProdId ;
  PUCHAR CurrentPort ;
  PUCHAR CurrentStatus ;
  PUCHAR CurrentControl ;

  {
  {
#line 4536
  bReturnValue = (unsigned char)0;
#line 4537
  Delay = 3UL;
#line 4538
  CurrentPort = DeviceExtension->PortInfo.Controller;
#line 4539
  CurrentStatus = CurrentPort + 1;
#line 4540
  CurrentControl = CurrentPort + 2;
#line 4541
  value = READ_PORT_UCHAR(CurrentControl);
#line 4542
  newvalue = (unsigned char )(((int )value & -9) | 4);
#line 4543
  newvalue = (unsigned char )((int )newvalue & -33);
#line 4544
  WRITE_PORT_UCHAR(CurrentControl, newvalue);
#line 4545
  WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4546
  WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[i]);
#line 4547
  KeStallExecutionProcessor(Delay);
#line 4548
  status = READ_PORT_UCHAR(CurrentStatus);
  }
#line 4550
  if (((int )status & 184) == 184) {
    {
#line 4552
    WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[4]);
#line 4553
    KeStallExecutionProcessor(Delay);
#line 4554
    status = READ_PORT_UCHAR(CurrentStatus);
    }
#line 4556
    if (((int )status & 184) == 24) {
      {
#line 4558
      WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[5]);
#line 4559
      KeStallExecutionProcessor(Delay);
#line 4560
      status = READ_PORT_UCHAR(CurrentStatus);
      }
#line 4562
      if (((int )status & 48) == 48) {
        {
#line 4564
        WRITE_PORT_UCHAR(CurrentPort, (unsigned char )(16UL | ulDaisyIndex));
#line 4565
        KeStallExecutionProcessor(Delay);
#line 4566
        KeStallExecutionProcessor(Delay);
#line 4567
        ucProdIdLoByteHiNibble = READ_PORT_UCHAR(CurrentStatus);
#line 4568
        ucProdIdLoByteHiNibble = (unsigned char )((int )ucProdIdLoByteHiNibble & 240);
#line 4569
        KeStallExecutionProcessor(Delay);
#line 4570
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4571
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4572
        KeStallExecutionProcessor(Delay);
#line 4573
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4574
        KeStallExecutionProcessor(Delay);
#line 4575
        ucProdIdLoByteLoNibble = READ_PORT_UCHAR(CurrentStatus);
#line 4576
        ucProdIdLoByteLoNibble = (unsigned char )((int )ucProdIdLoByteLoNibble >> 4);
#line 4577
        ucProdIdLoByte = (unsigned char )((int )ucProdIdLoByteHiNibble | (int )ucProdIdLoByteLoNibble);
#line 4578
        KeStallExecutionProcessor(Delay);
#line 4579
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4580
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4581
        KeStallExecutionProcessor(Delay);
#line 4582
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4583
        KeStallExecutionProcessor(Delay);
#line 4584
        ucProdIdHiByteHiNibble = READ_PORT_UCHAR(CurrentStatus);
#line 4585
        ucProdIdHiByteHiNibble = (unsigned char )((int )ucProdIdHiByteHiNibble & 240);
#line 4586
        KeStallExecutionProcessor(Delay);
#line 4587
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4588
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4589
        KeStallExecutionProcessor(Delay);
#line 4590
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4591
        KeStallExecutionProcessor(Delay);
#line 4592
        ucProdIdHiByteLoNibble = READ_PORT_UCHAR(CurrentStatus);
#line 4593
        ucProdIdHiByteLoNibble = (unsigned char )((int )ucProdIdHiByteLoNibble >> 4);
#line 4594
        ucProdIdHiByte = (unsigned char )((int )ucProdIdHiByteHiNibble | (int )ucProdIdHiByteLoNibble);
#line 4595
        KeStallExecutionProcessor(Delay);
#line 4596
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4597
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4598
        KeStallExecutionProcessor(Delay);
#line 4599
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4600
        KeStallExecutionProcessor(Delay);
#line 4601
        usProdId = (unsigned short )(((int )ucProdIdHiByte << 8) | (int )ucProdIdLoByte);
        }
#line 4603
        if (43775 == (int )usProdId) {
#line 4604
          bReturnValue = (unsigned char)1;
        } else {
#line 4606
          if (43263 == (int )usProdId) {
#line 4607
            bReturnValue = (unsigned char)1;
          } else {

          }
        }
        {
#line 4613
        WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[6]);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 4625
  WRITE_PORT_UCHAR(CurrentControl, value);
  }
#line 4627
  return (bReturnValue);
}
}
#line 4630 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSend1284_3Command(PDEVICE_EXTENSION DeviceExtension , UCHAR Command ) 
{ UCHAR i ;
  UCHAR value ;
  UCHAR newvalue ;
  UCHAR test ;
  PUCHAR CurrentPort ;
  PUCHAR CurrentStatus ;
  PUCHAR CurrentControl ;
  ULONG Delay ;
  BOOLEAN success ;
  UCHAR tmp ;
  UCHAR tmp___0 ;
  int tmp___3 ;
  BOOLEAN tmp___4 ;
  UCHAR tmp___5 ;
  int tmp___8 ;
  BOOLEAN tmp___9 ;
  UCHAR tmp___10 ;
  int tmp___13 ;
  BOOLEAN tmp___14 ;
  UCHAR tmp___15 ;

  {
  {
#line 4653
  Delay = 3UL;
#line 4654
  success = (unsigned char)0;
#line 4655
  CurrentPort = DeviceExtension->PortInfo.Controller;
#line 4656
  CurrentStatus = CurrentPort + 1;
#line 4657
  CurrentControl = CurrentPort + 2;
#line 4658
  test = (unsigned char )((int )Command & 248);
#line 4662
  value = READ_PORT_UCHAR(CurrentControl);
#line 4663
  newvalue = (unsigned char )(((int )value & -9) | 4);
#line 4664
  newvalue = (unsigned char )((int )newvalue & -33);
#line 4665
  WRITE_PORT_UCHAR(CurrentControl, newvalue);
#line 4666
  WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4667
  KeStallExecutionProcessor(Delay);
#line 4668
  WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[i]);
#line 4669
  KeStallExecutionProcessor(Delay);
#line 4670
  tmp___15 = READ_PORT_UCHAR(CurrentPort + 1);
  }
#line 4672
  if (((int )tmp___15 & 184) == 184) {
#line 4673
    tmp___13 = 1;
  } else {
    {
#line 4676
    tmp___14 = CheckPort(CurrentPort + 1, (unsigned char)184, (unsigned char)184,
                         (unsigned short)5);
#line 4677
    tmp___13 = (int )tmp___14;
    }
  }
#line 4680
  if (tmp___13) {
    {
#line 4682
    WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[4]);
#line 4683
    KeStallExecutionProcessor(Delay);
#line 4684
    tmp___10 = READ_PORT_UCHAR(CurrentPort + 1);
    }
#line 4686
    if (((int )tmp___10 & 184) == 24) {
#line 4687
      tmp___8 = 1;
    } else {
      {
#line 4690
      tmp___9 = CheckPort(CurrentPort + 1, (unsigned char)184, (unsigned char)24,
                          (unsigned short)5);
#line 4691
      tmp___8 = (int )tmp___9;
      }
    }
#line 4694
    if (tmp___8) {
      {
#line 4696
      WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[5]);
#line 4697
      KeStallExecutionProcessor(Delay);
#line 4698
      tmp___5 = READ_PORT_UCHAR(CurrentPort + 1);
      }
#line 4700
      if (((int )tmp___5 & 48) == 48) {
#line 4701
        tmp___3 = 1;
      } else {
        {
#line 4704
        tmp___4 = CheckPort(CurrentPort + 1, (unsigned char)48, (unsigned char)48,
                            (unsigned short)5);
#line 4705
        tmp___3 = (int )tmp___4;
        }
      }
#line 4708
      if (tmp___3) {
        {
#line 4710
        KeStallExecutionProcessor(Delay);
#line 4711
        WRITE_PORT_UCHAR(CurrentPort, Command);
#line 4712
        KeStallExecutionProcessor(Delay);
#line 4713
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4714
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue | 1));
#line 4715
        KeStallExecutionProcessor(Delay);
        }
#line 4717
        if ((int )test == 224) {
          goto switch_99_224;
        } else {
#line 4720
          if ((int )test == 48) {
            goto switch_99_48;
          } else {
            goto switch_99_default;
#line 4725
            if (0) {
              switch_99_224: 
              {
#line 4730
              tmp = READ_PORT_UCHAR(CurrentStatus);
              }
#line 4732
              if (((int )tmp & 8) == 8) {
#line 4733
                success = (unsigned char)1;
              } else {

              }
#line 4739
              if (! success) {

              } else {

              }
              goto switch_99_break;
              switch_99_48: 
              {
#line 4748
              tmp___0 = READ_PORT_UCHAR(CurrentStatus);
              }
#line 4750
              if (((int )tmp___0 & 8) != 8) {
#line 4751
                success = (unsigned char)1;
              } else {

              }
#line 4757
              if (! success) {

              } else {

              }
              goto switch_99_break;
              switch_99_default: 
              {
#line 4768
              KeStallExecutionProcessor(Delay);
#line 4769
              success = (unsigned char)1;
              }
              goto switch_99_break;
            } else {
              switch_99_break: ;
            }
          }
        }
        {
#line 4779
        WRITE_PORT_UCHAR(CurrentControl, (unsigned char )((int )newvalue & -2));
#line 4780
        KeStallExecutionProcessor(Delay);
#line 4781
        WRITE_PORT_UCHAR(CurrentPort, ModeQualifier___6[6]);
        }
      } else {

      }
    } else {

    }
  } else {

  }
  {
#line 4793
  WRITE_PORT_UCHAR(CurrentControl, value);
  }
#line 4795
  return (success);
}
}
#line 4802
#pragma warning(push)
#line 4803
#pragma warning(disable:4035)
#line 4804
#pragma warning(pop)
#line 4806
#pragma warning(disable:4103)
#line 4807
#pragma warning(disable:4103)
#line 4808
#pragma warning(push)
#line 4809
#pragma warning(disable:4035)
#line 4810
#pragma warning(pop)
#line 4811
#pragma warning(disable:4035)
#line 4812
#pragma warning(push)
#line 4813
#pragma warning(disable:4164)
#line 4814
#pragma function(_enable)
#line 4815
#pragma function(_disable)
#line 4816
#pragma warning(pop)
#line 4817
#pragma warning(disable:4103)
#line 4818
#pragma warning(disable:4103)
#line 4819
#pragma warning(disable:4103)
#line 4820
#pragma warning(disable:4103)
#line 4821
#pragma warning(disable:4103)
#line 4822
#pragma warning(disable:4103)
#line 4823
#pragma warning(disable:4200)
#line 4824
#pragma warning(default:4200)
#line 4826
NTSTATUS PptDetectPortCapabilities(PDEVICE_EXTENSION Extension ) ;
#line 4827
void PptDetectEcpPort(PDEVICE_EXTENSION Extension ) ;
#line 4828
void PptDetectEppPortIfDot3DevicePresent(PDEVICE_EXTENSION Extension ) ;
#line 4829
void PptDetectEppPortIfUserRequested(PDEVICE_EXTENSION Extension ) ;
#line 4830
void PptDetectBytePort(PDEVICE_EXTENSION Extension ) ;
#line 4831
void PptDetermineFifoDepth(PDEVICE_EXTENSION Extension ) ;
#line 4832
void PptDetermineFifoWidth(PDEVICE_EXTENSION Extension ) ;
#line 4833
NTSTATUS PptEcrSetMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) ;
#line 4834
NTSTATUS PptEcrClearMode(PDEVICE_EXTENSION Extension ) ;
#line 4835
NTSTATUS PptFindNatChip(PDEVICE_EXTENSION Extension ) ;
#line 4836
NTSTATUS PptBuildResourceList(PDEVICE_EXTENSION Extension , ULONG Partial , PULONG Addresses ,
                              PCM_RESOURCE_LIST Resources ) ;
#line 4838
NTSTATUS PptSetByteMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) ;
#line 4839
NTSTATUS PptClearByteMode(PDEVICE_EXTENSION Extension ) ;
#line 4840
NTSTATUS PptCheckByteMode(PDEVICE_EXTENSION Extension ) ;
#line 4841 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int Extension_FilterMode  =    0;
#line 4842 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDetectChipFilter(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS Status ;
  UCHAR ecrLast ;
  PUCHAR Controller ;
  PUCHAR EcpController ;
  PUCHAR wPortECR ;

  {
#line 4851
  Status = -1073741810L;
#line 4852
  Controller = Extension->PortInfo.Controller;
#line 4853
  EcpController = Extension->PnpInfo.EcpController;
#line 4857
  Extension->ChipInfo.success = (unsigned char)0;
#line 4858
  Extension->ChipInfo.Controller = Controller;
#line 4859
  Extension->ChipInfo.EcrController = EcpController;
#line 4862
  if (Extension_FilterMode) {
#line 4863
    if (Extension->PnpInfo.HardwareCapabilities & 1UL) {
      {
#line 4867
      Status = (*(Extension->ChipInfo.ParChipSetMode))(Extension->ChipInfo.Context,
                                                       (unsigned char)96);
      }
#line 4870
      if (Status >= 0L) {
        {
#line 4874
        wPortECR = EcpController + 2;
#line 4875
        ecrLast = READ_PORT_UCHAR(wPortECR);
#line 4876
        PptDetermineFifoWidth(Extension);
#line 4877
        PptDetermineFifoDepth(Extension);
#line 4878
        WRITE_PORT_UCHAR(wPortECR, ecrLast);
#line 4879
        Status = (*(Extension->ChipInfo.ParChipClearMode))(Extension->ChipInfo.Context,
                                                           (unsigned char)96);
        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 4893
  return (Status);
}
}
#line 4896 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDetectPortType(PDEVICE_EXTENSION Extension ) 
{ int __BLAST_NONDET ;
  NTSTATUS Status ;
  UNICODE_STRING ParportPath ;
  RTL_QUERY_REGISTRY_TABLE RegTable[2] ;
  ULONG IdentifierHex ;
  ULONG zero ;

  {
  {
#line 4905
  IdentifierHex = 12169UL;
#line 4906
  zero = 0UL;
#line 4910
  memset((void *)(RegTable), 0, sizeof(RegTable));
#line 4911
  RegTable[0].Flags = 36UL;
#line 4912
  RegTable[0].EntryContext = (void *)(& IdentifierHex);
#line 4913
  RegTable[0].DefaultType = 4UL;
#line 4914
  RegTable[0].DefaultData = (void *)(& zero);
#line 4915
  RegTable[0].DefaultLength = (unsigned long )sizeof(ULONG );
#line 4916
  Status = RtlQueryRegistryValues(1UL, (WCHAR const   *)ParportPath.Buffer, RegTable,
                                  (void *)0, (void *)0);
  }
#line 4922
  if (Status >= 0L) {
#line 4923
    if (IdentifierHex == 0UL) {

    } else {
      goto _L;
    }
  } else {
    _L: 
#line 4930
    if (Status != -1073741772L) {
      {
#line 4936
      PptDetectEcpPort(Extension);
#line 4937
      PptDetectBytePort(Extension);
      }
#line 4939
      if (Extension->PnpInfo.HardwareCapabilities & 9UL) {
#line 4940
        return (0L);
      } else {
#line 4942
        return (-1073741810L);
      }
    } else {

    }
  }
#line 4948
  IdentifierHex = 12169UL;
#line 4949
  if (__BLAST_NONDET) {
#line 4950
    Status = 0L;
  } else {
#line 4952
    Status = -1073741823L;
  }
  {
#line 4957
  Status = PptDetectPortCapabilities(Extension);
#line 4961
  Status = 0L;
  }
#line 4964
  return (Status);
}
}
#line 4967 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDetectPortCapabilities(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS Status ;

  {
  {
#line 4976
  PptDetectEcpPort(Extension);
  }
#line 4978
  if (Extension->PnpInfo.HardwareCapabilities & 1UL) {
#line 4979
    if (((unsigned long )Extension->PortInfo.Controller & 15UL) != 12UL) {
      {
#line 4983
      Status = PptFindNatChip(Extension);
      }
#line 4985
      if (Status >= 0L) {
#line 4986
        if (! Extension->NationalChipFound) {
          {
#line 4992
          PptDetectEppPortIfDot3DevicePresent(Extension);
          }
#line 4994
          if (! Extension->CheckedForGenericEpp) {
            {
#line 4996
            PptDetectEppPortIfUserRequested(Extension);
            }
          } else {

          }
        } else {
#line 5004
          Extension->CheckedForGenericEpp = (unsigned char)1;
        }
      } else {

      }
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 5016
    Extension->CheckedForGenericEpp = (unsigned char)1;
  }
  {
#line 5021
  PptDetectBytePort(Extension);
  }
#line 5023
  if (Extension->PnpInfo.HardwareCapabilities & 11UL) {
#line 5026
    return (0L);
  } else {

  }
#line 5032
  return (-1073741810L);
}
}
#line 5035 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetectEcpPort(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;
  PUCHAR wPortDCR ;
  PUCHAR wPortECR ;
  UCHAR ecrLast ;
  UCHAR ecr ;
  UCHAR dcr ;

  {
#line 5044
  Controller = Extension->PortInfo.Controller;
#line 5045
  wPortDCR = Controller + 2;
#line 5046
  if ((unsigned int )((UCHAR *)0) == (unsigned int )Extension->PnpInfo.EcpController) {
#line 5049
    return;
  } else {

  }
  {
#line 5053
  wPortECR = Extension->PnpInfo.EcpController + 2;
#line 5059
  ecr = READ_PORT_UCHAR(wPortECR);
#line 5060
  ecrLast = ecr;
#line 5065
  dcr = (unsigned char)14;
#line 5066
  WRITE_PORT_UCHAR(wPortDCR, dcr);
#line 5067
  ecr = READ_PORT_UCHAR(wPortECR);
#line 5068
  ecrLast = ecr;
  }
#line 5072
  if (((int )ecr & 3) == 3) {
    goto _L;
  } else {
#line 5075
    if ((int )ecrLast == 255) {
      _L: 
      {
#line 5080
      dcr = (unsigned char)12;
#line 5081
      WRITE_PORT_UCHAR(wPortDCR, dcr);
      }
#line 5083
      return;
    } else {

    }
  }
#line 5088
  if (((int )ecr & 3) == 2) {
    {
#line 5090
    dcr = (unsigned char)12;
#line 5091
    WRITE_PORT_UCHAR(wPortDCR, dcr);
#line 5092
    ecr = READ_PORT_UCHAR(wPortECR);
    }
#line 5094
    if (((int )ecr & 3) == 0) {
      {
#line 5098
      dcr = (unsigned char)12;
#line 5099
      WRITE_PORT_UCHAR(wPortDCR, dcr);
      }
#line 5101
      return;
    } else {

    }
  } else {

  }
  {
#line 5109
  WRITE_PORT_UCHAR(wPortECR, (unsigned char)20);
#line 5110
  ecr = READ_PORT_UCHAR(wPortECR);
  }
#line 5112
  if (! (((int )ecr & 3) == 1)) {
    {
#line 5116
    dcr = (unsigned char)12;
#line 5117
    WRITE_PORT_UCHAR(wPortDCR, dcr);
    }
#line 5119
    return;
  } else {

  }
  {
#line 5124
  WRITE_PORT_UCHAR(wPortECR, ecrLast);
#line 5125
  ecrLast = READ_PORT_UCHAR(wPortECR);
#line 5126
  ecr = (unsigned char )((int )ecrLast & 31);
#line 5127
  WRITE_PORT_UCHAR(wPortECR, (unsigned char )((int )ecr | 192));
#line 5128
  PptDetermineFifoWidth(Extension);
  }
#line 5130
  if (0UL != Extension->PnpInfo.FifoWidth) {
    {
#line 5132
    Extension->PnpInfo.HardwareCapabilities |= 1UL;
#line 5133
    PptDetermineFifoDepth(Extension);
    }
  } else {

  }
  {
#line 5141
  WRITE_PORT_UCHAR(wPortECR, ecrLast);
  }
#line 5143
  return;
}
}
#line 5146 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetectEppPortIfDot3DevicePresent(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS status ;
  PUCHAR Controller ;
  UCHAR Reverse ;
  UCHAR Forward ;
  BOOLEAN daisyChainDevicePresent ;
  PARALLEL_1284_COMMAND Command ;

  {
#line 5155
  Controller = Extension->PortInfo.Controller;
#line 5156
  Reverse = (unsigned char)38;
#line 5157
  Forward = (unsigned char)6;
#line 5158
  daisyChainDevicePresent = (unsigned char)0;
#line 5159
  if (0UL == Extension->PnpInfo.Ieee1284_3DeviceCount) {
#line 5162
    return;
  } else {

  }
  {
#line 5167
  Command.ID = (unsigned char)0;
#line 5168
  Command.Port = (unsigned char)0;
#line 5169
  Command.CommandFlags = 2UL;
#line 5170
  status = PptTrySelectDevice((void *)Extension, (void *)(& Command));
  }
#line 5172
  if (! (status >= 0L)) {
#line 5175
    return;
  } else {

  }
  {
#line 5180
  PptDetectEppPort(Extension);
#line 5181
  Command.ID = (unsigned char)0;
#line 5182
  Command.Port = (unsigned char)0;
#line 5183
  Command.CommandFlags = 2UL;
#line 5184
  status = PptDeselectDevice((void *)Extension, (void *)(& Command));
  }
#line 5186
  if (! (status >= 0L)) {

  } else {

  }
#line 5193
  return;
}
}
#line 5196 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetectEppPortIfUserRequested(PDEVICE_EXTENSION Extension ) 
{ ULONG RequestEppTest ;

  {
#line 5200
  RequestEppTest = 0UL;
#line 5201
  if (RequestEppTest) {
    {
#line 5203
    PptDetectEppPort(Extension);
    }
  } else {

  }
#line 5208
  return;
}
}
#line 5211 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetectEppPort(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;
  UCHAR dcr ;
  UCHAR i ;
  UCHAR Reverse ;
  UCHAR Forward ;
  BOOLEAN daisyChainDevicePresent ;
  ULONG DisableEppTest ;
  UCHAR tmp ;

  {
  {
#line 5222
  Reverse = (unsigned char)38;
#line 5223
  Forward = (unsigned char)6;
#line 5224
  daisyChainDevicePresent = (unsigned char)0;
#line 5225
  DisableEppTest = 0UL;
#line 5229
  Controller = Extension->PortInfo.Controller;
#line 5230
  dcr = READ_PORT_UCHAR(Controller + 2);
#line 5231
  Extension->PnpInfo.HardwareCapabilities |= 2UL;
#line 5236
  PptEcrSetMode(Extension, (unsigned char)148);
#line 5237
  WRITE_PORT_UCHAR(Controller + 2, Reverse);
#line 5238
  KeStallExecutionProcessor(5UL);
#line 5239
  WRITE_PORT_UCHAR(Controller + 4, i);
#line 5240
  WRITE_PORT_UCHAR(Controller + 2, Forward);
#line 5241
  KeStallExecutionProcessor(5UL);
#line 5242
  tmp = READ_PORT_UCHAR(Controller);
  }
#line 5244
  if ((int )tmp != (int )i) {
#line 5245
    Extension->PnpInfo.HardwareCapabilities &= 4294967293UL;
  } else {

  }
  {
#line 5250
  PptEcrClearMode(Extension);
#line 5251
  WRITE_PORT_UCHAR(Controller + 2, dcr);
#line 5252
  Extension->CheckedForGenericEpp = (unsigned char)1;
  }
#line 5254
  if (Extension->PnpInfo.HardwareCapabilities & 2UL) {

  } else {

  }
#line 5261
  return;
}
}
#line 5264 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetectBytePort(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS Status ;

  {
  {
#line 5268
  Status = 0L;
#line 5272
  Status = PptSetByteMode(Extension, (unsigned char)52);
  }
#line 5274
  if (Status >= 0L) {
#line 5277
    Extension->PnpInfo.HardwareCapabilities |= 8UL;
  } else {

  }
  {
#line 5283
  PptClearByteMode(Extension);
  }
#line 5285
  return;
}
}
#line 5288 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetermineFifoDepth(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;
  PUCHAR wPortECR ;
  PUCHAR wPortDFIFO ;
  UCHAR ecr ;
  UCHAR ecrLast ;
  ULONG wFifoDepth ;
  UCHAR writeFifoDepth ;
  UCHAR readFifoDepth ;
  ULONG limitCount ;
  UCHAR testData ;
  UCHAR tmp ;
  UCHAR tmp___0 ;

  {
  {
#line 5304
  Controller = Extension->PortInfo.Controller;
#line 5305
  wPortECR = Extension->PnpInfo.EcpController + 2;
#line 5306
  wPortDFIFO = Extension->PnpInfo.EcpController;
#line 5307
  wFifoDepth = 0UL;
#line 5308
  ecrLast = READ_PORT_UCHAR(wPortECR);
#line 5309
  WRITE_PORT_UCHAR(wPortECR, (unsigned char)212);
#line 5310
  ecr = READ_PORT_UCHAR(wPortECR);
  }
#line 5312
  if (((int )ecr & 3) == 1) {
#line 5313
    writeFifoDepth = (unsigned char)0;
#line 5314
    limitCount = 0UL;
    {
#line 5316
    while (1) {
      while_14_continue: /* CIL Label */ ;
      {
#line 5319
      tmp = READ_PORT_UCHAR(wPortECR);
      }
#line 5321
      if (((int )tmp & 3) != 2) {
#line 5322
        if (limitCount <= 4098UL) {

        } else {
          goto while_148_break;
        }
      } else {
        goto while_148_break;
      }
      {
#line 5331
      WRITE_PORT_UCHAR(wPortDFIFO, (unsigned char )((int )writeFifoDepth & 255));
#line 5332
      writeFifoDepth = (unsigned char )((int )writeFifoDepth + 1);
#line 5333
      limitCount += 1UL;
      }
    }
    while_14_break: /* CIL Label */ ;
    }
    while_148_break: 
#line 5340
    readFifoDepth = (unsigned char)0;
#line 5341
    limitCount = 0UL;
    {
#line 5343
    while (1) {
      while_15_continue: /* CIL Label */ ;
      {
#line 5346
      tmp___0 = READ_PORT_UCHAR(wPortECR);
      }
#line 5348
      if (((int )tmp___0 & 3) != 1) {
#line 5349
        if (limitCount <= 4098UL) {

        } else {
          goto while_150_break;
        }
      } else {
        goto while_150_break;
      }
      {
#line 5358
      testData = READ_PORT_UCHAR(wPortDFIFO);
      }
#line 5360
      if ((int )testData != ((int )readFifoDepth & 255)) {
        {
#line 5362
        WRITE_PORT_UCHAR(wPortECR, ecrLast);
        }
#line 5366
        return;
      } else {

      }
#line 5370
      readFifoDepth = (unsigned char )((int )readFifoDepth + 1);
#line 5371
      limitCount += 1UL;
    }
    while_15_break: /* CIL Label */ ;
    }
    while_150_break: ;
#line 5377
    if ((int )writeFifoDepth == (int )readFifoDepth) {
#line 5378
      wFifoDepth = (unsigned long )readFifoDepth;
    } else {
      {
#line 5381
      WRITE_PORT_UCHAR(wPortECR, ecrLast);
      }
#line 5385
      return;
    }
  } else {
    {
#line 5391
    WRITE_PORT_UCHAR(wPortECR, ecrLast);
    }
#line 5393
    return;
  }
  {
#line 5396
  WRITE_PORT_UCHAR(wPortECR, ecrLast);
#line 5397
  Extension->PnpInfo.FifoDepth = wFifoDepth;
  }
#line 5399
  return;
}
}
#line 5402 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDetermineFifoWidth(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;
  UCHAR bConfigA ;
  PUCHAR wPortECR ;

  {
  {
#line 5411
  Controller = Extension->PortInfo.Controller;
#line 5412
  wPortECR = Extension->PnpInfo.EcpController + 2;
#line 5413
  WRITE_PORT_UCHAR(wPortECR, (unsigned char)244);
#line 5414
  bConfigA = READ_PORT_UCHAR(Extension->PnpInfo.EcpController);
#line 5415
  Extension->PnpInfo.FifoWidth = (unsigned long )(((int )bConfigA & 112) >> 4);
#line 5416
  WRITE_PORT_UCHAR(wPortECR, (unsigned char)20);
  }
#line 5418
  return;
}
}
#line 5421 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptSetChipMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) 
{ NTSTATUS Status ;
  UCHAR EcrMode ;

  {
#line 5426
  Status = 0L;
#line 5427
  EcrMode = (unsigned char )((int )ChipMode & -32);
#line 5430
  if (Extension->PnpInfo.CurrentMode != 0UL) {
#line 5433
    Status = -1073741436L;
    goto ExitSetChipModeNoChange;
  } else {

  }
#line 5438
  if (Extension_FilterMode) {
    {
#line 5442
    Status = (*(Extension->ChipInfo.ParChipSetMode))(Extension->ChipInfo.Context,
                                                     ChipMode);
    }
  } else {
#line 5448
    if ((int )EcrMode == 96) {
#line 5449
      if ((Extension->PnpInfo.HardwareCapabilities & 1UL) ^ 1UL) {
#line 5452
        return (-1073741810L);
      } else {

      }
      {
#line 5457
      Status = PptEcrSetMode(Extension, ChipMode);
      }
      goto ExitSetChipModeWithChanges;
    } else {

    }
#line 5463
    if ((int )EcrMode == 128) {
#line 5464
      if ((Extension->PnpInfo.HardwareCapabilities & 2UL) ^ 2UL) {
#line 5467
        return (-1073741810L);
      } else {

      }
      {
#line 5472
      Status = PptEcrSetMode(Extension, ChipMode);
      }
      goto ExitSetChipModeWithChanges;
    } else {

    }
#line 5478
    if ((int )EcrMode == 32) {
#line 5479
      if ((Extension->PnpInfo.HardwareCapabilities & 8UL) ^ 8UL) {
#line 5482
        return (-1073741810L);
      } else {

      }
      {
#line 5487
      Status = PptSetByteMode(Extension, ChipMode);
      }
      goto ExitSetChipModeWithChanges;
    } else {

    }
  }
  ExitSetChipModeWithChanges: 
#line 5495
  if (Status >= 0L) {
#line 5498
    Extension->PnpInfo.CurrentMode = (unsigned long )EcrMode;
  } else {

  }
  ExitSetChipModeNoChange: ;
#line 5506
  return (Status);
}
}
#line 5509 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptClearChipMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) 
{ NTSTATUS Status ;
  ULONG EcrMode ;

  {
#line 5514
  Status = -1073741823L;
#line 5515
  EcrMode = (unsigned long )((int )ChipMode & -32);
#line 5518
  if (EcrMode != Extension->PnpInfo.CurrentMode) {
#line 5521
    Status = -1073741436L;
    goto ExitClearChipModeNoChange;
  } else {

  }
#line 5526
  if (Extension_FilterMode) {
    {
#line 5530
    Status = (*(Extension->ChipInfo.ParChipClearMode))(Extension->ChipInfo.Context,
                                                       ChipMode);
    }
  } else {
#line 5536
    if (EcrMode == 96UL) {
      {
#line 5538
      Status = PptEcrClearMode(Extension);
      }
      goto ExitClearChipModeWithChanges;
    } else {

    }
#line 5544
    if (EcrMode == 128UL) {
      {
#line 5546
      Status = PptEcrClearMode(Extension);
      }
      goto ExitClearChipModeWithChanges;
    } else {

    }
#line 5552
    if (EcrMode == 32UL) {
      {
#line 5554
      Status = PptClearByteMode(Extension);
      }
      goto ExitClearChipModeWithChanges;
    } else {

    }
  }
  ExitClearChipModeWithChanges: 
#line 5562
  if (Status >= 0L) {
#line 5565
    Extension->PnpInfo.CurrentMode = 0UL;
  } else {

  }
  ExitClearChipModeNoChange: ;
#line 5572
  return (Status);
}
}
#line 5575 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptEcrSetMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) 
{ UCHAR ecr ;
  PUCHAR Controller ;
  PUCHAR wPortECR ;

  {
  {
#line 5583
  Controller = Extension->PortInfo.Controller;
#line 5584
  wPortECR = Extension->PnpInfo.EcpController + 2;
#line 5588
  ecr = READ_PORT_UCHAR(wPortECR);
#line 5589
  Extension->EcrPortData = ecr;
#line 5590
  ecr = (unsigned char )((int )ecr & 31);
#line 5591
  WRITE_PORT_UCHAR(wPortECR, (unsigned char )((int )ecr | 32));
#line 5592
  WRITE_PORT_UCHAR(wPortECR, ChipMode);
  }
#line 5596
  return (0L);
}
}
#line 5599 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptSetByteMode(PDEVICE_EXTENSION Extension , UCHAR ChipMode ) 
{ NTSTATUS Status ;

  {
#line 5603
  if (Extension->PnpInfo.HardwareCapabilities & 1UL) {
    {
#line 5605
    Status = PptEcrSetMode(Extension, ChipMode);
    }
  } else {

  }
  {
#line 5611
  Status = PptCheckByteMode(Extension);
  }
#line 5613
  return (Status);
}
}
#line 5616 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptClearByteMode(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS Status ;

  {
#line 5620
  Status = 0L;
#line 5621
  if (Extension->PnpInfo.HardwareCapabilities & 1UL) {
    {
#line 5623
    Status = PptEcrClearMode(Extension);
    }
  } else {

  }
#line 5628
  return (Status);
}
}
#line 5631 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptCheckByteMode(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;
  UCHAR dcr ;
  UCHAR tmp ;
  UCHAR tmp___0 ;

  {
  {
#line 5639
  Controller = Extension->PortInfo.Controller;
#line 5640
  dcr = READ_PORT_UCHAR(Controller + 2);
#line 5641
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char )((int )dcr | 32));
#line 5642
  WRITE_PORT_UCHAR(Controller, (unsigned char)85);
#line 5643
  tmp___0 = READ_PORT_UCHAR(Controller);
  }
#line 5645
  if ((int )tmp___0 == 85) {
    {
#line 5647
    WRITE_PORT_UCHAR(Controller, (unsigned char)170);
#line 5648
    tmp = READ_PORT_UCHAR(Controller);
    }
#line 5650
    if ((int )tmp == 170) {
#line 5651
      return (-1073741823L);
    } else {

    }
  } else {

  }
  {
#line 5659
  WRITE_PORT_UCHAR(Controller + 2, dcr);
  }
#line 5661
  return (0L);
}
}
#line 5664 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptEcrClearMode(PDEVICE_EXTENSION Extension ) 
{ UCHAR ecr ;
  PUCHAR Controller ;
  PUCHAR wPortECR ;

  {
  {
#line 5671
  Controller = Extension->PortInfo.Controller;
#line 5672
  ecr = Extension->EcrPortData;
#line 5673
  Extension->EcrPortData = (unsigned char)0;
#line 5674
  wPortECR = Extension->PnpInfo.EcpController + 2;
#line 5675
  WRITE_PORT_UCHAR(wPortECR, (unsigned char )((int )ecr & 31));
#line 5676
  WRITE_PORT_UCHAR(wPortECR, ecr);
  }
#line 5678
  return (0L);
}
}
#line 5681 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptFindNatChip(PDEVICE_EXTENSION Extension ) 
{ BOOLEAN found ;
  BOOLEAN OkToLook ;
  BOOLEAN Conflict ;
  PUCHAR ChipAddr[4] ;
  PUCHAR AddrList[4] ;
  PUCHAR PortAddr ;
  ULONG_PTR Port ;
  UCHAR SaveIdx ;
  UCHAR cr ;
  UCHAR ii ;
  NTSTATUS Status ;
  ULONG ResourceDescriptorCount ;
  ULONG ResourcesSize ;
  PCM_RESOURCE_LIST Resources ;
  ULONG NationalChecked ;
  ULONG NationalChipFound ;
  PVOID tmp ;
  UCHAR tmp___0 ;
  UCHAR tmp___1 ;
  UCHAR tmp___2 ;
  UCHAR tmp___3 ;
  UCHAR tmp___4 ;
  UCHAR tmp___5 ;
  UCHAR tmp___6 ;
  UCHAR tmp___7 ;
  PDEVICE_OBJECT pdo ;

  {
#line 5710
  found = (unsigned char)0;
#line 5711
  OkToLook = (unsigned char)0;
#line 5712
  ChipAddr[0] = (UCHAR *)920;
#line 5713
  ChipAddr[1] = (UCHAR *)622;
#line 5714
  ChipAddr[2] = (UCHAR *)348;
#line 5715
  ChipAddr[3] = (UCHAR *)46;
#line 5716
  AddrList[0] = (UCHAR *)888;
#line 5717
  AddrList[1] = (UCHAR *)956;
#line 5718
  AddrList[2] = (UCHAR *)632;
#line 5719
  AddrList[3] = (UCHAR *)0;
#line 5720
  NationalChecked = 0UL;
#line 5721
  NationalChipFound = 0UL;
#line 5722
  if ((int )Extension->NationalChecked == 1) {
#line 5725
    return (0L);
  } else {

  }
#line 5729
  Extension->NationalChecked = (unsigned char)1;
#line 5730
  if (NationalChecked) {
#line 5731
    if (NationalChipFound) {
#line 5732
      Extension->NationalChipFound = (unsigned char)1;
    } else {
#line 5734
      Extension->NationalChipFound = (unsigned char)0;
    }
#line 5736
    return (0L);
  } else {

  }
  {
#line 5741
  ResourceDescriptorCount = (unsigned long )(sizeof(ChipAddr) / sizeof(ULONG ));
#line 5742
  ResourcesSize = (unsigned long )sizeof(CM_RESOURCE_LIST ) + (ResourceDescriptorCount - 1UL) * (unsigned long )sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR );
#line 5743
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )0, ResourcesSize, 1349673296UL);
#line 5744
  Resources = (struct _CM_RESOURCE_LIST *)tmp;
  }
#line 5746
  if ((unsigned int )Resources == (unsigned int )((void *)0)) {
#line 5749
    return (-1073741823L);
  } else {

  }
  {
#line 5754
  memset((void *)Resources, 0, (unsigned int )ResourcesSize);
#line 5755
  Status = PptBuildResourceList(Extension, (unsigned long )(sizeof(ChipAddr) / sizeof(ULONG )),
                                (ULONG *)(ChipAddr), Resources);
  }
#line 5758
  if (! (Status >= 0L)) {
#line 5764
    return (Status);
  } else {

  }
  {
#line 5769
  Status = IoReportResourceUsage((UNICODE_STRING *)((void *)0), Extension->DriverObject,
                                 Resources, (unsigned long )sizeof(Resources), Extension->DeviceObject,
                                 (struct _CM_RESOURCE_LIST *)((void *)0), 0UL, (unsigned char)0,
                                 & Conflict);
  }
#line 5773
  if (! (Status >= 0L)) {
#line 5776
    return (Status);
  } else {

  }
#line 5780
  if (Conflict) {
#line 5783
    return (-1073741823L);
  } else {

  }
#line 5787
  ii = (unsigned char)0;
  {
#line 5789
  while (1) {
    while_16_continue: /* CIL Label */ ;

#line 5791
    if (! found) {
#line 5792
      if ((int )ii < 4) {

      } else {
        goto while_180_break;
      }
    } else {
      goto while_180_break;
    }
    {
#line 5801
    PortAddr = ChipAddr[ii];
#line 5802
    tmp___1 = READ_PORT_UCHAR(PortAddr);
    }
#line 5804
    if ((int )tmp___1 == 136) {
      {
#line 5806
      tmp___2 = READ_PORT_UCHAR(PortAddr);
      }
#line 5808
      if ((int )tmp___2 < 32) {
#line 5809
        OkToLook = (unsigned char)1;
      } else {
        goto _L;
      }
    } else {
      _L: 
      {
#line 5816
      READ_PORT_UCHAR(PortAddr);
#line 5817
      cr = READ_PORT_UCHAR(PortAddr);
      }
#line 5819
      if ((int )cr != 255) {
        {
#line 5821
        tmp___0 = READ_PORT_UCHAR(PortAddr);
        }
#line 5823
        if ((int )tmp___0 == (int )cr) {
#line 5824
          OkToLook = (unsigned char)1;
        } else {

        }
      } else {

      }
    }
#line 5832
    if (OkToLook) {
      {
#line 5834
      OkToLook = (unsigned char)0;
#line 5835
      WRITE_PORT_UCHAR(PortAddr, (unsigned char)8);
#line 5836
      cr = READ_PORT_UCHAR(PortAddr);
      }
#line 5838
      if ((int )cr == 8) {
        {
#line 5840
        tmp___3 = READ_PORT_UCHAR(PortAddr + 1);
#line 5841
        cr = (unsigned char )((int )tmp___3 & 240);
        }
#line 5843
        if ((int )cr == 16) {
          goto _L___0;
        } else {
#line 5846
          if ((int )cr == 80) {
            goto _L___0;
          } else {
#line 5849
            if ((int )cr == 112) {
              goto _L___0;
            } else {
#line 5852
              if ((int )cr == 48) {
                goto _L___0;
              } else {
#line 5855
                if ((int )cr == 32) {
                  goto _L___0;
                } else {
#line 5858
                  if ((int )cr == 144) {
                    goto _L___0;
                  } else {
#line 5861
                    if ((int )cr == 176) {
                      goto _L___0;
                    } else {
#line 5864
                      if ((int )cr == 96) {
                        _L___0: 
                        {
#line 5867
                        found = (unsigned char)1;
#line 5868
                        WRITE_PORT_UCHAR(PortAddr, (unsigned char)1);
#line 5869
                        tmp___4 = READ_PORT_UCHAR(PortAddr + 1);
#line 5870
                        Port = (unsigned long )((int )tmp___4 & 3);
                        }
#line 5872
                        if ((unsigned int )Extension->PortInfo.Controller == (unsigned int )AddrList[Port]) {
#line 5873
                          Extension->NationalChipFound = (unsigned char)1;
                        } else {

                        }
                      } else {

                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {

      }
    } else {

    }
#line 5893
    if (! found) {
      {
#line 5895
      SaveIdx = READ_PORT_UCHAR(PortAddr);
#line 5896
      WRITE_PORT_UCHAR(PortAddr, (unsigned char)32);
#line 5897
      WRITE_PORT_UCHAR(PortAddr + 1, (unsigned char)0);
#line 5898
      tmp___5 = READ_PORT_UCHAR(PortAddr + 1);
#line 5899
      cr = (unsigned char )((int )tmp___5 & 248);
      }
#line 5901
      if ((int )cr == 192) {
        goto _L___1;
      } else {
#line 5904
        if ((int )cr == 160) {
          _L___1: 
          {
#line 5907
          found = (unsigned char)1;
#line 5908
          WRITE_PORT_UCHAR(PortAddr, (unsigned char)7);
#line 5909
          WRITE_PORT_UCHAR(PortAddr + 1, (unsigned char)4);
#line 5910
          WRITE_PORT_UCHAR(PortAddr, (unsigned char)96);
#line 5911
          tmp___6 = READ_PORT_UCHAR(PortAddr + 1);
#line 5912
          Port = (unsigned long )(((int )tmp___6 << 8) & 65280);
#line 5913
          WRITE_PORT_UCHAR(PortAddr, (unsigned char)97);
#line 5914
          tmp___7 = READ_PORT_UCHAR(PortAddr + 1);
#line 5915
          Port |= (unsigned long )tmp___7;
          }
#line 5917
          if ((unsigned int )Extension->PortInfo.Controller == (unsigned int )((UCHAR *)Port)) {
#line 5918
            Extension->NationalChipFound = (unsigned char)1;
          } else {

          }
        } else {
          {
#line 5924
          WRITE_PORT_UCHAR(PortAddr, SaveIdx);
          }
        }
      }
    } else {

    }
#line 5931
    ii = (unsigned char )((int )ii + 1);
  }
  while_16_break: /* CIL Label */ ;
  }
  while_180_break: 
#line 5935
  pdo = Extension->PhysicalDeviceObject;
#line 5936
  NationalChecked = 1UL;
#line 5937
  if (Extension->NationalChipFound) {
#line 5938
    NationalChipFound = 1UL;
  } else {
#line 5940
    NationalChipFound = 0UL;
  }
  {
#line 5943
  Status = IoReportResourceUsage((UNICODE_STRING *)((void *)0), Extension->DriverObject,
                                 (struct _CM_RESOURCE_LIST *)((void *)0), 0UL, Extension->DeviceObject,
                                 (struct _CM_RESOURCE_LIST *)((void *)0), 0UL, (unsigned char)0,
                                 & Conflict);
  }
#line 5948
  return (Status);
}
}
#line 5951 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptBuildResourceList(PDEVICE_EXTENSION Extension , ULONG Partial , PULONG Addresses ,
                              PCM_RESOURCE_LIST Resources ) 
{ UCHAR i ;

  {
#line 5956
  Resources->Count = 1UL;
#line 5957
  Resources->List[0].InterfaceType = Extension->InterfaceType;
#line 5958
  Resources->List[0].BusNumber = Extension->BusNumber;
#line 5959
  Resources->List[0].PartialResourceList.Version = (unsigned short)0;
#line 5960
  Resources->List[0].PartialResourceList.Revision = (unsigned short)0;
#line 5961
  Resources->List[0].PartialResourceList.Count = Partial;
#line 5962
  i = (unsigned char)0;
  {
#line 5964
  while (1) {
    while_17_continue: /* CIL Label */ ;

#line 5966
    if ((unsigned long )i < Partial) {

    } else {
      goto while_182_break;
    }
#line 5971
    Resources->List[0].PartialResourceList.PartialDescriptors[i].Type = (unsigned char)1;
#line 5972
    Resources->List[0].PartialResourceList.PartialDescriptors[i].ShareDisposition = (unsigned char)2;
#line 5973
    Resources->List[0].PartialResourceList.PartialDescriptors[i].Flags = (unsigned short)1;
#line 5974
    Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Start.QuadPart = (long long )*(Addresses + (int )i);
#line 5975
    Resources->List[0].PartialResourceList.PartialDescriptors[i].u.Port.Length = 2UL;
#line 5976
    i = (unsigned char )((int )i + 1);
  }
  while_17_break: /* CIL Label */ ;
  }
  while_182_break: ;
#line 5980
  return (0L);
}
}
#line 5987
#pragma warning(push)
#line 5988
#pragma warning(disable:4035)
#line 5989
#pragma warning(pop)
#line 5991
#pragma warning(disable:4103)
#line 5992
#pragma warning(disable:4103)
#line 5993
#pragma warning(push)
#line 5994
#pragma warning(disable:4035)
#line 5995
#pragma warning(pop)
#line 5996
#pragma warning(disable:4035)
#line 5997
#pragma warning(push)
#line 5998
#pragma warning(disable:4164)
#line 5999
#pragma function(_enable)
#line 6000
#pragma function(_disable)
#line 6001
#pragma warning(pop)
#line 6002
#pragma warning(disable:4103)
#line 6003
#pragma warning(disable:4103)
#line 6004
#pragma warning(disable:4103)
#line 6005
#pragma warning(disable:4103)
#line 6006
#pragma warning(disable:4103)
#line 6007
#pragma warning(disable:4103)
#line 6008
#pragma warning(disable:4200)
#line 6009
#pragma warning(default:4200)
#line 6012 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _GUID  const  GUID_PARALLEL_DEVICE  =    {2549575408UL, (unsigned short)63619, (unsigned short)4560, {(unsigned char)175,
                                                                (unsigned char)31,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)248,
                                                                (unsigned char)0,
                                                                (unsigned char)132,
                                                                (unsigned char)92}};
#line 6013 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
struct _GUID  const  GUID_PARCLASS_DEVICE  =    {2166343333UL, (unsigned short)63272, (unsigned short)4560, {(unsigned char)165,
                                                                (unsigned char)55,
                                                                (unsigned char)0,
                                                                (unsigned char)0,
                                                                (unsigned char)248,
                                                                (unsigned char)117,
                                                                (unsigned char)62,
                                                                (unsigned char)209}};
#line 6014 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
ULONG PptDebugLevel  =    0UL;
#line 6015 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
ULONG PptBreakOn  =    0UL;
#line 6016 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
UNICODE_STRING RegistryPath  =    {(USHORT )0, (USHORT )0, (PWSTR )0};
#line 6017 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
LONG PortInfoReferenceCount  =    -1L;
#line 6018 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PFAST_MUTEX PortInfoMutex  =    (PFAST_MUTEX )((void *)0);
#line 6019 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
union _LARGE_INTEGER  const  PhysicalZero  =    {{(ULONG )0, 0L}};
#line 6020 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
UCHAR PptDot3Retries  =    (UCHAR )5;
#line 6025
#pragma warning(push)
#line 6026
#pragma warning(disable:4035)
#line 6027
#pragma warning(pop)
#line 6029
#pragma warning(disable:4103)
#line 6030
#pragma warning(disable:4103)
#line 6031
#pragma warning(push)
#line 6032
#pragma warning(disable:4035)
#line 6033
#pragma warning(pop)
#line 6034
#pragma warning(disable:4035)
#line 6035
#pragma warning(push)
#line 6036
#pragma warning(disable:4164)
#line 6037
#pragma function(_enable)
#line 6038
#pragma function(_disable)
#line 6039
#pragma warning(pop)
#line 6040
#pragma warning(disable:4103)
#line 6041
#pragma warning(disable:4103)
#line 6042
#pragma warning(disable:4103)
#line 6043
#pragma warning(disable:4103)
#line 6044
#pragma warning(disable:4103)
#line 6045
#pragma warning(disable:4103)
#line 6046
#pragma warning(disable:4200)
#line 6047
#pragma warning(default:4200)
#line 6049
NTSTATUS PptPnpFilterResourceRequirements(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6050
NTSTATUS PptPnpQueryDeviceRelations(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6051
NTSTATUS PptPnpQueryStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6052
NTSTATUS PptPnpCancelStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6053
NTSTATUS PptPnpStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6054
NTSTATUS PptPnpQueryRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6055
NTSTATUS PptPnpCancelRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6056
NTSTATUS PptPnpRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6057
NTSTATUS PptPnpSurpriseRemoval(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6058
NTSTATUS PptPnpUnhandledIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6059
NTSTATUS PptPnpStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 6060
NTSTATUS PptPnpStartValidateResources(PDEVICE_OBJECT DeviceObject , BOOLEAN FoundPort ,
                                      BOOLEAN FoundIrq , BOOLEAN FoundDma ) ;
#line 6062
NTSTATUS PptPnpStartScanCmResourceList(PDEVICE_EXTENSION Extension , PIRP Irp , PBOOLEAN FoundPort ,
                                       PBOOLEAN FoundIrq , PBOOLEAN FoundDma ) ;
#line 6064
NTSTATUS PptPnpPassThroughPnpIrpAndReleaseRemoveLock(PDEVICE_EXTENSION Extension ,
                                                     PIRP Irp ) ;
#line 6066
void PptPnpFilterNukeIrqResourceDescriptors(PIO_RESOURCE_LIST IoResourceList ) ;
#line 6067
void PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) ;
#line 6068
BOOLEAN PptPnpFilterExistsNonIrqResourceList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) ;
#line 6069
PVOID PptPnpFilterGetEndOfResourceRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) ;
#line 6070
BOOLEAN PptPnpListContainsIrqResourceDescriptor(PIO_RESOURCE_LIST List ) ;
#line 6071
void PptPnpFilterRemoveIrqResourceLists(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) ;
#line 6072
NTSTATUS PptPnpBounceAndCatchPnpIrp(PDEVICE_EXTENSION Extension , PIRP Irp ) ;
#line 6073 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PDEVICE_RELATIONS PptPnpBuildRemovalRelations(PDEVICE_EXTENSION Extension ) 
{ PDEVICE_RELATIONS relations ;
  PLIST_ENTRY listHead ;
  PLIST_ENTRY thisListEntry ;
  PLIST_ENTRY firstListEntry ;
  BOOLEAN done ;
  PREMOVAL_RELATIONS_LIST_ENTRY node ;
  ULONG count ;
  ULONG i ;
  PDEVICE_OBJECT pDevObj ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;
  PLIST_ENTRY _EX_Flink___0 ;
  PLIST_ENTRY _EX_ListHead ;
  PLIST_ENTRY _EX_Blink___0 ;
  PLIST_ENTRY _EX_ListHead___0 ;
  PVOID tmp ;
  PLIST_ENTRY _EX_Blink___1 ;
  PLIST_ENTRY _EX_Flink___1 ;
  PLIST_ENTRY _EX_Blink___2 ;
  PLIST_ENTRY _EX_ListHead___1 ;

  {
#line 6096
  relations = (struct _DEVICE_RELATIONS *)((void *)0);
#line 6097
  listHead = & Extension->RemovalRelationsList;
#line 6098
  thisListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 6099
  firstListEntry = (struct _LIST_ENTRY *)((void *)0);
#line 6100
  done = (unsigned char)0;
#line 6101
  node = (struct _REMOVAL_RELATIONS_LIST_ENTRY *)((void *)0);
#line 6107
  if ((unsigned int )listHead->Flink == (unsigned int )listHead) {
    goto targetExit;
  } else {

  }
#line 6114
  count = 0UL;
  {
#line 6116
  while (1) {
    while_18_continue: /* CIL Label */ ;

#line 6118
    if (! done) {

    } else {
      goto while_185_break;
    }
#line 6123
    thisListEntry = listHead->Flink;
#line 6124
    _EX_Flink = (listHead->Flink)->Flink;
#line 6125
    _EX_Blink = (listHead->Flink)->Blink;
#line 6126
    _EX_Blink->Flink = _EX_Flink;
#line 6127
    _EX_Flink->Blink = _EX_Blink;
#line 6128
    node = (REMOVAL_RELATIONS_LIST_ENTRY *)((CHAR *)thisListEntry - (unsigned long )(& ((REMOVAL_RELATIONS_LIST_ENTRY *)0)->ListEntry));
#line 6129
    if ((unsigned int )firstListEntry == (unsigned int )thisListEntry) {
#line 6130
      _EX_ListHead = listHead;
#line 6131
      _EX_Flink___0 = _EX_ListHead->Flink;
#line 6132
      node->ListEntry.Flink = _EX_Flink___0;
#line 6133
      node->ListEntry.Blink = _EX_ListHead;
#line 6134
      _EX_Flink___0->Blink = & node->ListEntry;
#line 6135
      _EX_ListHead->Flink = & node->ListEntry;
#line 6136
      done = (unsigned char)1;
    } else {
#line 6142
      _EX_ListHead___0 = listHead;
#line 6143
      _EX_Blink___0 = _EX_ListHead___0->Blink;
#line 6144
      node->ListEntry.Flink = _EX_ListHead___0;
#line 6145
      node->ListEntry.Blink = _EX_Blink___0;
#line 6146
      _EX_Blink___0->Flink = & node->ListEntry;
#line 6147
      _EX_ListHead___0->Blink = & node->ListEntry;
#line 6148
      count += 1UL;
    }
#line 6150
    if (! firstListEntry) {
#line 6153
      firstListEntry = thisListEntry;
    } else {

    }
  }
  while_18_break: /* CIL Label */ ;
  }
  while_185_break: 
  {
#line 6163
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )sizeof(DEVICE_RELATIONS ) + (count - 1UL) * (unsigned long )sizeof(PDEVICE_OBJECT ),
                              1349673296UL);
#line 6165
  relations = (struct _DEVICE_RELATIONS *)tmp;
  }
#line 6167
  if (! relations) {
    goto targetExit;
  } else {

  }
#line 6174
  relations->Count = count;
#line 6175
  i = 0UL;
  {
#line 6177
  while (1) {
    while_19_continue: /* CIL Label */ ;

#line 6179
    if (i < count) {

    } else {
      goto while_191_break;
    }
    {
#line 6184
    thisListEntry = listHead->Flink;
#line 6185
    _EX_Flink___1 = (listHead->Flink)->Flink;
#line 6186
    _EX_Blink___1 = (listHead->Flink)->Blink;
#line 6187
    _EX_Blink___1->Flink = _EX_Flink___1;
#line 6188
    _EX_Flink___1->Blink = _EX_Blink___1;
#line 6189
    node = (REMOVAL_RELATIONS_LIST_ENTRY *)((CHAR *)thisListEntry - (unsigned long )(& ((REMOVAL_RELATIONS_LIST_ENTRY *)0)->ListEntry));
#line 6193
    pDevObj = node->DeviceObject;
#line 6194
    ObfReferenceObject((void *)pDevObj);
#line 6195
    relations->Objects[i] = pDevObj;
#line 6196
    _EX_ListHead___1 = listHead;
#line 6197
    _EX_Blink___2 = _EX_ListHead___1->Blink;
#line 6198
    node->ListEntry.Flink = _EX_ListHead___1;
#line 6199
    node->ListEntry.Blink = _EX_Blink___2;
#line 6200
    _EX_Blink___2->Flink = & node->ListEntry;
#line 6201
    _EX_ListHead___1->Blink = & node->ListEntry;
#line 6202
    i += 1UL;
    }
  }
  while_19_break: /* CIL Label */ ;
  }
  while_191_break: ;
  targetExit: ;
#line 6211
  return (relations);
}
}
#line 6214 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpStartScanPciCardCmResourceList(PDEVICE_EXTENSION Extension , PIRP Irp ,
                                              PBOOLEAN FoundPort , PBOOLEAN FoundIrq ,
                                              PBOOLEAN FoundDma ) 
{ NTSTATUS status ;
  PIO_STACK_LOCATION irpStack ;
  PCM_RESOURCE_LIST ResourceList ;
  PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor ;
  PCM_PARTIAL_RESOURCE_LIST PartialResourceList ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor ;
  ULONG i ;
  ULONG length ;

  {
#line 6227
  status = 0L;
#line 6228
  irpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6231
  *FoundPort = (unsigned char)0;
#line 6232
  *FoundIrq = (unsigned char)0;
#line 6233
  *FoundDma = (unsigned char)0;
#line 6234
  ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
#line 6235
  FullResourceDescriptor = & ResourceList->List[0];
#line 6236
  if (FullResourceDescriptor) {
#line 6237
    Extension->InterfaceType = FullResourceDescriptor->InterfaceType;
#line 6238
    PartialResourceList = & FullResourceDescriptor->PartialResourceList;
#line 6239
    i = 0UL;
    {
#line 6241
    while (1) {
      while_20_continue: /* CIL Label */ ;

#line 6243
      if (i < PartialResourceList->Count) {

      } else {
        goto while_194_break;
      }
#line 6248
      PartialResourceDescriptor = & PartialResourceList->PartialDescriptors[i];
#line 6249
      if ((int )PartialResourceDescriptor->Type == 1) {
        goto switch_195_1;
      } else {
#line 6252
        if ((int )PartialResourceDescriptor->Type == 6) {
          goto switch_195_6;
        } else {
#line 6255
          if ((int )PartialResourceDescriptor->Type == 2) {
            goto switch_195_2;
          } else {
#line 6258
            if ((int )PartialResourceDescriptor->Type == 4) {
              goto switch_195_4;
            } else {
              goto switch_195_default;
#line 6263
              if (0) {
                switch_195_1: 
#line 6265
                length = PartialResourceDescriptor->u.Port.Length;
#line 6266
                if (length == 8UL) {
                  goto switch_196_8;
                } else {
#line 6269
                  if (length == 4UL) {
                    goto switch_196_4;
                  } else {
                    goto switch_196_default;
#line 6274
                    if (0) {
                      switch_196_8: 
#line 6278
                      Extension->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
#line 6279
                      Extension->PortInfo.SpanOfController = PartialResourceDescriptor->u.Port.Length;
#line 6280
                      Extension->PortInfo.Controller = (UCHAR *)((unsigned long )Extension->PortInfo.OriginalController.QuadPart);
#line 6281
                      Extension->AddressSpace = (unsigned long )PartialResourceDescriptor->Flags;
#line 6282
                      *FoundPort = (unsigned char)1;
                      goto switch_196_break;
                      switch_196_4: 
#line 6287
                      Extension->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
#line 6288
                      Extension->PnpInfo.SpanOfEcpController = PartialResourceDescriptor->u.Port.Length;
#line 6289
                      Extension->PnpInfo.EcpController = (UCHAR *)((unsigned long )Extension->PnpInfo.OriginalEcpController.QuadPart);
#line 6290
                      Extension->EcpAddressSpace = (unsigned long )PartialResourceDescriptor->Flags;
                      goto switch_196_break;
                      switch_196_default: ;
                    } else {
                      switch_196_break: ;
                    }
                  }
                }
                goto switch_195_break;
                switch_195_6: 
#line 6303
                Extension->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                goto switch_195_break;
                switch_195_2: 
#line 6306
                *FoundIrq = (unsigned char)1;
#line 6307
                Extension->FoundInterrupt = (unsigned char)1;
#line 6308
                Extension->InterruptLevel = (unsigned char )PartialResourceDescriptor->u.Interrupt.Level;
#line 6309
                Extension->InterruptVector = PartialResourceDescriptor->u.Interrupt.Vector;
#line 6310
                Extension->InterruptAffinity = PartialResourceDescriptor->u.Interrupt.Affinity;
#line 6311
                if ((int )PartialResourceDescriptor->Flags & 1) {
#line 6312
                  Extension->InterruptMode = (enum _KINTERRUPT_MODE )1;
                } else {
#line 6314
                  Extension->InterruptMode = (enum _KINTERRUPT_MODE )0;
                }
                goto switch_195_break;
                switch_195_4: 
#line 6318
                *FoundDma = (unsigned char)1;
#line 6319
                Extension->DmaChannel = PartialResourceDescriptor->u.Dma.Channel;
#line 6320
                Extension->DmaPort = PartialResourceDescriptor->u.Dma.Port;
#line 6321
                Extension->DmaWidth = PartialResourceDescriptor->Flags;
                goto switch_195_break;
                switch_195_default: ;
                goto switch_195_break;
              } else {
                switch_195_break: ;
              }
            }
          }
        }
      }
#line 6333
      i += 1UL;
    }
    while_20_break: /* CIL Label */ ;
    }
    while_194_break: ;
  } else {

  }
#line 6340
  return (status);
}
}
#line 6343 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptIsPci(PDEVICE_EXTENSION Extension , PIRP Irp ) 
{ NTSTATUS status ;
  PIO_STACK_LOCATION irpStack ;
  PCM_RESOURCE_LIST ResourceList ;
  PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor ;
  PCM_PARTIAL_RESOURCE_LIST PartialResourceList ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor ;
  ULONG i ;
  ULONG portResourceDescriptorCount ;
  BOOLEAN largePortRangeFound ;
  ULONG rangeLength ;

  {
#line 6356
  status = 0L;
#line 6357
  irpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6358
  portResourceDescriptorCount = 0UL;
#line 6359
  largePortRangeFound = (unsigned char)0;
#line 6360
  ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
#line 6361
  if ((unsigned int )ResourceList == (unsigned int )((void *)0)) {
#line 6364
    return ((unsigned char)0);
  } else {

  }
#line 6368
  FullResourceDescriptor = & ResourceList->List[0];
#line 6369
  if (FullResourceDescriptor) {
#line 6372
    PartialResourceList = & FullResourceDescriptor->PartialResourceList;
#line 6373
    i = 0UL;
    {
#line 6375
    while (1) {
      while_21_continue: /* CIL Label */ ;

#line 6377
      if (i < PartialResourceList->Count) {

      } else {
        goto while_202_break;
      }
#line 6382
      PartialResourceDescriptor = & PartialResourceList->PartialDescriptors[i];
#line 6383
      if ((int )PartialResourceDescriptor->Type == 1) {
        goto switch_203_1;
      } else {
        goto switch_203_default;
#line 6388
        if (0) {
          switch_203_1: 
#line 6390
          rangeLength = PartialResourceDescriptor->u.Port.Length;
#line 6393
          portResourceDescriptorCount += 1UL;
#line 6394
          if (rangeLength > 8UL) {
#line 6397
            largePortRangeFound = (unsigned char)1;
          } else {

          }
          goto switch_203_break;
          switch_203_default: ;
        } else {
          switch_203_break: ;
        }
      }
#line 6410
      i += 1UL;
    }
    while_21_break: /* CIL Label */ ;
    }
    while_202_break: ;
  } else {

  }
#line 6417
  if (portResourceDescriptorCount > 2UL) {
    goto _L;
  } else {
#line 6420
    if (1 == (int )largePortRangeFound) {
      _L: ;
#line 6424
      return ((unsigned char)1);
    } else {
#line 6428
      return ((unsigned char)0);
    }
  }
}
}
#line 6433 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
  {
#line 6438
  IofCompleteRequest(Irp, PriorityBoost);
  }
#line 6440
  return;
}
}
#line 6443 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
static PDRIVER_DISPATCH PptPnpDispatchFunctionTable[25]  ;
#line 6444 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptPnpInitDispatchFunctionTable(void) 
{ ULONG i ;

  {
#line 6448
  PptPnpDispatchFunctionTable[i] = & PptPnpUnhandledIrp;
#line 6449
  PptPnpDispatchFunctionTable[0] = & PptPnpStartDevice;
#line 6450
  PptPnpDispatchFunctionTable[13] = & PptPnpFilterResourceRequirements;
#line 6451
  PptPnpDispatchFunctionTable[7] = & PptPnpQueryDeviceRelations;
#line 6452
  PptPnpDispatchFunctionTable[5] = & PptPnpQueryStopDevice;
#line 6453
  PptPnpDispatchFunctionTable[6] = & PptPnpCancelStopDevice;
#line 6454
  PptPnpDispatchFunctionTable[4] = & PptPnpStopDevice;
#line 6455
  PptPnpDispatchFunctionTable[1] = & PptPnpQueryRemoveDevice;
#line 6456
  PptPnpDispatchFunctionTable[3] = & PptPnpCancelRemoveDevice;
#line 6457
  PptPnpDispatchFunctionTable[2] = & PptPnpRemoveDevice;
#line 6458
  PptPnpDispatchFunctionTable[23] = & PptPnpSurpriseRemoval;
#line 6459
  return;
}
}
#line 6462 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpAddDevice(PDRIVER_OBJECT pDriverObject , PDEVICE_OBJECT pPhysicalDeviceObject ) 
{ NTSTATUS status ;
  PDEVICE_OBJECT parentDevice ;
  PDEVICE_OBJECT pDeviceObject ;
  PDEVICE_EXTENSION Extension ;
  PCONFIGURATION_INFORMATION tmp ;

  {
  {
#line 6470
  status = 0L;
#line 6474
  pDeviceObject = PptBuildDeviceObject(pDriverObject, pPhysicalDeviceObject);
  }
#line 6476
  if ((unsigned int )((void *)0) == (unsigned int )pDeviceObject) {
#line 6479
    return (-1073741823L);
  } else {

  }
  {
#line 6484
  Extension = (struct _DEVICE_EXTENSION *)pDeviceObject->DeviceExtension;
#line 6485
  status = IoRegisterDeviceInterface(pPhysicalDeviceObject, & GUID_PARALLEL_DEVICE,
                                     (UNICODE_STRING *)((void *)0), & Extension->SymbolicLinkName);
  }
#line 6488
  if (! (status >= 0L)) {
#line 6494
    return (status);
  } else {

  }
  {
#line 6499
  parentDevice = IoAttachDeviceToDeviceStack(pDeviceObject, pPhysicalDeviceObject);
  }
#line 6501
  if ((unsigned int )((void *)0) == (unsigned int )parentDevice) {
#line 6507
    return (-1073741823L);
  } else {

  }
  {
#line 6512
  Extension->ParentDeviceObject = parentDevice;
#line 6513
  tmp = IoGetConfigurationInformation();
#line 6514
  tmp->ParallelCount += 1UL;
#line 6515
  pDeviceObject->Flags &= 4294967167UL;
  }
#line 6519
  return (0L);
}
}
#line 6522 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  NTSTATUS status ;
  PIO_STACK_LOCATION irpStack ;
  UCHAR minorFunction ;

  {
  {
#line 6530
  PptDebugDumpPnpIrpInfo(DeviceObject, Irp);
#line 6531
  status = PptAcquireRemoveLockOrFailIrp(DeviceObject, Irp);
  }
#line 6533
  if (status >= 0L) {
#line 6534
    irpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6535
    minorFunction = irpStack->MinorFunction;
#line 6536
    if ((int )minorFunction > 24) {
      {
#line 6538
      status = PptPnpUnhandledIrp(DeviceObject, Irp);
      }
    } else {
#line 6541
      if (__BLAST_NONDET == 0) {
        goto switch_214_0;
      } else {
#line 6544
        if (__BLAST_NONDET == 1) {
          goto switch_214_1;
        } else {
#line 6547
          if (__BLAST_NONDET == 2) {
            goto switch_214_2;
          } else {
#line 6550
            if (__BLAST_NONDET == 3) {
              goto switch_214_3;
            } else {
#line 6553
              if (__BLAST_NONDET == 4) {
                goto switch_214_4;
              } else {
#line 6556
                if (__BLAST_NONDET == 5) {
                  goto switch_214_5;
                } else {
#line 6559
                  if (__BLAST_NONDET == 6) {
                    goto switch_214_6;
                  } else {
#line 6562
                    if (__BLAST_NONDET == 7) {
                      goto switch_214_7;
                    } else {
#line 6565
                      if (__BLAST_NONDET == 8) {
                        goto switch_214_8;
                      } else {
#line 6568
                        if (__BLAST_NONDET == 9) {
                          goto switch_214_9;
                        } else {
                          goto switch_214_default;
#line 6573
                          if (0) {
                            switch_214_0: 
                            {
#line 6576
                            status = PptPnpUnhandledIrp(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_1: 
                            {
#line 6581
                            status = PptPnpStartDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_2: 
                            {
#line 6586
                            status = PptPnpFilterResourceRequirements(DeviceObject,
                                                                      Irp);
                            }
                            goto switch_214_break;
                            switch_214_3: 
                            {
#line 6592
                            status = PptPnpQueryDeviceRelations(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_4: 
                            {
#line 6597
                            status = PptPnpQueryStopDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_5: 
                            {
#line 6602
                            status = PptPnpCancelStopDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_6: 
                            {
#line 6607
                            status = PptPnpStopDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_7: 
                            {
#line 6612
                            status = PptPnpQueryRemoveDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_8: 
                            {
#line 6617
                            status = PptPnpCancelRemoveDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_9: 
                            {
#line 6622
                            status = PptPnpRemoveDevice(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                            switch_214_default: 
                            {
#line 6627
                            status = PptPnpSurpriseRemoval(DeviceObject, Irp);
                            }
                            goto switch_214_break;
                          } else {
                            switch_214_break: ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  } else {

  }
#line 6648
  return (status);
}
}
#line 6651 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS status ;
  BOOLEAN foundPort ;
  BOOLEAN foundIrq ;
  BOOLEAN foundDma ;

  {
  {
#line 6660
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6661
  foundPort = (unsigned char)0;
#line 6662
  foundIrq = (unsigned char)0;
#line 6663
  foundDma = (unsigned char)0;
#line 6664
  status = PptPnpBounceAndCatchPnpIrp(extension, Irp);
  }
#line 6666
  if (! (status >= 0L)) {
#line 6667
    if (status != -1073741637L) {
      goto targetExit;
    } else {

    }
  } else {

  }
  {
#line 6676
  status = PptPnpStartScanCmResourceList(extension, Irp, & foundPort, & foundIrq,
                                         & foundDma);
  }
#line 6679
  if (! (status >= 0L)) {
    goto targetExit;
  } else {

  }
  {
#line 6685
  status = PptPnpStartValidateResources(DeviceObject, foundPort, foundIrq, foundDma);
  }
#line 6687
  if (! (status >= 0L)) {
    goto targetExit;
  } else {

  }
  {
#line 6693
  extension->PnpInfo.Ieee1284_3DeviceCount = PptInitiate1284_3((void *)extension);
#line 6694
  status = PptDetectChipFilter(extension);
  }
#line 6696
  if (! (status >= 0L)) {
    {
#line 6698
    PptDetectPortType(extension);
    }
  } else {

  }
  {
#line 6704
  status = PptWmiInitWmi(DeviceObject);
  }
#line 6706
  if (! (status >= 0L)) {
    goto targetExit;
  } else {

  }
  {
#line 6712
  status = IoSetDeviceInterfaceState(& extension->SymbolicLinkName, (unsigned char)1);
  }
#line 6714
  if (! (status >= 0L)) {
#line 6715
    status = -1073741637L;
  } else {

  }
  targetExit: 
#line 6720
  if (status >= 0L) {
#line 6723
    extension->DeviceStateFlags |= 1UL;
  } else {

  }
  {
#line 6730
  Irp->IoStatus.__annonCompField4.Status = status;
#line 6731
  myStatus = (int )status;
#line 6732
  Irp->IoStatus.Information = 0UL;
#line 6733
  PptCompleteRequest(Irp, (char)0);
#line 6734
  PptReleaseRemoveLock(& extension->RemoveLock, (void *)Irp);
  }
#line 6736
  return (status);
}
}
#line 6739 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpStartScanCmResourceList(PDEVICE_EXTENSION Extension , PIRP Irp , PBOOLEAN FoundPort ,
                                       PBOOLEAN FoundIrq , PBOOLEAN FoundDma ) 
{ NTSTATUS status ;
  PIO_STACK_LOCATION irpStack ;
  PCM_RESOURCE_LIST ResourceList ;
  PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor ;
  PCM_PARTIAL_RESOURCE_LIST PartialResourceList ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor ;
  ULONG i ;
  PHYSICAL_ADDRESS start ;
  ULONG length ;
  BOOLEAN isPci ;
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;
  BOOLEAN tmp___1 ;

  {
#line 6756
  status = 0L;
#line 6757
  irpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6758
  isPci = (unsigned char)0;
#line 6759
  *FoundPort = (unsigned char)0;
#line 6760
  *FoundIrq = (unsigned char)0;
#line 6761
  *FoundDma = (unsigned char)0;
#line 6762
  ResourceList = irpStack->Parameters.StartDevice.AllocatedResourcesTranslated;
#line 6763
  if ((unsigned int )ResourceList == (unsigned int )((void *)0)) {
#line 6766
    status = -1073741670L;
    goto targetExit;
  } else {

  }
#line 6771
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture != 1) {
    {
#line 6773
    tmp = PptIsPci(Extension, Irp);
    }
#line 6775
    if (1 == (int )tmp) {
      {
#line 6779
      status = PptPnpStartScanPciCardCmResourceList(Extension, Irp, FoundPort, FoundIrq,
                                                    FoundDma);
#line 6781
      isPci = (unsigned char)1;
      }
      goto targetExit;
    } else {

    }
  } else {

  }
#line 6790
  FullResourceDescriptor = & ResourceList->List[0];
#line 6791
  if (FullResourceDescriptor) {
#line 6792
    Extension->InterfaceType = FullResourceDescriptor->InterfaceType;
#line 6793
    PartialResourceList = & FullResourceDescriptor->PartialResourceList;
#line 6794
    i = 0UL;
    {
#line 6796
    while (1) {
      while_22_continue: /* CIL Label */ ;

#line 6798
      if (i < PartialResourceList->Count) {

      } else {
        goto while_217_break;
      }
#line 6803
      PartialResourceDescriptor = & PartialResourceList->PartialDescriptors[i];
#line 6804
      if ((int )PartialResourceDescriptor->Type == 1) {
        goto switch_218_1;
      } else {
#line 6807
        if ((int )PartialResourceDescriptor->Type == 6) {
          goto switch_218_6;
        } else {
#line 6810
          if ((int )PartialResourceDescriptor->Type == 2) {
            goto switch_218_2;
          } else {
#line 6813
            if ((int )PartialResourceDescriptor->Type == 4) {
              goto switch_218_4;
            } else {
              goto switch_218_default;
#line 6818
              if (0) {
                switch_218_1: 
#line 6820
                start = PartialResourceDescriptor->u.Port.Start;
#line 6821
                length = PartialResourceDescriptor->u.Port.Length;
#line 6824
                *FoundPort = (unsigned char)1;
#line 6825
                if (Extension->PortInfo.OriginalController.__annonCompField1.LowPart == 0UL) {
#line 6826
                  if (Extension->PortInfo.OriginalController.__annonCompField1.HighPart == 0L) {
#line 6829
                    Extension->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
#line 6830
                    Extension->PortInfo.SpanOfController = PartialResourceDescriptor->u.Port.Length;
#line 6831
                    Extension->PortInfo.Controller = (UCHAR *)((unsigned long )Extension->PortInfo.OriginalController.QuadPart);
#line 6832
                    Extension->AddressSpace = (unsigned long )PartialResourceDescriptor->Flags;
#line 6833
                    if (Extension->PortInfo.SpanOfController == 4096UL) {
                      {
#line 6835
                      tmp___0 = PptIsNecR98Machine();
                      }
#line 6837
                      if (tmp___0) {
#line 6838
                        Extension->PortInfo.SpanOfController = 8UL;
                      } else {

                      }
                    } else {

                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
#line 6850
                  if (Extension->PnpInfo.OriginalEcpController.__annonCompField1.LowPart == 0UL) {
#line 6851
                    if (Extension->PnpInfo.OriginalEcpController.__annonCompField1.HighPart == 0L) {
#line 6852
                      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture != 1) {
#line 6853
                        if (PartialResourceDescriptor->u.Port.Start.__annonCompField1.LowPart < Extension->PortInfo.OriginalController.__annonCompField1.LowPart) {
#line 6854
                          if (PartialResourceDescriptor->u.Port.Start.__annonCompField1.HighPart < Extension->PortInfo.OriginalController.__annonCompField1.HighPart) {
#line 6857
                            Extension->PnpInfo.OriginalEcpController = Extension->PortInfo.OriginalController;
#line 6858
                            Extension->PnpInfo.SpanOfEcpController = Extension->PortInfo.SpanOfController;
#line 6859
                            Extension->PnpInfo.EcpController = Extension->PortInfo.Controller;
#line 6860
                            Extension->EcpAddressSpace = Extension->AddressSpace;
#line 6861
                            Extension->PortInfo.OriginalController = PartialResourceDescriptor->u.Port.Start;
#line 6862
                            Extension->PortInfo.SpanOfController = PartialResourceDescriptor->u.Port.Length;
#line 6863
                            Extension->PortInfo.Controller = (UCHAR *)((unsigned long )Extension->PortInfo.OriginalController.QuadPart);
#line 6864
                            Extension->AddressSpace = (unsigned long )PartialResourceDescriptor->Flags;
#line 6865
                            if (Extension->PortInfo.SpanOfController == 4096UL) {
                              {
#line 6867
                              tmp___1 = PptIsNecR98Machine();
                              }
#line 6869
                              if (tmp___1) {
#line 6870
                                Extension->PortInfo.SpanOfController = 8UL;
                              } else {

                              }
                            } else {

                            }
                          } else {
                            goto _L;
                          }
                        } else {
                          _L: 
#line 6884
                          Extension->PnpInfo.OriginalEcpController = PartialResourceDescriptor->u.Port.Start;
#line 6885
                          Extension->PnpInfo.SpanOfEcpController = PartialResourceDescriptor->u.Port.Length;
#line 6886
                          Extension->PnpInfo.EcpController = (UCHAR *)((unsigned long )Extension->PnpInfo.OriginalEcpController.QuadPart);
#line 6887
                          Extension->EcpAddressSpace = (unsigned long )PartialResourceDescriptor->Flags;
                        }
                      } else {

                      }
                    } else {

                    }
                  } else {

                  }
                }
                goto switch_218_break;
                switch_218_6: 
#line 6901
                Extension->BusNumber = PartialResourceDescriptor->u.BusNumber.Start;
                goto switch_218_break;
                switch_218_2: 
#line 6904
                *FoundIrq = (unsigned char)1;
#line 6905
                Extension->FoundInterrupt = (unsigned char)1;
#line 6906
                Extension->InterruptLevel = (unsigned char )PartialResourceDescriptor->u.Interrupt.Level;
#line 6907
                Extension->InterruptVector = PartialResourceDescriptor->u.Interrupt.Vector;
#line 6908
                Extension->InterruptAffinity = PartialResourceDescriptor->u.Interrupt.Affinity;
#line 6909
                if ((int )PartialResourceDescriptor->Flags & 1) {
#line 6910
                  Extension->InterruptMode = (enum _KINTERRUPT_MODE )1;
                } else {
#line 6912
                  Extension->InterruptMode = (enum _KINTERRUPT_MODE )0;
                }
                goto switch_218_break;
                switch_218_4: 
#line 6916
                *FoundDma = (unsigned char)1;
#line 6917
                Extension->DmaChannel = PartialResourceDescriptor->u.Dma.Channel;
#line 6918
                Extension->DmaPort = PartialResourceDescriptor->u.Dma.Port;
#line 6919
                Extension->DmaWidth = PartialResourceDescriptor->Flags;
                goto switch_218_break;
                switch_218_default: ;
                goto switch_218_break;
              } else {
                switch_218_break: ;
              }
            }
          }
        }
      }
#line 6931
      i += 1UL;
    }
    while_22_break: /* CIL Label */ ;
    }
    while_217_break: ;
  } else {

  }
  targetExit: 
#line 6939
  if (0 == (int )isPci) {

  } else {

  }
#line 6951
  return (status);
}
}
#line 6954 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpStartValidateResources(PDEVICE_OBJECT DeviceObject , BOOLEAN FoundPort ,
                                      BOOLEAN FoundIrq , BOOLEAN FoundDma ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS status ;

  {
#line 6960
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6961
  status = 0L;
#line 6962
  if (! FoundPort) {
#line 6963
    status = -1073741810L;
  } else {
#line 6965
    extension->PortInfo.Controller = (UCHAR *)((unsigned long )extension->PortInfo.OriginalController.QuadPart);
#line 6966
    if (! extension->PortInfo.Controller) {
      {
#line 6968
      PptLogError(DeviceObject->DriverObject, DeviceObject, extension->PortInfo.OriginalController,
                  (union _LARGE_INTEGER )PhysicalZero, 0UL, (unsigned char)0, (unsigned char)0,
                  10UL, 0L, 4L);
#line 6970
      status = -1073741709L;
      }
    } else {

    }
  }
#line 6976
  return (status);
}
}
#line 6979 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpFilterResourceRequirements(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  ULONG filterResourceMethod ;
  PIO_RESOURCE_REQUIREMENTS_LIST pResourceRequirementsIn ;
  NTSTATUS status ;
  PIO_STACK_LOCATION IrpStack ;
  BOOLEAN tmp ;
  BOOLEAN tmp___0 ;

  {
  {
#line 6990
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6991
  filterResourceMethod = 1UL;
#line 6992
  status = PptPnpBounceAndCatchPnpIrp(extension, Irp);
  }
#line 6994
  if (! (status >= 0L)) {
#line 6995
    if (status != -1073741637L) {
      goto targetExit;
    } else {

    }
  } else {

  }
#line 7003
  if (Irp->IoStatus.Information == 0UL) {
#line 7004
    IrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7005
    pResourceRequirementsIn = IrpStack->Parameters.FilterResourceRequirements.IoResourceRequirementList;
#line 7006
    if ((unsigned int )pResourceRequirementsIn == (unsigned int )((void *)0)) {
      goto targetExit;
    } else {

    }
  } else {
#line 7012
    pResourceRequirementsIn = (struct _IO_RESOURCE_REQUIREMENTS_LIST *)Irp->IoStatus.Information;
  }
  {
#line 7019
  PptDebugDumpResourceRequirementsList(pResourceRequirementsIn);
  }
#line 7021
  if (filterResourceMethod == 1UL) {
    goto switch_229_1;
  } else {
#line 7024
    if (filterResourceMethod == 0UL) {
      goto switch_229_0;
    } else {
#line 7027
      if (filterResourceMethod == 2UL) {
        goto switch_229_2;
      } else {
        goto switch_229_default;
#line 7032
        if (0) {
          switch_229_1: 
          {
#line 7037
          tmp = PptPnpFilterExistsNonIrqResourceList(pResourceRequirementsIn);
          }
#line 7039
          if (tmp) {
            {
#line 7043
            PptPnpFilterRemoveIrqResourceLists(pResourceRequirementsIn);
            }
          } else {
            {
#line 7049
            PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(pResourceRequirementsIn);
            }
          }
          {
#line 7055
          PptDebugDumpResourceRequirementsList(pResourceRequirementsIn);
          }
          goto switch_229_break;
          switch_229_0: 
          {
#line 7062
          tmp___0 = PptPnpFilterExistsNonIrqResourceList(pResourceRequirementsIn);
          }
#line 7064
          if (tmp___0) {
            {
#line 7068
            PptPnpFilterRemoveIrqResourceLists(pResourceRequirementsIn);
#line 7073
            PptDebugDumpResourceRequirementsList(pResourceRequirementsIn);
            }
          } else {

          }
          goto switch_229_break;
          switch_229_2: ;
          goto switch_229_break;
          switch_229_default: ;
        } else {
          switch_229_break: ;
        }
      }
    }
  }
  targetExit: 
  {
#line 7096
  Irp->IoStatus.__annonCompField4.Status = status;
#line 7097
  myStatus = (int )status;
#line 7098
  PptCompleteRequest(Irp, (char)0);
#line 7099
  PptReleaseRemoveLock(& extension->RemoveLock, (void *)Irp);
  }
#line 7101
  return (status);
}
}
#line 7104 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptPnpFilterExistsNonIrqResourceList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) 
{ ULONG listCount ;
  PIO_RESOURCE_LIST curList ;
  ULONG i ;
  ULONG remain ;
  PIO_RESOURCE_DESCRIPTOR curDesc ;
  BOOLEAN foundIrq ;

  {
#line 7113
  listCount = ResourceRequirementsList->AlternativeLists;
#line 7116
  i = 0UL;
#line 7117
  curList = ResourceRequirementsList->List;
  {
#line 7119
  while (1) {
    while_23_continue: /* CIL Label */ ;

#line 7121
    if (i < listCount) {

    } else {
      goto while_241_break;
    }
#line 7128
    remain = curList->Count;
#line 7129
    curDesc = curList->Descriptors;
#line 7130
    foundIrq = (unsigned char)0;
    {
#line 7132
    while (1) {
      while_24_continue: /* CIL Label */ ;

#line 7134
      if (remain) {

      } else {
        goto while_243_break;
      }
#line 7141
      if ((int )curDesc->Type == 2) {
#line 7144
        foundIrq = (unsigned char)1;
        goto while_243_break;
      } else {

      }
#line 7149
      curDesc += 1;
#line 7150
      remain -= 1UL;
    }
    while_24_break: /* CIL Label */ ;
    }
    while_243_break: ;
#line 7154
    if ((int )foundIrq == 0) {
#line 7157
      return ((unsigned char)1);
    } else {

    }
#line 7161
    curList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 7162
    i += 1UL;
  }
  while_23_break: /* CIL Label */ ;
  }
  while_241_break: ;
#line 7168
  return ((unsigned char)0);
}
}
#line 7171 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptPnpFilterRemoveIrqResourceLists(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) 
{ ULONG listCount ;
  PIO_RESOURCE_LIST curList ;
  PIO_RESOURCE_LIST nextList ;
  ULONG i ;
  PCHAR currentEndOfResourceRequirementsList ;
  LONG bytesToMove ;
  PVOID tmp ;
  BOOLEAN tmp___0 ;

  {
  {
#line 7182
  listCount = ResourceRequirementsList->AlternativeLists;
#line 7186
  tmp = PptPnpFilterGetEndOfResourceRequirementsList(ResourceRequirementsList);
#line 7187
  currentEndOfResourceRequirementsList = (CHAR *)tmp;
#line 7188
  i = 0UL;
#line 7189
  curList = ResourceRequirementsList->List;
  }
  {
#line 7192
  while (1) {
    while_25_continue: /* CIL Label */ ;

#line 7194
    if (i < listCount) {

    } else {
      goto while_249_break;
    }
    {
#line 7204
    tmp___0 = PptPnpListContainsIrqResourceDescriptor(curList);
    }
#line 7206
    if (tmp___0) {
#line 7209
      nextList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 7210
      bytesToMove = (long )(currentEndOfResourceRequirementsList - (CHAR *)nextList);
#line 7211
      if (bytesToMove > 0L) {
        {
#line 7213
        memmove((void *)curList, (void const   *)nextList, (unsigned int )bytesToMove);
#line 7214
        currentEndOfResourceRequirementsList -= (CHAR *)nextList - (CHAR *)curList;
        }
      } else {

      }
#line 7219
      listCount -= 1UL;
    } else {
#line 7223
      curList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 7224
      i += 1UL;
    }
  }
  while_25_break: /* CIL Label */ ;
  }
  while_249_break: 
#line 7229
  ResourceRequirementsList->AlternativeLists = listCount;
#line 7232
  return;
}
}
#line 7235 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID PptPnpFilterGetEndOfResourceRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) 
{ ULONG listCount ;
  PIO_RESOURCE_LIST curList ;
  ULONG i ;

  {
#line 7241
  listCount = ResourceRequirementsList->AlternativeLists;
#line 7242
  i = 0UL;
#line 7243
  curList = ResourceRequirementsList->List;
  {
#line 7245
  while (1) {
    while_26_continue: /* CIL Label */ ;

#line 7247
    if (i < listCount) {

    } else {
      goto while_255_break;
    }
#line 7252
    curList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 7253
    i += 1UL;
  }
  while_26_break: /* CIL Label */ ;
  }
  while_255_break: ;
#line 7257
  return ((void *)curList);
}
}
#line 7260 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptPnpFilterNukeIrqResourceDescriptorsFromAllLists(PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList ) 
{ ULONG listCount ;
  ULONG i ;
  PIO_RESOURCE_LIST curList ;

  {
#line 7266
  listCount = ResourceRequirementsList->AlternativeLists;
#line 7267
  i = 0UL;
#line 7268
  curList = ResourceRequirementsList->List;
  {
#line 7272
  while (1) {
    while_27_continue: /* CIL Label */ ;

#line 7274
    if (i < listCount) {

    } else {
      goto while_257_break;
    }
    {
#line 7282
    PptPnpFilterNukeIrqResourceDescriptors(curList);
#line 7283
    curList = (struct _IO_RESOURCE_LIST *)(curList->Descriptors + curList->Count);
#line 7284
    i += 1UL;
    }
  }
  while_27_break: /* CIL Label */ ;
  }
  while_257_break: ;
#line 7289
  return;
}
}
#line 7292 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptPnpFilterNukeIrqResourceDescriptors(PIO_RESOURCE_LIST IoResourceList ) 
{ PIO_RESOURCE_DESCRIPTOR pIoResourceDescriptorIn ;
  ULONG i ;

  {
#line 7297
  pIoResourceDescriptorIn = IoResourceList->Descriptors;
#line 7298
  i = 0UL;
  {
#line 7300
  while (1) {
    while_28_continue: /* CIL Label */ ;

#line 7302
    if (i < IoResourceList->Count) {

    } else {
      goto while_259_break;
    }
#line 7307
    if ((int )pIoResourceDescriptorIn->Type == 2) {
#line 7308
      pIoResourceDescriptorIn->Type = (unsigned char)0;
    } else {

    }
#line 7314
    pIoResourceDescriptorIn += 1;
#line 7315
    i += 1UL;
  }
  while_28_break: /* CIL Label */ ;
  }
  while_259_break: ;
#line 7319
  return;
}
}
#line 7322 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpQueryDeviceRelations(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  PIO_STACK_LOCATION irpSp ;
  DEVICE_RELATION_TYPE type ;
  PDEVICE_RELATIONS removalRelations ;
  NTSTATUS tmp ;

  {
#line 7330
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7331
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7332
  type = irpSp->Parameters.QueryDeviceRelations.Type;
#line 7333
  if ((int )type == 3) {
    goto switch_261_3;
  } else {
#line 7336
    if ((int )type == 0) {
      goto switch_261_0;
    } else {
#line 7339
      if ((int )type == 1) {
        goto switch_261_1;
      } else {
#line 7342
        if ((int )type == 2) {
          goto switch_261_2;
        } else {
#line 7345
          if ((int )type == 4) {
            goto switch_261_4;
          } else {
            goto switch_261_default;
#line 7350
            if (0) {
              switch_261_3: 
              {
#line 7355
              PptDumpRemovalRelationsList(extension);
              }
#line 7357
              if (Irp->IoStatus.Information) {

              } else {
                {
#line 7362
                removalRelations = PptPnpBuildRemovalRelations(extension);
                }
#line 7364
                if (removalRelations) {
#line 7367
                  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7368
                  myStatus = 0;
#line 7369
                  Irp->IoStatus.Information = (unsigned long )removalRelations;
                } else {

                }
              }
              goto switch_261_break;
              switch_261_0: ;
              goto switch_261_break;
              switch_261_1: ;
              goto switch_261_break;
              switch_261_2: ;
              goto switch_261_break;
              switch_261_4: ;
              goto switch_261_break;
              switch_261_default: ;
              goto switch_261_break;
            } else {
              switch_261_break: ;
            }
          }
        }
      }
    }
  }
  {
#line 7406
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock((struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension,
                                                    Irp);
  }
#line 7409
  return (tmp);
}
}
#line 7412 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpQueryStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS status ;
  PDEVICE_EXTENSION extension ;
  LONG handlesOpen ;

  {
#line 7419
  status = 0L;
#line 7420
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7422
  handlesOpen = extension->OpenCloseRefCount;
#line 7425
  if (handlesOpen > 0L) {
    {
#line 7427
    status = -2147483631L;
#line 7428
    PptFailRequest(Irp, status);
#line 7429
    PptReleaseRemoveLock(& extension->RemoveLock, (void *)Irp);
    }
  } else {
    {
#line 7433
    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7434
    myStatus = 0;
#line 7435
    status = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
#line 7437
    extension->DeviceStateFlags |= 65552UL;
    }
  }
#line 7441
  return (status);
}
}
#line 7444 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpCancelStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS tmp ;

  {
#line 7450
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7453
  if (extension->DeviceStateFlags & 16UL) {
#line 7454
    extension->DeviceStateFlags &= 4294901743UL;
  } else {

  }
  {
#line 7460
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7461
  myStatus = 0;
#line 7462
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
  }
#line 7464
  return (tmp);
}
}
#line 7467 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpStopDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS tmp ;

  {
  {
#line 7473
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7475
  extension->DeviceStateFlags |= 32UL;
#line 7476
  extension->DeviceStateFlags &= 4294967278UL;
#line 7478
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7479
  myStatus = 0;
#line 7480
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
  }
#line 7482
  return (tmp);
}
}
#line 7485 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpQueryRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS tmp ;

  {
  {
#line 7490
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7495
  extension->DeviceStateFlags |= 65792UL;
#line 7497
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7498
  myStatus = 0;
#line 7499
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
  }
#line 7501
  return (tmp);
}
}
#line 7504 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpCancelRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS tmp ;

  {
#line 7510
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7513
  if (extension->DeviceStateFlags & 256UL) {
#line 7514
    extension->DeviceStateFlags &= 4294901503UL;
  } else {

  }
  {
#line 7520
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7521
  myStatus = 0;
#line 7522
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
  }
#line 7524
  return (tmp);
}
}
#line 7527 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpRemoveDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  NTSTATUS status ;

  {
  {
#line 7533
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7535
  extension->DeviceStateFlags |= 512UL;
#line 7537
  IoWMIRegistrationControl(DeviceObject, 2UL);
#line 7538
  IoSetDeviceInterfaceState(& extension->SymbolicLinkName, (unsigned char)0);
#line 7539
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7540
  myStatus = 0;
  }
#line 7542
  if (s == NP) {
#line 7543
    s = SKIP1;
  } else {
    {
#line 7546
    errorFn();
    }
  }
  {
#line 7550
  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 7551
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 7552
  status = IofCallDriver(extension->ParentDeviceObject, Irp);
#line 7553
  PptReleaseRemoveLockAndWait(& extension->RemoveLock, (void *)Irp);
#line 7554
  PptCleanRemovalRelationsList(extension);
  }
#line 7558
  if (extension->PnpInfo.PortName) {
#line 7561
    extension->PnpInfo.PortName = (WCHAR *)((void *)0);
  } else {

  }
#line 7570
  return (status);
}
}
#line 7573 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpSurpriseRemoval(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  KIRQL cancelIrql ;
  NTSTATUS tmp ;

  {
  {
#line 7580
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7582
  extension->DeviceStateFlags |= 4096UL;
#line 7584
  IoAcquireCancelSpinLock(& cancelIrql);
#line 7586
  IoSetDeviceInterfaceState(& extension->SymbolicLinkName, (unsigned char)0);
#line 7587
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 7588
  myStatus = 0;
#line 7589
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock(extension, Irp);
  }
#line 7591
  return (tmp);
}
}
#line 7594 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptPnpListContainsIrqResourceDescriptor(PIO_RESOURCE_LIST List ) 
{ ULONG i ;
  PIO_RESOURCE_DESCRIPTOR curDesc ;

  {
#line 7599
  curDesc = List->Descriptors;
#line 7600
  i = 0UL;
  {
#line 7602
  while (1) {
    while_29_continue: /* CIL Label */ ;

#line 7604
    if (i < List->Count) {

    } else {
      goto while_272_break;
    }
#line 7609
    if ((int )curDesc->Type == 2) {
#line 7610
      return ((unsigned char)1);
    } else {
#line 7612
      curDesc += 1;
    }
#line 7614
    i += 1UL;
  }
  while_29_break: /* CIL Label */ ;
  }
  while_272_break: ;
#line 7618
  return ((unsigned char)0);
}
}
#line 7621 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpBounceAndCatchPnpIrp(PDEVICE_EXTENSION Extension , PIRP Irp ) 
{ NTSTATUS status ;
  KEVENT event ;
  PDEVICE_OBJECT parentDevObj ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___0 ;

  {
  {
#line 7630
  parentDevObj = Extension->ParentDeviceObject;
#line 7635
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7636
  nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7637
  memcpy((void *)nextIrpSp, (void const   *)irpSp, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 7638
  nextIrpSp->Control = (unsigned char)0;
  }
#line 7640
  if (s != NP) {
    {
#line 7642
    errorFn();
    }
  } else {
#line 7645
    if (compRegistered != 0) {
      {
#line 7647
      errorFn();
      }
    } else {
#line 7650
      compRegistered = 1;
#line 7651
      compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))(& PptSynchCompletionRoutine);
#line 7652
      routine = 0;
    }
  }
  {
#line 7656
  irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7657
  irpSp___0->CompletionRoutine = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                               PVOID Context ))(& PptSynchCompletionRoutine);
#line 7658
  irpSp___0->Context = (void *)(& event);
#line 7659
  irpSp___0->Control = (unsigned char)0;
#line 7660
  irpSp___0->Control = (unsigned char)64;
#line 7661
  irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 128);
#line 7662
  irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 32);
#line 7663
  status = IofCallDriver(parentDevObj, Irp);
#line 7664
  KeWaitForSingleObject((void *)(& event), (enum _KWAIT_REASON )5, (char)0, (unsigned char)0,
                        (LARGE_INTEGER *)((void *)0));
  }
#line 7666
  if (status == 259L) {
#line 7667
    status = (long )myStatus;
  } else {

  }
#line 7671
  return (status);
}
}
#line 7674 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpPassThroughPnpIrpAndReleaseRemoveLock(PDEVICE_EXTENSION Extension ,
                                                     PIRP Irp ) 
{ NTSTATUS status ;

  {
#line 7679
  if (s == NP) {
#line 7680
    s = SKIP1;
  } else {
    {
#line 7683
    errorFn();
    }
  }
  {
#line 7687
  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 7688
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 7689
  status = IofCallDriver(Extension->ParentDeviceObject, Irp);
#line 7690
  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
  }
#line 7692
  return (status);
}
}
#line 7695 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPnpUnhandledIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS tmp ;

  {
  {
#line 7700
  tmp = PptPnpPassThroughPnpIrpAndReleaseRemoveLock((struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension,
                                                    Irp);
  }
#line 7703
  return (tmp);
}
}
#line 7710
#pragma warning(push)
#line 7711
#pragma warning(disable:4035)
#line 7712
#pragma warning(pop)
#line 7714
#pragma warning(disable:4103)
#line 7715
#pragma warning(disable:4103)
#line 7716
#pragma warning(push)
#line 7717
#pragma warning(disable:4035)
#line 7718
#pragma warning(pop)
#line 7719
#pragma warning(disable:4035)
#line 7720
#pragma warning(push)
#line 7721
#pragma warning(disable:4164)
#line 7722
#pragma function(_enable)
#line 7723
#pragma function(_disable)
#line 7724
#pragma warning(pop)
#line 7725
#pragma warning(disable:4103)
#line 7726
#pragma warning(disable:4103)
#line 7727
#pragma warning(disable:4103)
#line 7728
#pragma warning(disable:4103)
#line 7729
#pragma warning(disable:4103)
#line 7730
#pragma warning(disable:4103)
#line 7731
#pragma warning(disable:4200)
#line 7732
#pragma warning(default:4200)
#line 7734 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptPowerComplete(PDEVICE_OBJECT pDeviceObject , PIRP pIrp , PDEVICE_EXTENSION Extension ) 
{ POWER_STATE_TYPE powerType ;
  POWER_STATE powerState ;
  PIO_STACK_LOCATION pIrpStack ;

  {
#line 7740
  pIrpStack = pIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7741
  powerType = pIrpStack->Parameters.Power.Type;
#line 7742
  powerState = pIrpStack->Parameters.Power.State;
#line 7743
  if ((int )pIrpStack->MinorFunction == 3) {
    goto switch_274_3;
  } else {
#line 7746
    if ((int )pIrpStack->MinorFunction == 2) {
      goto switch_274_2;
    } else {
      goto switch_274_default;
#line 7751
      if (0) {
        switch_274_3: ;
        goto switch_274_break;
        switch_274_2: ;
#line 7757
        if ((int )powerType == 1) {
          goto switch_276_1;
        } else {
#line 7760
          if ((int )powerType == 0) {
            goto switch_276_0;
          } else {
#line 7763
            if (0) {
              switch_276_1: ;
#line 7765
              if ((int )Extension->DeviceState < (int )powerState.DeviceState) {

              } else {
#line 7768
                if ((int )powerState.DeviceState < (int )Extension->DeviceState) {
                  {
#line 7770
                  PoSetPowerState(Extension->DeviceObject, powerType, powerState);
                  }
#line 7772
                  if (1 == (int )Extension->DeviceState) {

                  } else {

                  }
#line 7777
                  Extension->DeviceState = powerState.DeviceState;
                } else {

                }
              }
              goto switch_276_break;
              switch_276_0: ;
#line 7784
              if ((int )Extension->SystemState < (int )powerState.SystemState) {

              } else {
#line 7787
                if ((int )powerState.SystemState < (int )Extension->SystemState) {
#line 7788
                  if (1 == (int )powerState.SystemState) {
                    {
#line 7790
                    powerState.DeviceState = (enum _DEVICE_POWER_STATE )1;
#line 7791
                    PoRequestPowerIrp(Extension->DeviceObject, (unsigned char)2, powerState,
                                      (void (*)(PDEVICE_OBJECT DeviceObject , UCHAR MinorFunction ,
                                                POWER_STATE PowerState , PVOID Context ,
                                                PIO_STATUS_BLOCK IoStatus ))((void *)0),
                                      (void *)0, (PIRP *)((void *)0));
                    }
                  } else {

                  }
#line 7797
                  Extension->SystemState = powerState.SystemState;
                } else {

                }
              }
              goto switch_276_break;
            } else {
              switch_276_break: ;
            }
          }
        }
        goto switch_274_break;
        switch_274_default: ;
      } else {
        switch_274_break: ;
      }
    }
  }
#line 7819
  return (0L);
}
}
#line 7822 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void InitNEC_98(PDEVICE_EXTENSION Extension ) 
{ PUCHAR Controller ;

  {
  {
#line 7827
  Controller = Extension->PortInfo.Controller;
#line 7828
  WRITE_PORT_UCHAR(Controller + 9, (unsigned char)16);
#line 7829
  WRITE_PORT_UCHAR(Controller + 14, (unsigned char)0);
#line 7830
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)4);
  }
#line 7832
  return;
}
}
#line 7835 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchPower(PDEVICE_OBJECT pDeviceObject , PIRP pIrp ) 
{ POWER_STATE_TYPE powerType ;
  POWER_STATE powerState ;
  PIO_STACK_LOCATION pIrpStack ;
  NTSTATUS status ;
  PDEVICE_EXTENSION Extension ;
  BOOLEAN hookit ;
  NTSTATUS status___0 ;
  NTSTATUS tmp ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___0 ;

  {
  {
#line 7850
  status = 0L;
#line 7851
  hookit = (unsigned char)0;
#line 7852
  Extension = (struct _DEVICE_EXTENSION *)pDeviceObject->DeviceExtension;
#line 7853
  pIrpStack = pIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7854
  tmp = PptAcquireRemoveLock(& Extension->RemoveLock, (void *)pIrp);
#line 7855
  status___0 = tmp;
  }
#line 7857
  if (! (status___0 >= 0L)) {
    {
#line 7860
    pIrp->IoStatus.__annonCompField4.Status = status___0;
#line 7861
    PptCompleteRequest(pIrp, (char)0);
    }
#line 7863
    return (status___0);
  } else {

  }
#line 7867
  powerType = pIrpStack->Parameters.Power.Type;
#line 7868
  powerState = pIrpStack->Parameters.Power.State;
#line 7869
  if ((int )pIrpStack->MinorFunction == 3) {
    goto switch_277_3;
  } else {
#line 7872
    if ((int )pIrpStack->MinorFunction == 2) {
      goto switch_277_2;
    } else {
      goto switch_277_default;
#line 7877
      if (0) {
        switch_277_3: 
#line 7879
        status = 0L;
        goto switch_277_break;
        switch_277_2: ;
#line 7884
        if ((int )powerType == 1) {
          goto switch_279_1;
        } else {
#line 7887
          if ((int )powerType == 0) {
            goto switch_279_0;
          } else {
#line 7890
            if (0) {
              switch_279_1: ;
#line 7892
              if ((int )Extension->DeviceState < (int )powerState.DeviceState) {
                {
#line 7894
                PoSetPowerState(Extension->DeviceObject, powerType, powerState);
                }
#line 7896
                if (1 == (int )Extension->DeviceState) {

                } else {

                }
#line 7901
                Extension->DeviceState = powerState.DeviceState;
              } else {
#line 7903
                if ((int )powerState.DeviceState < (int )Extension->DeviceState) {
#line 7904
                  hookit = (unsigned char)1;
#line 7905
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                    {
#line 7907
                    InitNEC_98(Extension);
                    }
                  } else {

                  }
                } else {

                }
              }
              goto switch_279_break;
              switch_279_0: ;
#line 7918
              if ((int )Extension->SystemState < (int )powerState.SystemState) {
#line 7919
                if (1 == (int )Extension->SystemState) {

                } else {

                }
                {
#line 7925
                powerState.DeviceState = (enum _DEVICE_POWER_STATE )4;
#line 7926
                PoRequestPowerIrp(Extension->DeviceObject, (unsigned char)2, powerState,
                                  (void (*)(PDEVICE_OBJECT DeviceObject , UCHAR MinorFunction ,
                                            POWER_STATE PowerState , PVOID Context ,
                                            PIO_STATUS_BLOCK IoStatus ))((void *)0),
                                  (void *)0, (PIRP *)((void *)0));
#line 7928
                Extension->SystemState = powerState.SystemState;
                }
              } else {
#line 7931
                if ((int )powerState.SystemState < (int )Extension->SystemState) {
#line 7932
                  hookit = (unsigned char)1;
                } else {

                }
              }
              goto switch_279_break;
            } else {
              switch_279_break: ;
            }
          }
        }
        goto switch_277_break;
        switch_277_default: 
#line 7945
        status = -1073741637L;
      } else {
        switch_277_break: ;
      }
    }
  }
  {
#line 7953
  irpSp = pIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7954
  nextIrpSp = pIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7955
  memcpy((void *)nextIrpSp, (void const   *)irpSp, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 7956
  nextIrpSp->Control = (unsigned char)0;
  }
#line 7958
  if (! (status >= 0L)) {
    {
#line 7960
    pIrp->IoStatus.__annonCompField4.Status = status;
#line 7962
    PptCompleteRequest(pIrp, (char)0);
    }
  } else {
#line 7965
    if (hookit) {
#line 7966
      if (s != NP) {
        {
#line 7968
        errorFn();
        }
      } else {
#line 7971
        if (compRegistered != 0) {
          {
#line 7973
          errorFn();
          }
        } else {
#line 7976
          compRegistered = 1;
#line 7977
          compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))(& PptPowerComplete);
#line 7978
          routine = 1;
        }
      }
      {
#line 7982
      irpSp___0 = pIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7983
      irpSp___0->CompletionRoutine = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                                   PVOID Context ))(& PptPowerComplete);
#line 7984
      irpSp___0->Context = (void *)Extension;
#line 7985
      irpSp___0->Control = (unsigned char)0;
#line 7986
      irpSp___0->Control = (unsigned char)64;
#line 7987
      irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 128);
#line 7988
      irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 32);
#line 7989
      status = PoCallDriver(Extension->ParentDeviceObject, pIrp);
      }
    } else {
      {
#line 7994
      status = PoCallDriver(Extension->ParentDeviceObject, pIrp);
      }
    }
  }
  {
#line 7999
  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)pIrp);
  }
#line 8001
  return (status);
}
}
#line 8008
#pragma warning(push)
#line 8009
#pragma warning(disable:4035)
#line 8010
#pragma warning(pop)
#line 8012
#pragma warning(disable:4103)
#line 8013
#pragma warning(disable:4103)
#line 8014
#pragma warning(push)
#line 8015
#pragma warning(disable:4035)
#line 8016
#pragma warning(pop)
#line 8017
#pragma warning(disable:4035)
#line 8018
#pragma warning(push)
#line 8019
#pragma warning(disable:4164)
#line 8020
#pragma function(_enable)
#line 8021
#pragma function(_disable)
#line 8022
#pragma warning(pop)
#line 8023
#pragma warning(disable:4103)
#line 8024
#pragma warning(disable:4103)
#line 8025
#pragma warning(disable:4103)
#line 8026
#pragma warning(disable:4103)
#line 8027
#pragma warning(disable:4103)
#line 8028
#pragma warning(disable:4103)
#line 8029
#pragma warning(disable:4200)
#line 8030
#pragma warning(default:4200)
#line 8031 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
static UCHAR LegacyZipModeQualifier___11[3]  = {      (UCHAR )0,      (UCHAR )60,      (UCHAR )32};
#line 8033 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptLegacyZipClockDiskModeByte(PUCHAR Controller , UCHAR ModeByte ) 
{ 

  {
  {
#line 8038
  WRITE_PORT_UCHAR(Controller, ModeByte);
#line 8039
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)4);
#line 8040
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)6);
#line 8041
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)4);
#line 8042
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)12);
  }
#line 8044
  return;
}
}
#line 8047 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptLegacyZipClockPrtModeByte(PUCHAR Controller , UCHAR ModeByte ) 
{ 

  {
  {
#line 8052
  WRITE_PORT_UCHAR(Controller, ModeByte);
#line 8053
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)12);
#line 8054
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)14);
#line 8055
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)12);
#line 8056
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)4);
#line 8057
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)12);
  }
#line 8059
  return;
}
}
#line 8062 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptLegacyZipSetDiskMode(PUCHAR Controller , UCHAR Mode ) 
{ ULONG i ;

  {
  {
#line 8067
  PptLegacyZipClockDiskModeByte(Controller, LegacyZipModeQualifier___11[i]);
#line 8068
  PptLegacyZipClockDiskModeByte(Controller, Mode);
  }
#line 8070
  return;
}
}
#line 8073 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptLegacyZipCheckDevice(PUCHAR Controller ) 
{ UCHAR tmp ;
  UCHAR tmp___0 ;

  {
  {
#line 8079
  WRITE_PORT_UCHAR(Controller + 2, (unsigned char)6);
#line 8080
  tmp___0 = READ_PORT_UCHAR(Controller + 1);
  }
#line 8082
  if (((int )tmp___0 & 8) == 8) {
    {
#line 8084
    WRITE_PORT_UCHAR(Controller + 2, (unsigned char)4);
#line 8085
    tmp = READ_PORT_UCHAR(Controller + 1);
    }
#line 8087
    if (((int )tmp & 8) != 8) {
#line 8088
      return ((unsigned char)1);
    } else {

    }
  } else {

  }
#line 8095
  return ((unsigned char)0);
}
}
#line 8098 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptTrySelectLegacyZip(PVOID Context , PVOID TrySelectCommand ) 
{ PDEVICE_EXTENSION Extension ;
  PPARALLEL_1284_COMMAND Command ;
  NTSTATUS Status ;
  PUCHAR Controller ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  KIRQL CancelIrql ;
  BOOLEAN tmp ;

  {
#line 8108
  Extension = (struct _DEVICE_EXTENSION *)Context;
#line 8109
  Command = (struct _PARALLEL_1284_COMMAND *)TrySelectCommand;
#line 8110
  Status = 0L;
#line 8111
  Controller = Extension->PortInfo.Controller;
#line 8114
  if (! (Command->CommandFlags & 2UL)) {
    {
#line 8118
    IoAcquireCancelSpinLock(& CancelIrql);
#line 8119
    SyncContext.Count = & Extension->WorkQueueCount;
    }
#line 8121
    if (Extension->InterruptRefCount) {
      {
#line 8123
      KeSynchronizeExecution(Extension->InterruptObject, & PptSynchronizedIncrement,
                             (void *)(& SyncContext));
      }
    } else {
      {
#line 8128
      PptSynchronizedIncrement((void *)(& SyncContext));
      }
    }
#line 8131
    if (SyncContext.NewCount) {
#line 8132
      Status = 259L;
    } else {

    }
  } else {

  }
#line 8142
  if (Status >= 0L) {
#line 8143
    if (Status != 259L) {
#line 8144
      if (Command->CommandFlags & 32UL) {
        {
#line 8146
        PptLegacyZipSetDiskMode(Controller, (unsigned char)207);
        }
      } else {
        {
#line 8150
        PptLegacyZipSetDiskMode(Controller, (unsigned char)143);
        }
      }
      {
#line 8154
      tmp = PptLegacyZipCheckDevice(Controller);
      }
#line 8156
      if (tmp) {
#line 8159
        if (! Extension->CheckedForGenericEpp) {
#line 8160
          if (Extension->PnpInfo.HardwareCapabilities & 1UL) {
#line 8161
            if (! Extension->NationalChipFound) {
              {
#line 8163
              PptDetectEppPort(Extension);
              }
            } else {

            }
          } else {

          }
#line 8171
          Extension->CheckedForGenericEpp = (unsigned char)1;
        } else {

        }
      } else {
        {
#line 8179
        PptDeselectLegacyZip(Context, TrySelectCommand);
#line 8180
        Status = -1073741823L;
        }
      }
    } else {

    }
  } else {

  }
#line 8189
  return (Status);
}
}
#line 8192 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDeselectLegacyZip(PVOID Context , PVOID DeselectCommand ) 
{ ULONG i ;
  PDEVICE_EXTENSION Extension ;
  PUCHAR Controller ;
  PPARALLEL_1284_COMMAND Command ;

  {
  {
#line 8199
  Extension = (struct _DEVICE_EXTENSION *)Context;
#line 8200
  Controller = Extension->PortInfo.Controller;
#line 8201
  Command = (struct _PARALLEL_1284_COMMAND *)DeselectCommand;
#line 8205
  PptLegacyZipClockPrtModeByte(Controller, LegacyZipModeQualifier___11[i]);
#line 8206
  PptLegacyZipClockPrtModeByte(Controller, (unsigned char)15);
  }
#line 8208
  if (! (Command->CommandFlags & 2UL)) {
    {
#line 8210
    PptFreePort((void *)Extension);
    }
  } else {

  }
#line 8215
  return (0L);
}
}
#line 8222
#pragma warning(push)
#line 8223
#pragma warning(disable:4035)
#line 8224
#pragma warning(pop)
#line 8226
#pragma warning(disable:4103)
#line 8227
#pragma warning(disable:4103)
#line 8228
#pragma warning(push)
#line 8229
#pragma warning(disable:4035)
#line 8230
#pragma warning(pop)
#line 8231
#pragma warning(disable:4035)
#line 8232
#pragma warning(push)
#line 8233
#pragma warning(disable:4164)
#line 8234
#pragma function(_enable)
#line 8235
#pragma function(_disable)
#line 8236
#pragma warning(pop)
#line 8237
#pragma warning(disable:4103)
#line 8238
#pragma warning(disable:4103)
#line 8239
#pragma warning(disable:4103)
#line 8240
#pragma warning(disable:4103)
#line 8241
#pragma warning(disable:4103)
#line 8242
#pragma warning(disable:4103)
#line 8243
#pragma warning(disable:4200)
#line 8244
#pragma warning(default:4200)
#line 8246 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptRegInitDriverSettings(PUNICODE_STRING RegistryPath___0 ) 
{ NTSTATUS Status ;
  RTL_QUERY_REGISTRY_TABLE paramTable[3] ;
  PWSTR path ;
  ULONG defaultDebugLevel ;
  ULONG defaultBreakOn ;
  PVOID tmp ;

  {
  {
#line 8256
  defaultDebugLevel = 0UL;
#line 8257
  defaultBreakOn = 0UL;
#line 8258
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )((unsigned int )RegistryPath___0->Length + sizeof(WCHAR )),
                              1349673296UL);
#line 8260
  path = (WCHAR *)tmp;
  }
#line 8262
  if (! path) {
#line 8263
    PptDebugLevel = defaultDebugLevel;
#line 8264
    PptBreakOn = defaultBreakOn;
#line 8265
    return;
  } else {

  }
  {
#line 8270
  memmove((void *)path, (void const   *)RegistryPath___0->Buffer, (unsigned int )RegistryPath___0->Length);
#line 8271
  *(path + (int )RegistryPath___0->Length / 2) = (unsigned short)0;
#line 8272
  memset((void *)(paramTable), 0, sizeof(paramTable));
#line 8273
  paramTable[0].Flags = 32UL;
#line 8274
  paramTable[0].EntryContext = (void *)(& PptDebugLevel);
#line 8275
  paramTable[0].DefaultType = 4UL;
#line 8276
  paramTable[0].DefaultData = (void *)(& defaultDebugLevel);
#line 8277
  paramTable[0].DefaultLength = (unsigned long )sizeof(ULONG );
#line 8278
  paramTable[1].Flags = 32UL;
#line 8279
  paramTable[1].EntryContext = (void *)(& PptBreakOn);
#line 8280
  paramTable[1].DefaultType = 4UL;
#line 8281
  paramTable[1].DefaultData = (void *)(& defaultBreakOn);
#line 8282
  paramTable[1].DefaultLength = (unsigned long )sizeof(ULONG );
#line 8283
  Status = RtlQueryRegistryValues(2147483648UL, (WCHAR const   *)path, paramTable,
                                  (void *)0, (void *)0);
  }
#line 8285
  if (! (Status >= 0L)) {
#line 8286
    PptDebugLevel = defaultDebugLevel;
#line 8287
    PptBreakOn = defaultBreakOn;
  } else {

  }
#line 8296
  return;
}
}
#line 8299 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptRegGetDeviceParameterDword(PDEVICE_OBJECT Pdo , PWSTR ParameterName ,
                                       PULONG ParameterValue ) 
{ NTSTATUS status ;
  HANDLE hKey ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;
  ULONG defaultValue ;

  {
  {
#line 8308
  status = IoOpenDeviceRegistryKey(Pdo, 1UL, 131097UL, & hKey);
  }
#line 8310
  if (! (status >= 0L)) {
#line 8311
    return (status);
  } else {

  }
  {
#line 8316
  defaultValue = *ParameterValue;
#line 8317
  memset((void *)(& queryTable), 0, sizeof(queryTable));
#line 8318
  queryTable[0].Flags = 32UL;
#line 8319
  queryTable[0].Name = ParameterName;
#line 8320
  queryTable[0].EntryContext = (void *)ParameterValue;
#line 8321
  queryTable[0].DefaultType = 4UL;
#line 8322
  queryTable[0].DefaultData = (void *)(& defaultValue);
#line 8323
  queryTable[0].DefaultLength = (unsigned long )sizeof(ULONG );
#line 8324
  status = RtlQueryRegistryValues(1073741824UL, (WCHAR const   *)hKey, queryTable,
                                  (void *)0, (void *)0);
  }
#line 8326
  if (! (status >= 0L)) {
#line 8327
    *ParameterValue = defaultValue;
  } else {

  }
  {
#line 8332
  ZwClose(hKey);
  }
#line 8334
  return (status);
}
}
#line 8337 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptRegSetDeviceParameterDword(PDEVICE_OBJECT Pdo , PWSTR ParameterName ,
                                       PULONG ParameterValue ) 
{ NTSTATUS status ;
  HANDLE hKey ;
  UNICODE_STRING valueName ;

  {
  {
#line 8345
  status = IoOpenDeviceRegistryKey(Pdo, 1UL, 131078UL, & hKey);
  }
#line 8347
  if (! (status >= 0L)) {
#line 8350
    return (status);
  } else {

  }
  {
#line 8356
  status = ZwSetValueKey(hKey, & valueName, 0UL, 4UL, (void *)ParameterValue, (unsigned long )sizeof(ULONG ));
  }
#line 8358
  if (! (status >= 0L)) {

  } else {

  }
  {
#line 8365
  ZwClose(hKey);
  }
#line 8367
  return (status);
}
}
#line 8374
#pragma warning(push)
#line 8375
#pragma warning(disable:4035)
#line 8376
#pragma warning(pop)
#line 8378
#pragma warning(disable:4103)
#line 8379
#pragma warning(disable:4103)
#line 8380
#pragma warning(push)
#line 8381
#pragma warning(disable:4035)
#line 8382
#pragma warning(pop)
#line 8383
#pragma warning(disable:4035)
#line 8384
#pragma warning(push)
#line 8385
#pragma warning(disable:4164)
#line 8386
#pragma function(_enable)
#line 8387
#pragma function(_disable)
#line 8388
#pragma warning(pop)
#line 8389
#pragma warning(disable:4103)
#line 8390
#pragma warning(disable:4103)
#line 8391
#pragma warning(disable:4103)
#line 8392
#pragma warning(disable:4103)
#line 8393
#pragma warning(disable:4103)
#line 8394
#pragma warning(disable:4103)
#line 8395
#pragma warning(disable:4200)
#line 8396
#pragma warning(default:4200)
#line 8398 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptFailRequest(PIRP Irp , NTSTATUS Status ) 
{ 

  {
  {
#line 8403
  Irp->IoStatus.__annonCompField4.Status = Status;
#line 8404
  myStatus = (int )Status;
#line 8405
  Irp->IoStatus.Information = 0UL;
#line 8406
  PptCompleteRequest(Irp, (char)0);
  }
#line 8408
  return (Status);
}
}
#line 8411 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptAcquireRemoveLockOrFailIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION extension ;
  PIO_REMOVE_LOCK removeLock ;
  NTSTATUS status ;
  NTSTATUS tmp ;

  {
  {
#line 8419
  extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 8420
  removeLock = & extension->RemoveLock;
#line 8421
  tmp = IoAcquireRemoveLockEx(removeLock, (void *)Irp, "util.c", 33UL, (unsigned long )sizeof(IO_REMOVE_LOCK ));
#line 8422
  status = tmp;
  }
#line 8424
  if (! (status >= 0L)) {
    {
#line 8426
    PptFailRequest(Irp, status);
    }
  } else {

  }
#line 8431
  return (status);
}
}
#line 8434 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchPreProcessIrp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION Extension ;
  NTSTATUS status ;
  NTSTATUS tmp ;

  {
  {
#line 8441
  Extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 8442
  tmp = PptAcquireRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 8443
  status = tmp;
  }
#line 8445
  if (! (status >= 0L)) {
    {
#line 8447
    Irp->IoStatus.Information = 0UL;
#line 8448
    Irp->IoStatus.__annonCompField4.Status = status;
#line 8449
    myStatus = (int )status;
#line 8450
    PptCompleteRequest(Irp, (char)0);
    }
  } else {

  }
#line 8455
  return (status);
}
}
#line 8458 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchPostProcessIrp(void) 
{ 

  {
#line 8462
  return (0L);
}
}
#line 8465 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptSynchCompletionRoutine(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT Event ) 
{ 

  {
  {
#line 8470
  KeSetEvent(Event, 0L, (unsigned char)0);
  }
#line 8472
  return (-1073741802L);
}
}
#line 8475 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PWSTR PptGetPortNameFromPhysicalDeviceObject(PDEVICE_OBJECT PhysicalDeviceObject ) 
{ NTSTATUS status ;
  HANDLE hKey ;
  PKEY_VALUE_FULL_INFORMATION buffer ;
  ULONG bufferLength ;
  ULONG resultLength ;
  UNICODE_STRING valueName ;
  PWSTR portName ;
  PVOID tmp ;
  PVOID tmp___0 ;

  {
  {
#line 8491
  status = IoOpenDeviceRegistryKey(PhysicalDeviceObject, 1UL, 2031616UL, & hKey);
  }
#line 8493
  if (! (status >= 0L)) {
#line 8496
    return ((WCHAR *)((void *)0));
  } else {

  }
#line 8501
  bufferLength = 0UL;
#line 8502
  buffer = (struct _KEY_VALUE_FULL_INFORMATION *)((void *)0);
#line 8504
  status = -1073741789L;
  {
#line 8507
  while (1) {
    while_30_continue: /* CIL Label */ ;

#line 8509
    if (status == -1073741789L) {

    } else {
      goto while_290_break;
    }
    {
#line 8515
    status = ZwQueryValueKey(hKey, & valueName, (enum _KEY_VALUE_INFORMATION_CLASS )1,
                             (void *)buffer, bufferLength, & resultLength);
    }
#line 8517
    if (status == -1073741789L) {
#line 8518
      if (buffer) {

      } else {

      }
      {
#line 8526
      tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, resultLength, 1349673296UL);
#line 8527
      buffer = (struct _KEY_VALUE_FULL_INFORMATION *)tmp;
#line 8528
      bufferLength = resultLength;
      }
#line 8530
      if (! buffer) {
        {
#line 8534
        ZwClose(hKey);
        }
#line 8536
        return ((WCHAR *)((void *)0));
      } else {

      }
    } else {

    }
  }
  while_30_break: /* CIL Label */ ;
  }
  while_290_break: 
  {
#line 8547
  ZwClose(hKey);
  }
#line 8549
  if (! (status >= 0L)) {
#line 8550
    if (buffer) {

    } else {

    }
#line 8559
    return ((WCHAR *)((void *)0));
  } else {

  }
#line 8563
  if (buffer->Type != 1UL) {
    goto _L;
  } else {
#line 8566
    if (! buffer->DataLength) {
      _L: ;
#line 8573
      return ((WCHAR *)((void *)0));
    } else {

    }
  }
  {
#line 8579
  tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )1, buffer->DataLength, 1349673296UL);
#line 8580
  portName = (WCHAR *)tmp___0;
  }
#line 8582
  if (! portName) {
#line 8588
    return ((WCHAR *)((void *)0));
  } else {

  }
  {
#line 8593
  memcpy((void *)portName, (void const   *)((UCHAR *)buffer + buffer->DataOffset),
         (unsigned int )buffer->DataLength);
  }
#line 8596
  return (portName);
}
}
#line 8599 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptConnectInterrupt(PDEVICE_EXTENSION Extension ) 
{ NTSTATUS Status ;

  {
#line 8603
  Status = 0L;
#line 8604
  if (! Extension->FoundInterrupt) {
#line 8605
    return (-1073741637L);
  } else {

  }
  {
#line 8610
  Status = IoConnectInterrupt(& Extension->InterruptObject, & PptInterruptService,
                              (void *)Extension, (KSPIN_LOCK *)((void *)0), Extension->InterruptVector,
                              Extension->InterruptLevel, Extension->InterruptLevel,
                              Extension->InterruptMode, (unsigned char)1, Extension->InterruptAffinity,
                              (unsigned char)0);
  }
#line 8615
  if (! (Status >= 0L)) {
    {
#line 8617
    PptLogError((Extension->DeviceObject)->DriverObject, Extension->DeviceObject,
                Extension->PortInfo.OriginalController, (union _LARGE_INTEGER )PhysicalZero,
                0UL, (unsigned char)0, (unsigned char)0, 14UL, Status, 20L);
    }
  } else {

  }
#line 8626
  return (Status);
}
}
#line 8629 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptDisconnectInterrupt(PDEVICE_EXTENSION Extension ) 
{ 

  {
  {
#line 8634
  IoDisconnectInterrupt(Extension->InterruptObject);
  }
#line 8636
  return;
}
}
#line 8639 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSynchronizedIncrement(PVOID SyncContext ) 
{ 

  {
#line 8643
  *(((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->Count) += 1L;
#line 8644
  ((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->NewCount = *(((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->Count);
#line 8645
  return ((unsigned char)1);
}
}
#line 8648 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSynchronizedDecrement(PVOID SyncContext ) 
{ 

  {
#line 8652
  *(((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->Count) -= 1L;
#line 8653
  ((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->NewCount = *(((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->Count);
#line 8654
  return ((unsigned char)1);
}
}
#line 8657 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSynchronizedRead(PVOID SyncContext ) 
{ 

  {
#line 8661
  ((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->NewCount = *(((struct _SYNCHRONIZED_COUNT_CONTEXT *)SyncContext)->Count);
#line 8662
  return ((unsigned char)1);
}
}
#line 8665 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSynchronizedQueue(PVOID Context ) 
{ PSYNCHRONIZED_LIST_CONTEXT ListContext ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_ListHead ;

  {
#line 8671
  ListContext = (struct _SYNCHRONIZED_LIST_CONTEXT *)Context;
#line 8672
  _EX_ListHead = ListContext->List;
#line 8673
  _EX_Blink = _EX_ListHead->Blink;
#line 8674
  (ListContext->NewEntry)->Flink = _EX_ListHead;
#line 8675
  (ListContext->NewEntry)->Blink = _EX_Blink;
#line 8676
  _EX_Blink->Flink = ListContext->NewEntry;
#line 8677
  _EX_ListHead->Blink = ListContext->NewEntry;
#line 8678
  return ((unsigned char)1);
}
}
#line 8681 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptSynchronizedDisconnect(PVOID Context ) 
{ PSYNCHRONIZED_DISCONNECT_CONTEXT DisconnectContext ;
  BOOLEAN (*ServiceRoutine)(struct _KINTERRUPT *Interrupt , PVOID ServiceContext ) ;
  PVOID ServiceContext ;
  PLIST_ENTRY Current ;
  PISR_LIST_ENTRY ListEntry ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
#line 8691
  DisconnectContext = (struct _SYNCHRONIZED_DISCONNECT_CONTEXT *)Context;
#line 8692
  ServiceRoutine = (DisconnectContext->IsrInfo)->InterruptServiceRoutine;
#line 8693
  ServiceContext = (DisconnectContext->IsrInfo)->InterruptServiceContext;
#line 8694
  Current = (DisconnectContext->Extension)->IsrList.Flink;
  {
#line 8696
  while (1) {
    while_31_continue: /* CIL Label */ ;

#line 8698
    if ((unsigned int )Current != (unsigned int )(& (DisconnectContext->Extension)->IsrList)) {

    } else {
      goto while_296_break;
    }
#line 8703
    ListEntry = (ISR_LIST_ENTRY *)((CHAR *)Current - (unsigned long )(& ((ISR_LIST_ENTRY *)0)->ListEntry));
#line 8704
    if ((unsigned int )ListEntry->ServiceRoutine == (unsigned int )ServiceRoutine) {
#line 8705
      if ((unsigned int )ListEntry->ServiceContext == (unsigned int )ServiceContext) {
#line 8706
        _EX_Flink = Current->Flink;
#line 8707
        _EX_Blink = Current->Blink;
#line 8708
        _EX_Blink->Flink = _EX_Flink;
#line 8709
        _EX_Flink->Blink = _EX_Blink;
#line 8710
        return ((unsigned char)1);
      } else {

      }
    } else {

    }
#line 8717
    Current = Current->Flink;
  }
  while_31_break: /* CIL Label */ ;
  }
  while_296_break: ;
#line 8721
  return ((unsigned char)0);
}
}
#line 8724 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptCancelRoutine(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDEVICE_EXTENSION Extension ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
#line 8733
  Extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 8734
  SyncContext.Count = & Extension->WorkQueueCount;
#line 8735
  if (Extension->InterruptRefCount) {
    {
#line 8737
    KeSynchronizeExecution(Extension->InterruptObject, & PptSynchronizedDecrement,
                           (void *)(& SyncContext));
    }
  } else {
    {
#line 8742
    PptSynchronizedDecrement((void *)(& SyncContext));
    }
  }
  {
#line 8746
  _EX_Flink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink;
#line 8747
  _EX_Blink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink;
#line 8748
  _EX_Blink->Flink = _EX_Flink;
#line 8749
  _EX_Flink->Blink = _EX_Blink;
#line 8751
  Irp->IoStatus.Information = 0UL;
#line 8752
  Irp->IoStatus.__annonCompField4.Status = -1073741536L;
#line 8753
  myStatus = -1073741536;
#line 8754
  PptReleaseRemoveLock(& Extension->RemoveLock, (void *)Irp);
#line 8755
  PptCompleteRequest(Irp, (char)0);
  }
#line 8757
  return;
}
}
#line 8760 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptFreePortDpc(PKDPC Dpc , PVOID Extension , PVOID SystemArgument1 , PVOID SystemArgument2 ) 
{ 

  {
  {
#line 8765
  PptFreePort(Extension);
  }
#line 8767
  return;
}
}
#line 8770 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptTryAllocatePortAtInterruptLevel(PVOID Context ) 
{ 

  {
#line 8774
  if (((struct _DEVICE_EXTENSION *)Context)->WorkQueueCount == -1L) {
#line 8775
    ((struct _DEVICE_EXTENSION *)Context)->WorkQueueCount = 0L;
#line 8776
    ((struct _DEVICE_EXTENSION *)Context)->WmiPortAllocFreeCounts.PortAllocates += 1UL;
#line 8777
    return ((unsigned char)1);
  } else {
#line 8779
    return ((unsigned char)0);
  }
}
}
#line 8783 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptFreePortFromInterruptLevel(PVOID Context ) 
{ 

  {
#line 8787
  if (((struct _DEVICE_EXTENSION *)Context)->WorkQueueCount == 0L) {
#line 8788
    ((struct _DEVICE_EXTENSION *)Context)->WorkQueueCount = -1L;
  } else {
    {
#line 8791
    KeInsertQueueDpc(& ((struct _DEVICE_EXTENSION *)Context)->FreePortDpc, (void *)0,
                     (void *)0);
    }
  }
#line 8795
  return;
}
}
#line 8798 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptInterruptService(PKINTERRUPT Interrupt , PVOID Extension ) 
{ PLIST_ENTRY Current ;
  PISR_LIST_ENTRY IsrListEntry ;
  PDEVICE_EXTENSION DeviceExtension ;
  BOOLEAN tmp ;

  {
#line 8805
  DeviceExtension = (struct _DEVICE_EXTENSION *)Extension;
#line 8806
  Current = DeviceExtension->IsrList.Flink;
  {
#line 8808
  while (1) {
    while_32_continue: /* CIL Label */ ;

#line 8810
    if ((unsigned int )Current != (unsigned int )(& DeviceExtension->IsrList)) {

    } else {
      goto while_298_break;
    }
    {
#line 8816
    IsrListEntry = (ISR_LIST_ENTRY *)((CHAR *)Current - (unsigned long )(& ((ISR_LIST_ENTRY *)0)->ListEntry));
#line 8817
    tmp = (*(IsrListEntry->ServiceRoutine))(Interrupt, IsrListEntry->ServiceContext);
    }
#line 8819
    if (tmp) {
#line 8820
      return ((unsigned char)1);
    } else {

    }
#line 8824
    Current = Current->Flink;
  }
  while_32_break: /* CIL Label */ ;
  }
  while_298_break: ;
#line 8828
  return ((unsigned char)0);
}
}
#line 8831 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptTryAllocatePort(PVOID Extension ) 
{ PDEVICE_EXTENSION DeviceExtension ;
  KIRQL CancelIrql ;
  BOOLEAN b ;

  {
#line 8837
  DeviceExtension = (struct _DEVICE_EXTENSION *)Extension;
#line 8838
  if (DeviceExtension->InterruptRefCount) {
    {
#line 8840
    b = KeSynchronizeExecution(DeviceExtension->InterruptObject, & PptTryAllocatePortAtInterruptLevel,
                               (void *)DeviceExtension);
    }
  } else {
    {
#line 8845
    IoAcquireCancelSpinLock(& CancelIrql);
#line 8846
    b = PptTryAllocatePortAtInterruptLevel((void *)DeviceExtension);
    }
  }
#line 8852
  return (b);
}
}
#line 8855 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN PptTraversePortCheckList(PVOID Extension ) 
{ PDEVICE_EXTENSION DeviceExtension ;
  PLIST_ENTRY Current ;
  PISR_LIST_ENTRY CheckEntry ;

  {
#line 8861
  DeviceExtension = (struct _DEVICE_EXTENSION *)Extension;
#line 8862
  if (DeviceExtension->WorkQueueCount >= 0L) {
#line 8863
    return ((unsigned char)0);
  } else {

  }
#line 8867
  Current = DeviceExtension->IsrList.Flink;
  {
#line 8869
  while (1) {
    while_33_continue: /* CIL Label */ ;

#line 8871
    if ((unsigned int )Current != (unsigned int )(& DeviceExtension->IsrList)) {

    } else {
      goto while_300_break;
    }
#line 8876
    CheckEntry = (ISR_LIST_ENTRY *)((CHAR *)Current - (unsigned long )(& ((ISR_LIST_ENTRY *)0)->ListEntry));
#line 8877
    if (CheckEntry->DeferredPortCheckRoutine) {
      {
#line 8879
      (*(CheckEntry->DeferredPortCheckRoutine))(CheckEntry->CheckContext);
      }
    } else {

    }
#line 8884
    Current = Current->Flink;
  }
  while_33_break: /* CIL Label */ ;
  }
  while_300_break: ;
#line 8888
  return ((unsigned char)1);
}
}
#line 8891 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PptFreePort(PVOID Extension ) 
{ PDEVICE_EXTENSION DeviceExtension ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  KIRQL CancelIrql ;
  ULONG InterruptRefCount ;
  BOOLEAN Allocated ;

  {
  {
#line 8899
  DeviceExtension = (struct _DEVICE_EXTENSION *)Extension;
#line 8903
  SyncContext.Count = & DeviceExtension->WorkQueueCount;
#line 8904
  IoAcquireCancelSpinLock(& CancelIrql);
  }
#line 8906
  if (DeviceExtension->InterruptRefCount) {
    {
#line 8908
    KeSynchronizeExecution(DeviceExtension->InterruptObject, & PptSynchronizedDecrement,
                           (void *)(& SyncContext));
    }
  } else {
    {
#line 8913
    PptSynchronizedDecrement((void *)(& SyncContext));
    }
  }
#line 8918
  DeviceExtension->WmiPortAllocFreeCounts.PortFrees += 1UL;
#line 8919
  Allocated = (unsigned char)0;
  {
#line 8922
  while (1) {
    while_34_continue: /* CIL Label */ ;

#line 8924
    if (! Allocated) {
#line 8925
      if (SyncContext.NewCount >= 0L) {

      } else {
        goto while_302_break;
      }
    } else {
      goto while_302_break;
    }
  }
  while_34_break: /* CIL Label */ ;
  }
  while_302_break: ;
#line 8936
  if (! Allocated) {
    {
#line 8938
    IoAcquireCancelSpinLock(& CancelIrql);
#line 8939
    InterruptRefCount = DeviceExtension->InterruptRefCount;
    }
#line 8942
    if (InterruptRefCount) {
      {
#line 8944
      KeSynchronizeExecution(DeviceExtension->InterruptObject, & PptTraversePortCheckList,
                             (void *)DeviceExtension);
      }
    } else {

    }
  } else {

  }
#line 8953
  return;
}
}
#line 8956 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
ULONG PptQueryNumWaiters(PVOID Extension ) 
{ PDEVICE_EXTENSION DeviceExtension ;
  KIRQL CancelIrql ;
  SYNCHRONIZED_COUNT_CONTEXT SyncContext ;
  unsigned long tmp ;

  {
#line 8963
  DeviceExtension = (struct _DEVICE_EXTENSION *)Extension;
#line 8964
  SyncContext.Count = & DeviceExtension->WorkQueueCount;
#line 8965
  if (DeviceExtension->InterruptRefCount) {
    {
#line 8967
    KeSynchronizeExecution(DeviceExtension->InterruptObject, & PptSynchronizedRead,
                           (void *)(& SyncContext));
    }
  } else {
    {
#line 8972
    IoAcquireCancelSpinLock(& CancelIrql);
#line 8973
    PptSynchronizedRead((void *)(& SyncContext));
    }
  }
#line 8977
  if (SyncContext.NewCount >= 0L) {
#line 8978
    tmp = (unsigned long )SyncContext.NewCount;
  } else {
#line 8980
    tmp = 0UL;
  }
#line 8982
  return (tmp);
}
}
#line 8985 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID PptSetCancelRoutine(PIRP Irp , void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject ,
                                                           struct _IRP *Irp ) ) 
{ LONG tmp ;

  {
  {
#line 8991
  tmp = InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)CancelRoutine));
  }
#line 8993
  return ((void *)((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)));
}
}
#line 8996
extern int KeQueryTickCount() ;
#line 8997 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
BOOLEAN CheckPort(PUCHAR wPortAddr , UCHAR bMask , UCHAR bValue , USHORT usTimeDelay ) 
{ UCHAR dsr ;
  LARGE_INTEGER Wait ;
  LARGE_INTEGER Start ;
  LARGE_INTEGER End ;
  ULONG tmp ;
  ULONG tmp___0 ;

  {
  {
#line 9007
  dsr = READ_PORT_UCHAR(wPortAddr);
  }
#line 9009
  if (((int )dsr & (int )bMask) == (int )bValue) {
#line 9010
    return ((unsigned char)1);
  } else {

  }
  {
#line 9015
  tmp = KeQueryTimeIncrement();
#line 9016
  Wait.QuadPart = (long long )((unsigned long )(((int )usTimeDelay * 10) * 10) + tmp);
#line 9017
  KeQueryTickCount(& Start);
  }
  {
#line 9020
  while (1) {
    while_35_continue: /* CIL Label */ ;
    {
#line 9023
    KeQueryTickCount(& End);
#line 9024
    dsr = READ_PORT_UCHAR(wPortAddr);
    }
#line 9026
    if (((int )dsr & (int )bMask) == (int )bValue) {
#line 9027
      return ((unsigned char)1);
    } else {

    }
    {
#line 9032
    tmp___0 = KeQueryTimeIncrement();
    }
#line 9034
    if ((End.QuadPart - Start.QuadPart) * (long long )tmp___0 > Wait.QuadPart) {
      goto CheckPort_TimeOut;
    } else {

    }
  }
  while_35_break: /* CIL Label */ ;
  }

  CheckPort_TimeOut: 
#line 9043
  return ((unsigned char)0);
}
}
#line 9046 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptBuildParallelPortDeviceName(ULONG Number , PUNICODE_STRING DeviceName ) 
{ UNICODE_STRING uniDeviceString ;
  UNICODE_STRING uniBaseNameString ;
  UNICODE_STRING uniPortNumberString ;
  WCHAR wcPortNum[10] ;
  NTSTATUS status ;
  PVOID tmp ;

  {
  {
#line 9059
  uniPortNumberString.Length = (unsigned short)0;
#line 9060
  uniPortNumberString.MaximumLength = (unsigned short )sizeof(wcPortNum);
#line 9061
  uniPortNumberString.Buffer = wcPortNum;
#line 9062
  status = RtlIntegerToUnicodeString(Number, 10UL, & uniPortNumberString);
  }
#line 9064
  if (! (status >= 0L)) {
#line 9067
    return (status);
  } else {

  }
  {
#line 9072
  DeviceName->MaximumLength = (unsigned short )((unsigned int )(((int )uniDeviceString.Length + (int )uniBaseNameString.Length) + (int )uniPortNumberString.Length) + sizeof((unsigned short)0));
#line 9073
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )DeviceName->MaximumLength,
                              1349673296UL);
#line 9074
  DeviceName->Buffer = (WCHAR *)tmp;
  }
#line 9076
  if ((unsigned int )((void *)0) == (unsigned int )DeviceName->Buffer) {
#line 9079
    return (-1073741670L);
  } else {

  }
  {
#line 9084
  memset((void *)DeviceName->Buffer, 0, (unsigned int )DeviceName->MaximumLength);
#line 9085
  RtlAppendUnicodeStringToString(DeviceName, & uniDeviceString);
#line 9086
  RtlAppendUnicodeStringToString(DeviceName, & uniBaseNameString);
#line 9087
  RtlAppendUnicodeStringToString(DeviceName, & uniPortNumberString);
  }
#line 9089
  return (0L);
}
}
#line 9092 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptInitializeDeviceExtension(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ,
                                      PDEVICE_OBJECT DeviceObject , PUNICODE_STRING UniNameString ,
                                      PWSTR PortName , ULONG PortNumber ) 
{ PDEVICE_EXTENSION Extension ;
  ULONG bufferLength ;
  PVOID tmp ;

  {
  {
#line 9101
  Extension = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 9102
  memset((void *)Extension, 0, sizeof(DEVICE_EXTENSION ));
#line 9103
  Extension->ExtensionSignatureBegin = 2022144135UL;
#line 9104
  Extension->ExtensionSignatureEnd = 2272823160UL;
#line 9105
  Extension->DriverObject = DriverObject;
#line 9106
  Extension->PhysicalDeviceObject = PhysicalDeviceObject;
#line 9107
  Extension->DeviceObject = DeviceObject;
#line 9108
  Extension->PnpInfo.PortNumber = PortNumber;
#line 9109
  IoInitializeRemoveLockEx(& Extension->RemoveLock, 1349673296UL, 1UL, 10UL, (unsigned long )sizeof(IO_REMOVE_LOCK ));
#line 9110
  Extension->OpenCloseMutex.Count = 1L;
#line 9111
  Extension->OpenCloseMutex.Contention = 0UL;
#line 9113
  Extension->ExtensionFastMutex.Count = 1L;
#line 9114
  Extension->ExtensionFastMutex.Contention = 0UL;
#line 9116
  Extension->NationalChipFound = (unsigned char)0;
#line 9117
  Extension->NationalChecked = (unsigned char)0;
#line 9118
  Extension->WorkQueue.Blink = & Extension->WorkQueue;
#line 9119
  Extension->WorkQueue.Flink = Extension->WorkQueue.Blink;
#line 9120
  Extension->WorkQueueCount = -1L;
#line 9121
  Extension->PortInfo.FreePort = & PptFreePort;
#line 9122
  Extension->PortInfo.TryAllocatePort = & PptTryAllocatePort;
#line 9123
  Extension->PortInfo.QueryNumWaiters = & PptQueryNumWaiters;
#line 9124
  Extension->PortInfo.Context = (void *)Extension;
#line 9125
  Extension->PnpInfo.HardwareCapabilities = 0UL;
#line 9126
  Extension->PnpInfo.TrySetChipMode = (NTSTATUS (*)(PVOID SetChipContext , UCHAR ChipMode ))(& PptSetChipMode);
#line 9127
  Extension->PnpInfo.ClearChipMode = (NTSTATUS (*)(PVOID ClearChipContext , UCHAR ChipMode ))(& PptClearChipMode);
#line 9128
  Extension->PnpInfo.TrySelectDevice = & PptTrySelectDevice;
#line 9129
  Extension->PnpInfo.DeselectDevice = & PptDeselectDevice;
#line 9130
  Extension->PnpInfo.Context = (void *)Extension;
#line 9131
  Extension->PnpInfo.PortName = PortName;
#line 9132
  Extension->RemovalRelationsList.Blink = & Extension->RemovalRelationsList;
#line 9133
  Extension->RemovalRelationsList.Flink = Extension->RemovalRelationsList.Blink;
#line 9134
  Extension->IsrList.Blink = & Extension->IsrList;
#line 9135
  Extension->IsrList.Flink = Extension->IsrList.Blink;
#line 9136
  Extension->InterruptObject = (struct _KINTERRUPT *)((void *)0);
#line 9137
  Extension->InterruptRefCount = 0UL;
#line 9138
  KeInitializeDpc(& Extension->FreePortDpc, & PptFreePortDpc, (void *)Extension);
#line 9139
  bufferLength = (unsigned long )((unsigned int )UniNameString->MaximumLength + sizeof((unsigned short)0));
#line 9140
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )0, bufferLength, 1349673296UL);
#line 9141
  Extension->DeviceName.Buffer = (WCHAR *)tmp;
  }
#line 9143
  if (! Extension->DeviceName.Buffer) {
#line 9144
    return (-1073741670L);
  } else {

  }
  {
#line 9149
  memset((void *)Extension->DeviceName.Buffer, 0, (unsigned int )bufferLength);
#line 9150
  Extension->DeviceName.Length = (unsigned short)0;
#line 9151
  Extension->DeviceName.MaximumLength = UniNameString->MaximumLength;
#line 9153
  Extension->PnpInfo.CurrentMode = 0UL;
#line 9154
  Extension_FilterMode = 0;
  }
#line 9156
  return (0L);
}
}
#line 9159 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptGetPortNumberFromLptName(PWSTR PortName , PULONG PortNumber ) 
{ NTSTATUS status ;
  UNICODE_STRING str ;
  int __BLAST_NONDET ;

  {
#line 9165
  if (__BLAST_NONDET) {
#line 9168
    return (-1073741823L);
  } else {

  }
  {
#line 9174
  status = RtlUnicodeStringToInteger(& str, 10UL, PortNumber);
  }
#line 9176
  if (! (status >= 0L)) {
#line 9179
    return (-1073741823L);
  } else {

  }
#line 9183
  if (*PortNumber == 0UL) {
#line 9186
    return (-1073741823L);
  } else {

  }
#line 9192
  return (0L);
}
}
#line 9195 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PDEVICE_OBJECT PptBuildDeviceObject(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) 
{ UNICODE_STRING uniNameString ;
  ULONG portNumber ;
  PWSTR portName ;
  NTSTATUS status ;
  PDEVICE_OBJECT deviceObject ;

  {
  {
#line 9203
  uniNameString.Length = (unsigned short)0;
#line 9204
  uniNameString.MaximumLength = (unsigned short)0;
#line 9205
  uniNameString.Buffer = (WCHAR *)0;
#line 9206
  portNumber = 0UL;
#line 9207
  portName = (WCHAR *)((void *)0);
#line 9208
  status = 0L;
#line 9209
  deviceObject = (struct _DEVICE_OBJECT *)((void *)0);
#line 9213
  portName = PptGetPortNameFromPhysicalDeviceObject(PhysicalDeviceObject);
  }
#line 9215
  if ((unsigned int )((void *)0) == (unsigned int )portName) {
    goto targetExit;
  } else {

  }
  {
#line 9225
  status = PptGetPortNumberFromLptName(portName, & portNumber);
  }
#line 9227
  if (! (status >= 0L)) {
    goto targetExit;
  } else {

  }
  {
#line 9237
  portNumber -= 1UL;
#line 9241
  status = PptBuildParallelPortDeviceName(portNumber, & uniNameString);
  }
#line 9243
  if (! (status >= 0L)) {
    goto targetExit;
  } else {

  }
  {
#line 9256
  status = IoCreateDevice(DriverObject, (unsigned long )sizeof(DEVICE_EXTENSION ),
                          & uniNameString, 22UL, 256UL, (unsigned char)0, & deviceObject);
  }
#line 9259
  if (-1073741771L == status) {
#line 9262
    portNumber = 7UL;
    {
#line 9264
    while (1) {
      while_36_continue: /* CIL Label */ ;
      {
#line 9268
      portNumber += 1UL;
#line 9269
      status = PptBuildParallelPortDeviceName(portNumber, & uniNameString);
      }
#line 9271
      if (! (status >= 0L)) {
        goto targetExit;
      } else {

      }
      {
#line 9284
      status = IoCreateDevice(DriverObject, (unsigned long )sizeof(DEVICE_EXTENSION ),
                              & uniNameString, 22UL, 256UL, (unsigned char)0, & deviceObject);
      }
#line 9287
      if (-1073741771L == status) {

      } else {
        goto while_319_break;
      }
    }
    while_36_break: /* CIL Label */ ;
    }
    while_319_break: ;
  } else {

  }
#line 9298
  if (! (status >= 0L)) {
#line 9302
    deviceObject = (struct _DEVICE_OBJECT *)((void *)0);
    goto targetExit;
  } else {

  }
  {
#line 9310
  status = PptInitializeDeviceExtension(DriverObject, PhysicalDeviceObject, deviceObject,
                                        & uniNameString, portName, portNumber);
  }
#line 9313
  if (! (status >= 0L)) {
#line 9318
    deviceObject = (struct _DEVICE_OBJECT *)((void *)0);
    goto targetExit;
  } else {

  }
#line 9325
  if (PhysicalDeviceObject->Flags & 8192UL) {
#line 9326
    deviceObject->Flags |= 8192UL;
  } else {

  }
  targetExit: ;
#line 9336
  return (deviceObject);
}
}
#line 9343
#pragma warning(push)
#line 9344
#pragma warning(disable:4035)
#line 9345
#pragma warning(pop)
#line 9347
#pragma warning(disable:4103)
#line 9348
#pragma warning(disable:4103)
#line 9349
#pragma warning(push)
#line 9350
#pragma warning(disable:4035)
#line 9351
#pragma warning(pop)
#line 9352
#pragma warning(disable:4035)
#line 9353
#pragma warning(push)
#line 9354
#pragma warning(disable:4164)
#line 9355
#pragma function(_enable)
#line 9356
#pragma function(_disable)
#line 9357
#pragma warning(pop)
#line 9358
#pragma warning(disable:4103)
#line 9359
#pragma warning(disable:4103)
#line 9360
#pragma warning(disable:4103)
#line 9361
#pragma warning(disable:4103)
#line 9362
#pragma warning(disable:4103)
#line 9363
#pragma warning(disable:4103)
#line 9364
#pragma warning(disable:4200)
#line 9365
#pragma warning(default:4200)
#line 9367
#pragma warning(disable:4200)
#line 9368
NTSTATUS PptWmiQueryWmiRegInfo(PDEVICE_OBJECT PDevObj , PULONG PRegFlags , PUNICODE_STRING PInstanceName ,
                               PUNICODE_STRING *PRegistryPath , PUNICODE_STRING MofResourceName ,
                               PDEVICE_OBJECT *Pdo ) ;
#line 9371
NTSTATUS PptWmiQueryWmiDataBlock(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                                 ULONG InstanceIndex , ULONG InstanceCount , PULONG InstanceLengthArray ,
                                 ULONG OutBufferSize , PUCHAR Buffer ) ;
#line 9374
#pragma alloc_text(PAGEPARWMI0,PptWmiInitWmi)
#line 9375
#pragma alloc_text(PAGEPARWMI0,PptDispatchSystemControl)
#line 9376
#pragma alloc_text(PAGEPARWMI0,PptWmiQueryWmiRegInfo)
#line 9377
#pragma alloc_text(PAGEPARWMI0,PptWmiQueryWmiDataBlock)
#line 9378 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
GUID PptWmiAllocFreeCountsGuid  =    {1270573546UL, (unsigned short)26707, (unsigned short)4562, {(unsigned char)142,
                                                                (unsigned char)206,
                                                                (unsigned char)0,
                                                                (unsigned char)192,
                                                                (unsigned char)79,
                                                                (unsigned char)142,
                                                                (unsigned char)244,
                                                                (unsigned char)129}};
#line 9379 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
WMIGUIDREGINFO PptWmiGuidList[1]  = {      {(LPCGUID )(& PptWmiAllocFreeCountsGuid), (ULONG )1, (ULONG )0}};
#line 9380 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptWmiInitWmi(PDEVICE_OBJECT DeviceObject ) 
{ PDEVICE_EXTENSION devExt ;
  PWMILIB_CONTEXT wmiContext ;
  NTSTATUS tmp ;

  {
  {
#line 9387
  devExt = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 9388
  wmiContext = & devExt->WmiLibContext;
#line 9389
  wmiContext->GuidCount = (unsigned long )(sizeof(PptWmiGuidList) / sizeof(WMIGUIDREGINFO ));
#line 9390
  wmiContext->GuidList = PptWmiGuidList;
#line 9391
  wmiContext->QueryWmiRegInfo = & PptWmiQueryWmiRegInfo;
#line 9392
  wmiContext->QueryWmiDataBlock = & PptWmiQueryWmiDataBlock;
#line 9393
  wmiContext->SetWmiDataBlock = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                              ULONG GuidIndex , ULONG InstanceIndex ,
                                              ULONG BufferSize , PUCHAR Buffer ))((void *)0);
#line 9394
  wmiContext->SetWmiDataItem = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                             ULONG GuidIndex , ULONG InstanceIndex ,
                                             ULONG DataItemId , ULONG BufferSize ,
                                             PUCHAR Buffer ))((void *)0);
#line 9395
  wmiContext->ExecuteWmiMethod = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                               ULONG GuidIndex , ULONG InstanceIndex ,
                                               ULONG MethodId , ULONG InBufferSize ,
                                               ULONG OutBufferSize , PUCHAR Buffer ))((void *)0);
#line 9396
  wmiContext->WmiFunctionControl = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                                 ULONG GuidIndex , WMIENABLEDISABLECONTROL Function ,
                                                 BOOLEAN Enable ))((void *)0);
#line 9397
  tmp = IoWMIRegistrationControl(DeviceObject, 1UL);
  }
#line 9399
  return (tmp);
}
}
#line 9402 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptDispatchSystemControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ SYSCTL_IRP_DISPOSITION disposition ;
  NTSTATUS status ;
  PDEVICE_EXTENSION pDevExt ;

  {
  {
#line 9409
  pDevExt = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 9410
  status = WmiSystemControl(& pDevExt->WmiLibContext, DeviceObject, Irp, & disposition);
  }
#line 9412
  if ((int )disposition == 0) {
    goto switch_325_0;
  } else {
#line 9415
    if ((int )disposition == 1) {
      goto switch_325_1;
    } else {
#line 9418
      if ((int )disposition == 3) {
        goto switch_325_3;
      } else {
#line 9421
        if ((int )disposition == 2) {
          goto switch_325_2;
        } else {
          goto switch_325_default;
#line 9426
          if (0) {
            switch_325_0: 
#line 9428
            s = DC;
            goto switch_325_break;
            switch_325_1: 
            {
#line 9432
            PptCompleteRequest(Irp, (char)0);
            }
            goto switch_325_break;
            switch_325_3: ;
            switch_325_2: ;
#line 9437
            if (s == NP) {
#line 9438
              s = SKIP1;
            } else {
              {
#line 9441
              errorFn();
              }
            }
            {
#line 9445
            Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 9446
            Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 9447
            status = IofCallDriver(pDevExt->ParentDeviceObject, Irp);
            }
            goto switch_325_break;
            switch_325_default: ;
#line 9451
            if (s == NP) {
#line 9452
              s = SKIP1;
            } else {
              {
#line 9455
              errorFn();
              }
            }
            {
#line 9459
            Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 9460
            Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 9461
            status = IofCallDriver(pDevExt->ParentDeviceObject, Irp);
            }
            goto switch_325_break;
          } else {
            switch_325_break: ;
          }
        }
      }
    }
  }
#line 9472
  return (status);
}
}
#line 9475 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptWmiQueryWmiRegInfo(PDEVICE_OBJECT PDevObj , PULONG PRegFlags , PUNICODE_STRING PInstanceName ,
                               PUNICODE_STRING *PRegistryPath , PUNICODE_STRING MofResourceName ,
                               PDEVICE_OBJECT *Pdo ) 
{ PDEVICE_EXTENSION devExt ;

  {
#line 9481
  devExt = (struct _DEVICE_EXTENSION *)PDevObj->DeviceExtension;
#line 9484
  *PRegFlags = 32UL;
#line 9485
  *PRegistryPath = & RegistryPath;
#line 9486
  *Pdo = devExt->PhysicalDeviceObject;
#line 9487
  return (0L);
}
}
#line 9490 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PptWmiQueryWmiDataBlock(PDEVICE_OBJECT DeviceObject , PIRP Irp , ULONG GuidIndex ,
                                 ULONG InstanceIndex , ULONG InstanceCount , PULONG InstanceLengthArray ,
                                 ULONG OutBufferSize , PUCHAR Buffer ) 
{ NTSTATUS status ;
  ULONG size ;
  PDEVICE_EXTENSION devExt ;

  {
#line 9498
  size = (unsigned long )sizeof(PARPORT_WMI_ALLOC_FREE_COUNTS );
#line 9499
  devExt = (struct _DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 9500
  if (GuidIndex == 0UL) {
    goto switch_327_0;
  } else {
    goto switch_327_default;
#line 9505
    if (0) {
      switch_327_0: ;
#line 9507
      if (OutBufferSize < size) {
#line 9508
        status = -1073741789L;
        goto switch_327_break;
      } else {

      }
#line 9513
      *((struct _PARPORT_WMI_ALLOC_FREE_COUNTS *)Buffer) = devExt->WmiPortAllocFreeCounts;
#line 9514
      *InstanceLengthArray = size;
#line 9515
      status = 0L;
      goto switch_327_break;
      switch_327_default: 
#line 9518
      status = -1073741163L;
      goto switch_327_break;
    } else {
      switch_327_break: ;
    }
  }
  {
#line 9526
  status = WmiCompleteRequest(DeviceObject, Irp, status, size, (char)0);
  }
#line 9528
  return (status);
}
}
#line 9535
#pragma warning(push)
#line 9536
#pragma warning(disable:4035)
#line 9537
#pragma warning(pop)
#line 9539
#pragma warning(disable:4103)
#line 9540
#pragma warning(disable:4103)
#line 9541
#pragma warning(push)
#line 9542
#pragma warning(disable:4035)
#line 9543
#pragma warning(pop)
#line 9544
#pragma warning(disable:4035)
#line 9545
#pragma warning(push)
#line 9546
#pragma warning(disable:4164)
#line 9547
#pragma function(_enable)
#line 9548
#pragma function(_disable)
#line 9549
#pragma warning(pop)
#line 9550
#pragma warning(disable:4103)
#line 9551
#pragma warning(disable:4103)
#line 9552
#pragma warning(disable:4103)
#line 9553
#pragma warning(disable:4103)
#line 9554
#pragma warning(disable:4103)
#line 9555
#pragma warning(disable:4103)
#line 9556
#pragma warning(disable:4200)
#line 9557
#pragma warning(default:4200)
#line 9558 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void _BLAST_init(void) 
{ 

  {
#line 9562
  UNLOADED = 0;
#line 9563
  NP = 1;
#line 9564
  DC = 2;
#line 9565
  SKIP1 = 3;
#line 9566
  SKIP2 = 4;
#line 9567
  MPR1 = 5;
#line 9568
  MPR3 = 6;
#line 9569
  IPC = 7;
#line 9570
  s = UNLOADED;
#line 9571
  pended = 0;
#line 9572
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 9573
  compRegistered = 0;
#line 9574
  lowerDriverReturn = 0;
#line 9575
  setEventCalled = 0;
#line 9576
  customIrp = 0;
#line 9577
  return;
}
}
#line 9580 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
IRP *pirp  ;
#line 9581 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void stub_driver_init(void) 
{ 

  {
#line 9585
  s = NP;
#line 9586
  customIrp = 0;
#line 9587
  setEventCalled = customIrp;
#line 9588
  lowerDriverReturn = setEventCalled;
#line 9589
  compRegistered = lowerDriverReturn;
#line 9590
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 9591
  pended = (int )compFptr;
#line 9592
  return;
}
}
#line 9595 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
int main(void) 
{ DRIVER_OBJECT d ;
  NTSTATUS status ;
  int we_should_unload ;
  IRP irp ;
  int __BLAST_NONDET ;
  int irp_choice ;
  DEVICE_OBJECT devobj ;

  {
  {
#line 9606
  pirp = & irp;
#line 9607
  _BLAST_init();
  }
#line 9609
  if (status >= 0L) {
#line 9610
    s = NP;
#line 9611
    customIrp = 0;
#line 9612
    setEventCalled = customIrp;
#line 9613
    lowerDriverReturn = setEventCalled;
#line 9614
    compRegistered = lowerDriverReturn;
#line 9615
    compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 9616
    pended = (int )compFptr;
#line 9617
    pirp->IoStatus.__annonCompField4.Status = 0L;
#line 9618
    myStatus = 0;
#line 9619
    if (irp_choice == 0) {
#line 9620
      pirp->IoStatus.__annonCompField4.Status = -1073741637L;
#line 9621
      myStatus = -1073741637;
    } else {

    }
    {
#line 9626
    stub_driver_init();
    }
#line 9628
    if (! (status >= 0L)) {
#line 9629
      return (-1);
    } else {

    }
#line 9633
    if (__BLAST_NONDET == 0) {
      goto switch_328_0;
    } else {
#line 9636
      if (__BLAST_NONDET == 1) {
        goto switch_328_1;
      } else {
#line 9639
        if (__BLAST_NONDET == 3) {
          goto switch_328_3;
        } else {
#line 9642
          if (__BLAST_NONDET == 4) {
            goto switch_328_4;
          } else {
#line 9645
            if (__BLAST_NONDET == 5) {
              goto switch_328_5;
            } else {
#line 9648
              if (__BLAST_NONDET == 6) {
                goto switch_328_6;
              } else {
#line 9651
                if (__BLAST_NONDET == 8) {
                  goto switch_328_8;
                } else {
#line 9654
                  if (__BLAST_NONDET == 11) {
                    goto switch_328_11;
                  } else {
                    goto switch_328_default;
#line 9659
                    if (0) {
                      switch_328_0: 
                      {
#line 9662
                      status = PptDispatchCreate(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_1: 
                      {
#line 9667
                      status = PptDispatchClose(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_3: 
                      {
#line 9672
                      status = PptDispatchPnp(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_4: 
                      {
#line 9677
                      status = PptDispatchPower(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_5: 
                      {
#line 9682
                      status = PptDispatchCleanup(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_6: 
                      {
#line 9687
                      status = PptDispatchSystemControl(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_8: 
                      {
#line 9692
                      status = PptDispatchInternalDeviceControl(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_11: 
                      {
#line 9697
                      status = PptDispatchCleanup(& devobj, pirp);
                      }
                      goto switch_328_break;
                      switch_328_default: ;
#line 9701
                      return (-1);
                    } else {
                      switch_328_break: ;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 9714
    if (we_should_unload) {
      {
#line 9716
      PptUnload(& d);
      }
    } else {

    }
  } else {

  }
#line 9724
  if (pended == 1) {
#line 9725
    if (s == NP) {
#line 9726
      s = NP;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
#line 9732
    if (pended == 1) {
#line 9733
      if (s == MPR3) {
#line 9734
        s = MPR3;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 9740
      if (s == UNLOADED) {

      } else {
#line 9743
        if (status == -1L) {

        } else {
#line 9746
          if (s != SKIP2) {
#line 9747
            if (s != IPC) {
#line 9748
              if (s != DC) {
                {
#line 9750
                errorFn();
                }
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
#line 9760
            if (pended == 1) {
#line 9761
              if (status != 259L) {
                {
#line 9763
                errorFn();
                }
              } else {

              }
            } else {
#line 9769
              if (s == DC) {
#line 9770
                if (status == 259L) {
                  {
#line 9772
                  errorFn();
                  }
                } else {

                }
              } else {
#line 9778
                if (status != (long )lowerDriverReturn) {
                  {
#line 9780
                  errorFn();
                  }
                } else {

                }
              }
            }
          }
        }
      }
    }
  }
#line 9792
  return ((int )status);
}
}
#line 9795 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
char _SLAM_alloc_dummy  ;
#line 9796 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
char *qdpt_malloc(int i ) 
{ int __BLAST_NONDET ;

  {
#line 9800
  if (__BLAST_NONDET) {
#line 9801
    return ((char *)0);
  } else {
#line 9803
    return ((char *)1);
  }
}
}
#line 9808 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 9812
  return;
}
}
#line 9816 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 9820
  return;
}
}
#line 9826 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) 
{ PVOID x ;
  char *tmp ;

  {
  {
#line 9833
  tmp = qdpt_malloc((int )NumberOfBytes);
#line 9834
  x = (void *)tmp;
  }
#line 9836
  return (x);
}
}
#line 9840 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void ExFreePool(PVOID P ) 
{ 

  {
#line 9844
  return;
}
}
#line 9850 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 9856
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 9862 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 9868
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 9873 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) 
{ 

  {
#line 9878
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 9884 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 9890
  if (__BLAST_NONDET == 0) {
    goto switch_329_0;
  } else {
    goto switch_329_default;
#line 9895
    if (0) {
      switch_329_0: 
      {
#line 9898
      tmp = qdpt_malloc((int )sizeof(MDL ));
      }
#line 9900
      return ((struct _MDL *)((void *)tmp));
      switch_329_default: ;
#line 9902
      return ((struct _MDL *)((void *)0));
    } else {

    }
  }
}
}
#line 9912 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) 
{ int __BLAST_NONDET ;

  {
#line 9916
  if (__BLAST_NONDET == 0) {
    goto switch_330_0;
  } else {
    goto switch_330_default;
#line 9921
    if (0) {
      switch_330_0: ;
#line 9923
      return (TargetDevice);
      switch_330_default: ;
#line 9925
      return ((struct _DEVICE_OBJECT *)((void *)0));
    } else {

    }
  }
}
}
#line 9939 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 9946
  customIrp = 1;
#line 9947
  if (__BLAST_NONDET == 0) {
    goto switch_331_0;
  } else {
    goto switch_331_default;
#line 9952
    if (0) {
      switch_331_0: 
      {
#line 9955
      tmp = qdpt_malloc((int )sizeof(IRP ));
      }
#line 9957
      return ((struct _IRP *)((void *)tmp));
      switch_331_default: ;
#line 9959
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 9976 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 9984
  customIrp = 1;
#line 9985
  if (__BLAST_NONDET == 0) {
    goto switch_332_0;
  } else {
    goto switch_332_default;
#line 9990
    if (0) {
      switch_332_0: 
      {
#line 9993
      tmp = qdpt_malloc((int )sizeof(IRP ));
      }
#line 9995
      return ((struct _IRP *)((void *)tmp));
      switch_332_default: ;
#line 9997
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 10010 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 10017
  if (__BLAST_NONDET == 0) {
    goto switch_333_0;
  } else {
    goto switch_333_default;
#line 10022
    if (0) {
      switch_333_0: 
      {
#line 10025
      tmp = qdpt_malloc((int )sizeof(DEVICE_OBJECT ));
#line 10026
      *DeviceObject = (struct _DEVICE_OBJECT *)((void *)tmp);
      }
#line 10028
      return (0L);
      switch_333_default: ;
#line 10030
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10040 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) 
{ int __BLAST_NONDET ;

  {
#line 10044
  if (__BLAST_NONDET == 0) {
    goto switch_334_0;
  } else {
    goto switch_334_default;
#line 10049
    if (0) {
      switch_334_0: ;
#line 10051
      return (0L);
      switch_334_default: ;
#line 10053
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10062 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 10066
  return;
}
}
#line 10070 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 10074
  if (__BLAST_NONDET == 0) {
    goto switch_335_0;
  } else {
    goto switch_335_default;
#line 10079
    if (0) {
      switch_335_0: ;
#line 10081
      return (0L);
      switch_335_default: ;
#line 10083
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10092 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) 
{ 

  {
#line 10096
  return;
}
}
#line 10100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoFreeIrp(PIRP Irp ) 
{ 

  {
#line 10104
  return;
}
}
#line 10108 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoFreeMdl(PMDL Mdl ) 
{ 

  {
#line 10112
  return;
}
}
#line 10116 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) 
{ char *tmp ;

  {
  {
#line 10121
  tmp = qdpt_malloc((int )sizeof(CONFIGURATION_INFORMATION ));
  }
#line 10123
  return ((struct _CONFIGURATION_INFORMATION *)((void *)tmp));
}
}
#line 10144 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) 
{ int __BLAST_NONDET ;

  {
#line 10161
  if (__BLAST_NONDET == 0) {
    goto switch_336_0;
  } else {
    goto switch_336_default;
#line 10166
    if (0) {
      switch_336_0: ;
#line 10168
      return (0L);
      switch_336_default: ;
#line 10170
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10182 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 10189
  if (__BLAST_NONDET == 0) {
    goto switch_337_0;
  } else {
    goto switch_337_default;
#line 10194
    if (0) {
      switch_337_0: ;
#line 10196
      return (0L);
      switch_337_default: ;
#line 10198
      return (-1073741808L);
    } else {

    }
  }
}
}
#line 10207 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoReleaseCancelSpinLock(KIRQL Irql ) 
{ 

  {
#line 10211
  return;
}
}
#line 10216 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) 
{ int __BLAST_NONDET ;

  {
#line 10220
  if (__BLAST_NONDET == 0) {
    goto switch_338_0;
  } else {
    goto switch_338_default;
#line 10225
    if (0) {
      switch_338_0: ;
#line 10227
      return (0L);
      switch_338_default: ;
#line 10229
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10238 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 10242
  return;
}
}
#line 10245 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void stubMoreProcessingRequired(void) 
{ 

  {
#line 10249
  if (s == NP) {
#line 10250
    s = MPR1;
  } else {
    {
#line 10253
    errorFn();
    }
  }
#line 10256
  return;
}
}
#line 10261 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  NTSTATUS returnVal2 ;
  int compRetStatus ;
  PVOID lcontext ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 10271
  if (compRegistered) {
#line 10272
    if (routine == 0) {
      {
#line 10274
      tmp = PptSynchCompletionRoutine(DeviceObject, Irp, (struct _KEVENT *)lcontext);
#line 10275
      compRetStatus = (int )tmp;
      }
    } else {
#line 10278
      if (routine == 1) {
        {
#line 10280
        tmp___0 = PptPowerComplete(DeviceObject, Irp, (struct _DEVICE_EXTENSION *)lcontext);
#line 10281
        compRetStatus = (int )tmp___0;
        }
      } else {

      }
    }
#line 10287
    if ((long )compRetStatus == -1073741802L) {
      {
#line 10289
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 10297
  if (__BLAST_NONDET == 0) {
    goto switch_339_0;
  } else {
#line 10300
    if (__BLAST_NONDET == 1) {
      goto switch_339_1;
    } else {
      goto switch_339_default;
#line 10305
      if (0) {
        switch_339_0: 
#line 10307
        returnVal2 = 0L;
        goto switch_339_break;
        switch_339_1: 
#line 10310
        returnVal2 = -1073741823L;
        goto switch_339_break;
        switch_339_default: 
#line 10313
        returnVal2 = 259L;
        goto switch_339_break;
      } else {
        switch_339_break: ;
      }
    }
  }
#line 10321
  if (s == NP) {
#line 10322
    s = IPC;
#line 10323
    lowerDriverReturn = (int )returnVal2;
  } else {
#line 10325
    if (s == MPR1) {
#line 10326
      if (returnVal2 == 259L) {
#line 10327
        s = MPR3;
#line 10328
        lowerDriverReturn = (int )returnVal2;
      } else {
#line 10330
        s = NP;
#line 10331
        lowerDriverReturn = (int )returnVal2;
      }
    } else {
#line 10334
      if (s == SKIP1) {
#line 10335
        s = SKIP2;
#line 10336
        lowerDriverReturn = (int )returnVal2;
      } else {
        {
#line 10339
        errorFn();
        }
      }
    }
  }
#line 10344
  return (returnVal2);
}
}
#line 10349 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
#line 10353
  if (s == NP) {
#line 10354
    s = DC;
  } else {
    {
#line 10357
    errorFn();
    }
  }
#line 10360
  return;
}
}
#line 10363
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) ;
#line 10364 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 10368
  return ((unsigned char)0);
}
}
#line 10374 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) 
{ int __BLAST_NONDET ;

  {
#line 10378
  if (__BLAST_NONDET == 0) {
    goto switch_340_0;
  } else {
    goto switch_340_default;
#line 10383
    if (0) {
      switch_340_0: ;
#line 10385
      return (0L);
      switch_340_default: ;
#line 10387
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10397 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) 
{ 

  {
#line 10401
  return;
}
}
#line 10406 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) 
{ 

  {
#line 10410
  return;
}
}
#line 10414 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 10418
  return;
}
}
#line 10423 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) 
{ LONG r ;

  {
#line 10428
  return (r);
}
}
#line 10433 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) 
{ 

  {
#line 10437
  return;
}
}
#line 10442 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) 
{ LONG l ;

  {
#line 10446
  setEventCalled = 1;
#line 10447
  return (l);
}
}
#line 10454 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) 
{ int __BLAST_NONDET ;

  {
#line 10459
  if (s == MPR3) {
#line 10460
    if (setEventCalled == 1) {
#line 10461
      s = NP;
#line 10462
      setEventCalled = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 10468
    if (customIrp == 1) {
#line 10469
      s = NP;
#line 10470
      customIrp = 0;
    } else {
#line 10472
      if (s == MPR3) {
        {
#line 10474
        errorFn();
        }
      } else {

      }
    }
  }
#line 10481
  if (__BLAST_NONDET == 0) {
    goto switch_341_0;
  } else {
    goto switch_341_default;
#line 10486
    if (0) {
      switch_341_0: ;
#line 10488
      return (0L);
      switch_341_default: ;
#line 10490
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10500 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 10505
  if (__BLAST_NONDET == 0) {
    goto switch_342_0;
  } else {
#line 10508
    if (__BLAST_NONDET == 1) {
      goto switch_342_1;
    } else {
#line 10511
      if (0) {
        switch_342_0: 
        {
#line 10514
        tmp = qdpt_malloc((int )NumberOfBytes);
        }
#line 10516
        return ((void *)tmp);
        switch_342_1: ;
#line 10518
        return ((void *)0);
      } else {

      }
    }
  }
#line 10524
  return ((void *)0);
}
}
#line 10528 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void MmFreeContiguousMemory(PVOID BaseAddress ) 
{ 

  {
#line 10532
  return;
}
}
#line 10541 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) 
{ 

  {
#line 10547
  return ((void *)0);
}
}
#line 10551 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) 
{ 

  {
#line 10555
  return ((void *)0);
}
}
#line 10559 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void MmResetDriverPaging(PVOID AddressWithinSection ) 
{ 

  {
#line 10563
  return;
}
}
#line 10567 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void MmUnlockPages(PMDL MemoryDescriptorList ) 
{ 

  {
#line 10571
  return;
}
}
#line 10580 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) 
{ int __BLAST_NONDET ;

  {
#line 10585
  if (__BLAST_NONDET == 0) {
    goto switch_343_0;
  } else {
    goto switch_343_default;
#line 10590
    if (0) {
      switch_343_0: ;
#line 10592
      return (0L);
      switch_343_default: ;
#line 10594
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10603 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void ObfDereferenceObject(PVOID Object ) 
{ 

  {
#line 10607
  return;
}
}
#line 10612 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 10621
  if (compRegistered) {
#line 10622
    if (routine == 0) {
      {
#line 10624
      tmp = PptSynchCompletionRoutine(DeviceObject, Irp, (struct _KEVENT *)lcontext);
#line 10625
      compRetStatus = (int )tmp;
      }
    } else {
#line 10628
      if (routine == 1) {
        {
#line 10630
        tmp___0 = PptPowerComplete(DeviceObject, Irp, (struct _DEVICE_EXTENSION *)lcontext);
#line 10631
        compRetStatus = (int )tmp___0;
        }
      } else {

      }
    }
#line 10637
    if ((long )compRetStatus == -1073741802L) {
      {
#line 10639
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 10647
  if (__BLAST_NONDET == 0) {
    goto switch_344_0;
  } else {
#line 10650
    if (__BLAST_NONDET == 1) {
      goto switch_344_1;
    } else {
      goto switch_344_default;
#line 10655
      if (0) {
        switch_344_0: 
#line 10657
        returnVal = 0L;
        goto switch_344_break;
        switch_344_1: 
#line 10660
        returnVal = -1073741823L;
        goto switch_344_break;
        switch_344_default: 
#line 10663
        returnVal = 259L;
        goto switch_344_break;
      } else {
        switch_344_break: ;
      }
    }
  }
#line 10671
  if (s == NP) {
#line 10672
    s = IPC;
#line 10673
    lowerDriverReturn = (int )returnVal;
  } else {
#line 10675
    if (s == MPR1) {
#line 10676
      if (returnVal == 259L) {
#line 10677
        s = MPR3;
#line 10678
        lowerDriverReturn = (int )returnVal;
      } else {
#line 10680
        s = NP;
#line 10681
        lowerDriverReturn = (int )returnVal;
      }
    } else {
#line 10684
      if (s == SKIP1) {
#line 10685
        s = SKIP2;
#line 10686
        lowerDriverReturn = (int )returnVal;
      } else {
        {
#line 10689
        errorFn();
        }
      }
    }
  }
#line 10694
  return (returnVal);
}
}
#line 10698 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void PoStartNextPowerIrp(PIRP Irp ) 
{ 

  {
#line 10702
  return;
}
}
#line 10712 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) 
{ int __BLAST_NONDET ;

  {
#line 10718
  if (__BLAST_NONDET == 0) {
    goto switch_345_0;
  } else {
    goto switch_345_default;
#line 10723
    if (0) {
      switch_345_0: ;
#line 10725
      return (0L);
      switch_345_default: ;
#line 10727
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10736 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) 
{ int __BLAST_NONDET ;

  {
#line 10740
  if (__BLAST_NONDET == 0) {
    goto switch_346_0;
  } else {
    goto switch_346_default;
#line 10745
    if (0) {
      switch_346_0: ;
#line 10747
      return (0L);
      switch_346_default: ;
#line 10749
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10760 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) 
{ int __BLAST_NONDET ;

  {
#line 10766
  if (__BLAST_NONDET == 0) {
    goto switch_347_0;
  } else {
    goto switch_347_default;
#line 10771
    if (0) {
      switch_347_0: ;
#line 10773
      return (0L);
      switch_347_default: ;
#line 10775
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10786 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) 
{ SIZE_T r ;

  {
#line 10791
  return (r);
}
}
#line 10796 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) 
{ 

  {
#line 10801
  return;
}
}
#line 10807 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) 
{ int __BLAST_NONDET ;

  {
#line 10812
  if (__BLAST_NONDET == 0) {
    goto switch_348_0;
  } else {
    goto switch_348_default;
#line 10817
    if (0) {
      switch_348_0: ;
#line 10819
      return (0L);
      switch_348_default: ;
#line 10821
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10830 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) 
{ 

  {
#line 10834
  return;
}
}
#line 10839 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) 
{ 

  {
#line 10843
  return;
}
}
#line 10848 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) 
{ 

  {
#line 10853
  return;
}
}
#line 10861 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) 
{ int __BLAST_NONDET ;

  {
#line 10867
  if (__BLAST_NONDET == 0) {
    goto switch_349_0;
  } else {
    goto switch_349_default;
#line 10872
    if (0) {
      switch_349_0: ;
#line 10874
      return (0L);
      switch_349_default: ;
#line 10876
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10885 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS ZwClose(HANDLE Handle ) 
{ int __BLAST_NONDET ;

  {
#line 10889
  if (__BLAST_NONDET == 0) {
    goto switch_350_0;
  } else {
    goto switch_350_default;
#line 10894
    if (0) {
      switch_350_0: ;
#line 10896
      return (0L);
      switch_350_default: ;
#line 10898
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10906 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS WmiSystemControl(PWMILIB_CONTEXT WmiLibInfo , PDEVICE_OBJECT DeviceObject ,
                          PIRP Irp , PSYSCTL_IRP_DISPOSITION IrpDisposition ) 
{ int __BLAST_NONDET ;

  {
#line 10911
  if (__BLAST_NONDET == 0) {
    goto switch_351_0;
  } else {
    goto switch_351_default;
#line 10916
    if (0) {
      switch_351_0: 
#line 10918
      return (0L);
      switch_351_default: ;
#line 10920
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 10933 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/parport/parport.i.cil.c"
NTSTATUS IoAcquireRemoveLockEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag , PCSTR File ,
                               ULONG Line , ULONG RemlockSize ) 
{ int __BLAST_NONDET ;

  {
#line 10939
  if (__BLAST_NONDET) {
#line 10940
    return (0L);
  } else {
#line 10942
    return (-1073741738L);
  }
}
}
