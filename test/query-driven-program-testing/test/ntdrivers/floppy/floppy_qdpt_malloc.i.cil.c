/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 4 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
#pragma pack(push,8)
#line 5 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned int size_t;
#line 6 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned short wchar_t;
#line 7
#pragma pack(pop)
#line 8
#pragma pack(push,8)
#line 9
#pragma pack(pop)
#line 10 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned long ULONG_PTR;
#line 11 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned long *PULONG_PTR;
#line 12 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG_PTR SIZE_T;
#line 13 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef void *PVOID;
#line 14 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef char CHAR;
#line 15 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef short SHORT;
#line 16 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef long LONG;
#line 17 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef wchar_t WCHAR;
#line 18 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef WCHAR *PWSTR;
#line 19 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef WCHAR const   *PCWSTR;
#line 20 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef CHAR *PCHAR;
#line 21 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef LONG *PLONG;
#line 22 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned char UCHAR;
#line 23 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned short USHORT;
#line 24 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef unsigned long ULONG;
#line 25 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef UCHAR *PUCHAR;
#line 26 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG *PULONG;
#line 27 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef void *HANDLE;
#line 28 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef HANDLE *PHANDLE;
#line 29 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef char CCHAR;
#line 30 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef short CSHORT;
#line 31 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG LCID;
#line 32 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef LONG NTSTATUS;
#line 33 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef long long LONGLONG;
#line 34 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct____missing_field_name_1 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 38 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_u_2 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 42 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union _LARGE_INTEGER {
   struct __anonstruct____missing_field_name_1 __annonCompField1 ;
   struct __anonstruct_u_2 u ;
   LONGLONG QuadPart ;
};
#line 47 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef union _LARGE_INTEGER LARGE_INTEGER;
#line 48 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef LARGE_INTEGER *PLARGE_INTEGER;
#line 49 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _LUID {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 53 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _LUID LUID;
#line 54 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
#line 55
enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1
} ;
#line 59 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _EVENT_TYPE EVENT_TYPE;
#line 60 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef char const   *PCSZ;
#line 61 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PCHAR Buffer ;
};
#line 66 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _STRING STRING;
#line 67 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef STRING *PSTRING;
#line 68 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef PSTRING PANSI_STRING;
#line 69 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _UNICODE_STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PWSTR Buffer ;
};
#line 74 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _UNICODE_STRING UNICODE_STRING;
#line 75 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef UNICODE_STRING *PUNICODE_STRING;
#line 76 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef UCHAR BOOLEAN;
#line 77 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink ;
   struct _LIST_ENTRY *Blink ;
};
#line 81 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _LIST_ENTRY LIST_ENTRY;
#line 82 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _LIST_ENTRY *PLIST_ENTRY;
#line 83 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _OBJECT_ATTRIBUTES {
   ULONG Length ;
   HANDLE RootDirectory ;
   PUNICODE_STRING ObjectName ;
   ULONG Attributes ;
   PVOID SecurityDescriptor ;
   PVOID SecurityQualityOfService ;
};
#line 91 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
#line 92 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#line 93 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _GUID {
   unsigned long Data1 ;
   unsigned short Data2 ;
   unsigned short Data3 ;
   unsigned char Data4[8] ;
};
#line 99 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _GUID GUID;
#line 100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef UCHAR KIRQL;
#line 101
enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt = 2,
    NtProductServer = 3
} ;
#line 106 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _NT_PRODUCT_TYPE NT_PRODUCT_TYPE;
#line 107
struct _KTHREAD;
#line 107
struct _KTHREAD;
#line 108 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KTHREAD *PKTHREAD;
#line 109
struct _ETHREAD;
#line 109
struct _ETHREAD;
#line 110 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _ETHREAD *PETHREAD;
#line 111
struct _EPROCESS;
#line 111
struct _EPROCESS;
#line 112 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _EPROCESS *PEPROCESS;
#line 113
struct _IO_TIMER;
#line 113
struct _IO_TIMER;
#line 114 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_TIMER *PIO_TIMER;
#line 115
struct _OBJECT_TYPE;
#line 115
struct _OBJECT_TYPE;
#line 116 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
#line 117 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef CCHAR KPROCESSOR_MODE;
#line 118
struct _KAPC;
#line 118
struct _KAPC;
#line 119
struct _KAPC;
#line 120 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 );
#line 121 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KAPC {
   CSHORT Type ;
   CSHORT Size ;
   ULONG Spare0 ;
   struct _KTHREAD *Thread ;
   LIST_ENTRY ApcListEntry ;
   void (*KernelRoutine)(struct _KAPC *Apc , PKNORMAL_ROUTINE *NormalRoutine , PVOID *NormalContext ,
                         PVOID *SystemArgument1 , PVOID *SystemArgument2 ) ;
   void (*RundownRoutine)(struct _KAPC *Apc ) ;
   void (*NormalRoutine)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
   PVOID NormalContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   CCHAR ApcStateIndex ;
   KPROCESSOR_MODE ApcMode ;
   BOOLEAN Inserted ;
};
#line 138 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KAPC KAPC;
#line 139
struct _KDPC;
#line 139
struct _KDPC;
#line 140
struct _KDPC;
#line 141 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KDPC {
   CSHORT Type ;
   UCHAR Number ;
   UCHAR Importance ;
   LIST_ENTRY DpcListEntry ;
   void (*DeferredRoutine)(struct _KDPC *Dpc , PVOID DeferredContext , PVOID SystemArgument1 ,
                           PVOID SystemArgument2 ) ;
   PVOID DeferredContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   PULONG_PTR Lock ;
};
#line 153 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KDPC KDPC;
#line 154 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KDPC *PKDPC;
#line 155 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _MDL {
   struct _MDL *Next ;
   CSHORT Size ;
   CSHORT MdlFlags ;
   struct _EPROCESS *Process ;
   PVOID MappedSystemVa ;
   PVOID StartVa ;
   ULONG ByteCount ;
   ULONG ByteOffset ;
};
#line 166 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MDL *PMDL;
#line 167 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef PVOID PACCESS_TOKEN;
#line 168 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef PVOID PSECURITY_DESCRIPTOR;
#line 169 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG ACCESS_MASK;
#line 170
#pragma pack(push,4)
#line 171 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _LUID_AND_ATTRIBUTES {
   LUID Luid ;
   ULONG Attributes ;
};
#line 175 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#line 176
#pragma pack(pop)
#line 177 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[1] ;
};
#line 182 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
#line 183
enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3
} ;
#line 189 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
#line 190 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
#line 191 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _SECURITY_QUALITY_OF_SERVICE {
   ULONG Length ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
   BOOLEAN EffectiveOnly ;
};
#line 197 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
#line 198 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG SECURITY_INFORMATION;
#line 199 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef LONG KPRIORITY;
#line 200 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG_PTR KSPIN_LOCK;
#line 201 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef KSPIN_LOCK *PKSPIN_LOCK;
#line 202 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _RTL_QUERY_REGISTRY_TABLE {
   NTSTATUS (*QueryRoutine)(PWSTR ValueName , ULONG ValueType , PVOID ValueData ,
                            ULONG ValueLength , PVOID Context , PVOID EntryContext ) ;
   ULONG Flags ;
   PWSTR Name ;
   PVOID EntryContext ;
   ULONG DefaultType ;
   PVOID DefaultData ;
   ULONG DefaultLength ;
};
#line 213 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
#line 214 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
#line 215 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_6 {
   NTSTATUS Status ;
   PVOID Pointer ;
};
#line 219 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_STATUS_BLOCK {
   union __anonunion____missing_field_name_6 __annonCompField4 ;
   ULONG_PTR Information ;
};
#line 223 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
#line 224 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
#line 225
enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileMaximumInformation = 37
} ;
#line 264 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
#line 265 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   ULONG FileAttributes ;
};
#line 272 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
#line 273 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FILE_STANDARD_INFORMATION {
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG NumberOfLinks ;
   BOOLEAN DeletePending ;
   BOOLEAN Directory ;
};
#line 280 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
#line 281 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG FileAttributes ;
};
#line 290 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
#line 291
enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsMaximumInformation = 9
} ;
#line 302 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
#line 303
enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    MaximumInterfaceType = 16
} ;
#line 323 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
#line 324 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
#line 325 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KEY_VALUE_FULL_INFORMATION {
   ULONG TitleIndex ;
   ULONG Type ;
   ULONG DataOffset ;
   ULONG DataLength ;
   ULONG NameLength ;
   WCHAR Name[1] ;
};
#line 333 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
#line 334 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CLIENT_ID {
   HANDLE UniqueProcess ;
   HANDLE UniqueThread ;
};
#line 338 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CLIENT_ID CLIENT_ID;
#line 339 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef CLIENT_ID *PCLIENT_ID;
#line 340
enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} ;
#line 350 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
#line 351
enum __anonenum_POWER_ACTION_11 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7
} ;
#line 361 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
#line 362
enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5
} ;
#line 370 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
#line 371 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union _POWER_STATE {
   SYSTEM_POWER_STATE SystemState ;
   DEVICE_POWER_STATE DeviceState ;
};
#line 375 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef union _POWER_STATE POWER_STATE;
#line 376
enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1
} ;
#line 380 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
#line 381 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KSYSTEM_TIME {
   ULONG LowPart ;
   LONG High1Time ;
   LONG High2Time ;
};
#line 386 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KSYSTEM_TIME KSYSTEM_TIME;
#line 387
enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign = 0,
    NEC98x86 = 1,
    EndAlternatives = 2
} ;
#line 392 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ALTERNATIVE_ARCHITECTURE_TYPE;
#line 393 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KUSER_SHARED_DATA {
   ULONG volatile   TickCountLow ;
   ULONG TickCountMultiplier ;
   KSYSTEM_TIME volatile   InterruptTime ;
   KSYSTEM_TIME volatile   SystemTime ;
   KSYSTEM_TIME volatile   TimeZoneBias ;
   USHORT ImageNumberLow ;
   USHORT ImageNumberHigh ;
   WCHAR NtSystemRoot[260] ;
   ULONG MaxStackTraceDepth ;
   ULONG CryptoExponent ;
   ULONG TimeZoneId ;
   ULONG Reserved2[8] ;
   NT_PRODUCT_TYPE NtProductType ;
   BOOLEAN ProductTypeIsValid ;
   ULONG NtMajorVersion ;
   ULONG NtMinorVersion ;
   BOOLEAN ProcessorFeatures[64] ;
   ULONG Reserved1 ;
   ULONG Reserved3 ;
   ULONG volatile   TimeSlip ;
   ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
   LARGE_INTEGER SystemExpirationDate ;
   ULONG SuiteMask ;
   BOOLEAN KdDebuggerEnabled ;
};
#line 419 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KUSER_SHARED_DATA KUSER_SHARED_DATA;
#line 420 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef PVOID PASSIGNED_RESOURCE;
#line 421
#pragma pack(push,4)
#line 422 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Generic_16 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 426 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Port_17 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 430 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Interrupt_18 {
   ULONG Level ;
   ULONG Vector ;
   ULONG Affinity ;
};
#line 435 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Memory_19 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 439 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Dma_20 {
   ULONG Channel ;
   ULONG Port ;
   ULONG Reserved1 ;
};
#line 444 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_DevicePrivate_21 {
   ULONG Data[3] ;
};
#line 447 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_BusNumber_22 {
   ULONG Start ;
   ULONG Length ;
   ULONG Reserved ;
};
#line 452 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_DeviceSpecificData_23 {
   ULONG DataSize ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 457 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_u_15 {
   struct __anonstruct_Generic_16 Generic ;
   struct __anonstruct_Port_17 Port ;
   struct __anonstruct_Interrupt_18 Interrupt ;
   struct __anonstruct_Memory_19 Memory ;
   struct __anonstruct_Dma_20 Dma ;
   struct __anonstruct_DevicePrivate_21 DevicePrivate ;
   struct __anonstruct_BusNumber_22 BusNumber ;
   struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData ;
};
#line 467 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
   UCHAR Type ;
   UCHAR ShareDisposition ;
   USHORT Flags ;
   union __anonunion_u_15 u ;
};
#line 473 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 474 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 475
#pragma pack(pop)
#line 476 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CM_PARTIAL_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
};
#line 482 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
#line 483 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CM_FULL_RESOURCE_DESCRIPTOR {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
};
#line 488 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
#line 489 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR *PCM_FULL_RESOURCE_DESCRIPTOR;
#line 490 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CM_RESOURCE_LIST {
   ULONG Count ;
   CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
};
#line 494 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#line 495
#pragma pack(push,1)
#line 496
#pragma pack(pop)
#line 497 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CM_FLOPPY_DEVICE_DATA {
   USHORT Version ;
   USHORT Revision ;
   CHAR Size[8] ;
   ULONG MaxDensity ;
   ULONG MountDensity ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   UCHAR SectorPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR DataTransferLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   UCHAR MotorSettleTime ;
   UCHAR MaximumTrackValue ;
   UCHAR DataTransferRate ;
};
#line 517 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CM_FLOPPY_DEVICE_DATA *PCM_FLOPPY_DEVICE_DATA;
#line 518 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Port_25 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 524 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Memory_26 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 530 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Interrupt_27 {
   ULONG MinimumVector ;
   ULONG MaximumVector ;
};
#line 534 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Dma_28 {
   ULONG MinimumChannel ;
   ULONG MaximumChannel ;
};
#line 538 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Generic_29 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 544 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_DevicePrivate_30 {
   ULONG Data[3] ;
};
#line 547 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_BusNumber_31 {
   ULONG Length ;
   ULONG MinBusNumber ;
   ULONG MaxBusNumber ;
   ULONG Reserved ;
};
#line 553 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_AssignedResource_32 {
   PASSIGNED_RESOURCE AssignedResource ;
};
#line 556 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_SubAllocateFrom_33 {
   UCHAR Type ;
   UCHAR Reserved[3] ;
   PASSIGNED_RESOURCE AssignedResource ;
   PHYSICAL_ADDRESS Transformation ;
};
#line 562 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_ConfigData_34 {
   ULONG Priority ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 567 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_u_24 {
   struct __anonstruct_Port_25 Port ;
   struct __anonstruct_Memory_26 Memory ;
   struct __anonstruct_Interrupt_27 Interrupt ;
   struct __anonstruct_Dma_28 Dma ;
   struct __anonstruct_Generic_29 Generic ;
   struct __anonstruct_DevicePrivate_30 DevicePrivate ;
   struct __anonstruct_BusNumber_31 BusNumber ;
   struct __anonstruct_AssignedResource_32 AssignedResource ;
   struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom ;
   struct __anonstruct_ConfigData_34 ConfigData ;
};
#line 579 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_RESOURCE_DESCRIPTOR {
   UCHAR Option ;
   UCHAR Type ;
   UCHAR ShareDisposition ;
   UCHAR Spare1 ;
   USHORT Flags ;
   USHORT Spare2 ;
   union __anonunion_u_24 u ;
};
#line 588 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
#line 589 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
};
#line 595 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
#line 596 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_RESOURCE_REQUIREMENTS_LIST {
   ULONG ListSize ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG SlotNumber ;
   ULONG Reserved[3] ;
   ULONG AlternativeLists ;
   IO_RESOURCE_LIST List[1] ;
};
#line 605 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
#line 606
enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    MaximumType = 40
} ;
#line 649 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
#line 650 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
#line 651
enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    Spare6 = 25,
    WrKernel = 26,
    MaximumWaitReason = 27
} ;
#line 681 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _KWAIT_REASON KWAIT_REASON;
#line 682 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DISPATCHER_HEADER {
   UCHAR Type ;
   UCHAR Absolute ;
   UCHAR Size ;
   UCHAR Inserted ;
   LONG SignalState ;
   LIST_ENTRY WaitListHead ;
};
#line 690 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
#line 691 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KDEVICE_QUEUE {
   CSHORT Type ;
   CSHORT Size ;
   LIST_ENTRY DeviceListHead ;
   KSPIN_LOCK Lock ;
   BOOLEAN Busy ;
};
#line 698 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
#line 699 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KDEVICE_QUEUE_ENTRY {
   LIST_ENTRY DeviceListEntry ;
   ULONG SortKey ;
   BOOLEAN Inserted ;
};
#line 704 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
#line 705 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KEVENT {
   DISPATCHER_HEADER Header ;
};
#line 708 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KEVENT KEVENT;
#line 709 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KEVENT *PKEVENT;
#line 710 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KEVENT *PRKEVENT;
#line 711 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _KSEMAPHORE {
   DISPATCHER_HEADER Header ;
   LONG Limit ;
};
#line 715 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KSEMAPHORE KSEMAPHORE;
#line 716 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KSEMAPHORE *PKSEMAPHORE;
#line 717 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
#line 718
enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6
} ;
#line 727 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
#line 728
enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38
} ;
#line 745 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _POOL_TYPE POOL_TYPE;
#line 746 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FAST_MUTEX {
   LONG Count ;
   PKTHREAD Owner ;
   ULONG Contention ;
   KEVENT Event ;
   ULONG OldIrql ;
};
#line 753 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FAST_MUTEX FAST_MUTEX;
#line 754 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FAST_MUTEX *PFAST_MUTEX;
#line 755 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef ULONG_PTR ERESOURCE_THREAD;
#line 756 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_38 {
   LONG OwnerCount ;
   ULONG TableSize ;
};
#line 760 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _OWNER_ENTRY {
   ERESOURCE_THREAD OwnerThread ;
   union __anonunion____missing_field_name_38 __annonCompField10 ;
};
#line 764 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _OWNER_ENTRY OWNER_ENTRY;
#line 765 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
#line 766 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_39 {
   PVOID Address ;
   ULONG_PTR CreatorBackTraceIndex ;
};
#line 770 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _ERESOURCE {
   LIST_ENTRY SystemResourcesList ;
   POWNER_ENTRY OwnerTable ;
   SHORT ActiveCount ;
   USHORT Flag ;
   PKSEMAPHORE SharedWaiters ;
   PKEVENT ExclusiveWaiters ;
   OWNER_ENTRY OwnerThreads[2] ;
   ULONG ContentionCount ;
   USHORT NumberOfSharedWaiters ;
   USHORT NumberOfExclusiveWaiters ;
   union __anonunion____missing_field_name_39 __annonCompField11 ;
   KSPIN_LOCK SpinLock ;
};
#line 784
enum _LOCK_OPERATION {
    IoReadAccess = 0,
    IoWriteAccess = 1,
    IoModifyAccess = 2
} ;
#line 789 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _LOCK_OPERATION LOCK_OPERATION;
#line 790
enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32
} ;
#line 795 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
#line 796
struct _DRIVER_OBJECT;
#line 796
struct _DRIVER_OBJECT;
#line 797
struct _DRIVER_OBJECT;
#line 798 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _SECURITY_SUBJECT_CONTEXT {
   PACCESS_TOKEN ClientToken ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   PACCESS_TOKEN PrimaryToken ;
   PVOID ProcessAuditId ;
};
#line 804 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
#line 805 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _INITIAL_PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[3] ;
};
#line 810 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
#line 811 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_Privileges_40 {
   INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
   PRIVILEGE_SET PrivilegeSet ;
};
#line 815 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _ACCESS_STATE {
   LUID OperationID ;
   BOOLEAN SecurityEvaluated ;
   BOOLEAN GenerateAudit ;
   BOOLEAN GenerateOnClose ;
   BOOLEAN PrivilegesAllocated ;
   ULONG Flags ;
   ACCESS_MASK RemainingDesiredAccess ;
   ACCESS_MASK PreviouslyGrantedAccess ;
   ACCESS_MASK OriginalDesiredAccess ;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   PVOID AuxData ;
   union __anonunion_Privileges_40 Privileges ;
   BOOLEAN AuditPrivileges ;
   UNICODE_STRING ObjectName ;
   UNICODE_STRING ObjectTypeName ;
};
#line 833 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _ACCESS_STATE *PACCESS_STATE;
#line 834
struct _DEVICE_OBJECT;
#line 834
struct _DEVICE_OBJECT;
#line 835
struct _DEVICE_OBJECT;
#line 836
struct _DRIVER_OBJECT;
#line 837
struct _FILE_OBJECT;
#line 837
struct _FILE_OBJECT;
#line 838
struct _FILE_OBJECT;
#line 839
struct _IRP;
#line 839
struct _IRP;
#line 840
struct _IRP;
#line 841
struct _SCSI_REQUEST_BLOCK;
#line 841
struct _SCSI_REQUEST_BLOCK;
#line 842
struct _SCSI_REQUEST_BLOCK;
#line 843 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp );
#line 844
struct _COMPRESSED_DATA_INFO;
#line 844
struct _COMPRESSED_DATA_INFO;
#line 845 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FAST_IO_DISPATCH {
   ULONG SizeOfFastIoDispatch ;
   BOOLEAN (*FastIoCheckIfPossible)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , BOOLEAN Wait , ULONG LockKey ,
                                    BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK IoStatus ,
                                    struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                         PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                          ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                          PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryBasicInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                   PFILE_BASIC_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                   struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryStandardInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                      PFILE_STANDARD_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoLock)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                         BOOLEAN FailImmediately , BOOLEAN ExclusiveLock , PIO_STATUS_BLOCK IoStatus ,
                         struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockSingle)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                 PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                                 PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAll)(struct _FILE_OBJECT *FileObject , PEPROCESS ProcessId ,
                              PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAllByKey)(struct _FILE_OBJECT *FileObject , PVOID ProcessId ,
                                   ULONG Key , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoDeviceControl)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                  PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                  ULONG OutputBufferLength , ULONG IoControlCode ,
                                  PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice , struct _DEVICE_OBJECT *TargetDevice ) ;
   BOOLEAN (*FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                         struct _FILE_NETWORK_OPEN_INFORMATION *Buffer ,
                                         struct _IO_STATUS_BLOCK *IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForModWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER EndingOffset ,
                                  struct _ERESOURCE **ResourceToRelease , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                      ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadComplete)(struct _FILE_OBJECT *FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*PrepareMdlWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                              ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteComplete)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                               PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoReadCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                   ULONG Length , ULONG LockKey , PVOID Buffer , PMDL *MdlChain ,
                                   PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                   ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWriteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , ULONG LockKey , PVOID Buffer ,
                                    PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                    ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadCompleteCompressed)(struct _FILE_OBJECT *FileObject , PMDL MdlChain ,
                                        struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteCompleteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                         PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryOpen)(struct _IRP *Irp , PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForModWrite)(struct _FILE_OBJECT *FileObject , struct _ERESOURCE *ResourceToRelease ,
                                  struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
};
#line 914 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
#line 915
enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3
} ;
#line 920 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
#line 921 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_SECURITY_CONTEXT {
   PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
   PACCESS_STATE AccessState ;
   ACCESS_MASK DesiredAccess ;
   ULONG FullCreateOptions ;
};
#line 927 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
#line 928 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _VPB {
   CSHORT Type ;
   CSHORT Size ;
   USHORT Flags ;
   USHORT VolumeLabelLength ;
   struct _DEVICE_OBJECT *DeviceObject ;
   struct _DEVICE_OBJECT *RealDevice ;
   ULONG SerialNumber ;
   ULONG ReferenceCount ;
   WCHAR VolumeLabel[(32U * sizeof(WCHAR )) / sizeof(WCHAR )] ;
};
#line 939 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _VPB *PVPB;
#line 940 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _WAIT_CONTEXT_BLOCK {
   KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
   IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ,
                                         PVOID MapRegisterBase , PVOID Context ) ;
   PVOID DeviceContext ;
   ULONG NumberOfMapRegisters ;
   PVOID DeviceObject ;
   PVOID CurrentIrp ;
   PKDPC BufferChainingDpc ;
};
#line 950 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
#line 951 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_Queue_43 {
   LIST_ENTRY ListEntry ;
   WAIT_CONTEXT_BLOCK Wcb ;
};
#line 955
struct _DEVOBJ_EXTENSION;
#line 955
struct _DEVOBJ_EXTENSION;
#line 956 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DEVICE_OBJECT {
   CSHORT Type ;
   USHORT Size ;
   LONG ReferenceCount ;
   struct _DRIVER_OBJECT *DriverObject ;
   struct _DEVICE_OBJECT *NextDevice ;
   struct _DEVICE_OBJECT *AttachedDevice ;
   struct _IRP *CurrentIrp ;
   PIO_TIMER Timer ;
   ULONG Flags ;
   ULONG Characteristics ;
   PVPB Vpb ;
   PVOID DeviceExtension ;
   ULONG DeviceType ;
   CCHAR StackSize ;
   union __anonunion_Queue_43 Queue ;
   ULONG AlignmentRequirement ;
   KDEVICE_QUEUE DeviceQueue ;
   KDPC Dpc ;
   ULONG ActiveThreadCount ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   KEVENT DeviceLock ;
   USHORT SectorSize ;
   USHORT Spare1 ;
   struct _DEVOBJ_EXTENSION *DeviceObjectExtension ;
   PVOID Reserved ;
};
#line 983 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
#line 984 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
#line 985 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DEVOBJ_EXTENSION {
   CSHORT Type ;
   USHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 990 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DRIVER_EXTENSION {
   struct _DRIVER_OBJECT *DriverObject ;
   NTSTATUS (*AddDevice)(struct _DRIVER_OBJECT *DriverObject , struct _DEVICE_OBJECT *PhysicalDeviceObject ) ;
   ULONG Count ;
   UNICODE_STRING ServiceKeyName ;
};
#line 996 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
#line 997 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DRIVER_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PVOID DriverStart ;
   ULONG DriverSize ;
   PVOID DriverSection ;
   PDRIVER_EXTENSION DriverExtension ;
   UNICODE_STRING DriverName ;
   PUNICODE_STRING HardwareDatabase ;
   PFAST_IO_DISPATCH FastIoDispatch ;
   NTSTATUS (*DriverInit)(struct _DRIVER_OBJECT *DriverObject , PUNICODE_STRING RegistryPath ) ;
   void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject ) ;
   PDRIVER_DISPATCH MajorFunction[28] ;
};
#line 1014 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
#line 1015 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
#line 1016 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _SECTION_OBJECT_POINTERS {
   PVOID DataSectionObject ;
   PVOID SharedCacheMap ;
   PVOID ImageSectionObject ;
};
#line 1021 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
#line 1022 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
#line 1023 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_COMPLETION_CONTEXT {
   PVOID Port ;
   PVOID Key ;
};
#line 1027 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
#line 1028 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FILE_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   PVPB Vpb ;
   PVOID FsContext ;
   PVOID FsContext2 ;
   PSECTION_OBJECT_POINTERS SectionObjectPointer ;
   PVOID PrivateCacheMap ;
   NTSTATUS FinalStatus ;
   struct _FILE_OBJECT *RelatedFileObject ;
   BOOLEAN LockOperation ;
   BOOLEAN DeletePending ;
   BOOLEAN ReadAccess ;
   BOOLEAN WriteAccess ;
   BOOLEAN DeleteAccess ;
   BOOLEAN SharedRead ;
   BOOLEAN SharedWrite ;
   BOOLEAN SharedDelete ;
   ULONG Flags ;
   UNICODE_STRING FileName ;
   LARGE_INTEGER CurrentByteOffset ;
   ULONG Waiters ;
   ULONG Busy ;
   PVOID LastLock ;
   KEVENT Lock ;
   KEVENT Event ;
   PIO_COMPLETION_CONTEXT CompletionContext ;
};
#line 1057 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FILE_OBJECT *PFILE_OBJECT;
#line 1058 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_AssociatedIrp_44 {
   struct _IRP *MasterIrp ;
   LONG IrpCount ;
   PVOID SystemBuffer ;
};
#line 1063 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_AsynchronousParameters_46 {
   void (*UserApcRoutine)(PVOID ApcContext , PIO_STATUS_BLOCK IoStatusBlock , ULONG Reserved ) ;
   PVOID UserApcContext ;
};
#line 1068 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_Overlay_45 {
   struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters ;
   LARGE_INTEGER AllocationSize ;
};
#line 1072 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct____missing_field_name_50 {
   PVOID DriverContext[4] ;
};
#line 1075 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_49 {
   KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
   struct __anonstruct____missing_field_name_50 __annonCompField14 ;
};
#line 1079
struct _IO_STACK_LOCATION;
#line 1079
struct _IO_STACK_LOCATION;
#line 1080 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_52 {
   struct _IO_STACK_LOCATION *CurrentStackLocation ;
   ULONG PacketType ;
};
#line 1084 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct____missing_field_name_51 {
   LIST_ENTRY ListEntry ;
   union __anonunion____missing_field_name_52 __annonCompField16 ;
};
#line 1088 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Overlay_48 {
   union __anonunion____missing_field_name_49 __annonCompField15 ;
   PETHREAD Thread ;
   PCHAR AuxiliaryBuffer ;
   struct __anonstruct____missing_field_name_51 __annonCompField17 ;
   PFILE_OBJECT OriginalFileObject ;
};
#line 1095 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_Tail_47 {
   struct __anonstruct_Overlay_48 Overlay ;
   KAPC Apc ;
   PVOID CompletionKey ;
};
#line 1100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IRP {
   CSHORT Type ;
   USHORT Size ;
   PMDL MdlAddress ;
   ULONG Flags ;
   union __anonunion_AssociatedIrp_44 AssociatedIrp ;
   LIST_ENTRY ThreadListEntry ;
   IO_STATUS_BLOCK IoStatus ;
   KPROCESSOR_MODE RequestorMode ;
   BOOLEAN PendingReturned ;
   CHAR StackCount ;
   CHAR CurrentLocation ;
   BOOLEAN Cancel ;
   KIRQL CancelIrql ;
   CCHAR ApcEnvironment ;
   UCHAR AllocationFlags ;
   PIO_STATUS_BLOCK UserIosb ;
   PKEVENT UserEvent ;
   union __anonunion_Overlay_45 Overlay ;
   void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   PVOID UserBuffer ;
   union __anonunion_Tail_47 Tail ;
};
#line 1123 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IRP IRP;
#line 1124 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IRP *PIRP;
#line 1125
enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4
} ;
#line 1132 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
#line 1133
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3
} ;
#line 1139 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
#line 1140 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _INTERFACE {
   USHORT Size ;
   USHORT Version ;
   PVOID Context ;
   void (*InterfaceReference)(PVOID Context ) ;
   void (*InterfaceDereference)(PVOID Context ) ;
};
#line 1147 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _INTERFACE *PINTERFACE;
#line 1148 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DEVICE_CAPABILITIES {
   USHORT Size ;
   USHORT Version ;
   ULONG DeviceD1 : 1 ;
   ULONG DeviceD2 : 1 ;
   ULONG LockSupported : 1 ;
   ULONG EjectSupported : 1 ;
   ULONG Removable : 1 ;
   ULONG DockDevice : 1 ;
   ULONG UniqueID : 1 ;
   ULONG SilentInstall : 1 ;
   ULONG RawDeviceOK : 1 ;
   ULONG SurpriseRemovalOK : 1 ;
   ULONG WakeFromD0 : 1 ;
   ULONG WakeFromD1 : 1 ;
   ULONG WakeFromD2 : 1 ;
   ULONG WakeFromD3 : 1 ;
   ULONG HardwareDisabled : 1 ;
   ULONG NonDynamic : 1 ;
   ULONG WarmEjectSupported : 1 ;
   ULONG Reserved : 15 ;
   ULONG Address ;
   ULONG UINumber ;
   DEVICE_POWER_STATE DeviceState[7] ;
   SYSTEM_POWER_STATE SystemWake ;
   DEVICE_POWER_STATE DeviceWake ;
   ULONG D1Latency ;
   ULONG D2Latency ;
   ULONG D3Latency ;
};
#line 1178 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
#line 1179 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _POWER_SEQUENCE {
   ULONG SequenceD1 ;
   ULONG SequenceD2 ;
   ULONG SequenceD3 ;
};
#line 1184 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
#line 1185
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4
} ;
#line 1192 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
#line 1193
enum __anonenum_DEVICE_TEXT_TYPE_54 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1
} ;
#line 1197 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#line 1198
#pragma pack(push,4)
#line 1199 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Create_56 {
   PIO_SECURITY_CONTEXT SecurityContext ;
   ULONG Options ;
   USHORT FileAttributes ;
   USHORT ShareAccess ;
   ULONG EaLength ;
};
#line 1206 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Read_57 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1211 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Write_58 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1216 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryFile_59 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
};
#line 1220 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct____missing_field_name_62 {
   BOOLEAN ReplaceIfExists ;
   BOOLEAN AdvanceOnly ;
};
#line 1224 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion____missing_field_name_61 {
   struct __anonstruct____missing_field_name_62 __annonCompField18 ;
   ULONG ClusterCount ;
   HANDLE DeleteHandle ;
};
#line 1229 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_SetFile_60 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
   PFILE_OBJECT FileObject ;
   union __anonunion____missing_field_name_61 __annonCompField19 ;
};
#line 1235 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryVolume_63 {
   ULONG Length ;
   FS_INFORMATION_CLASS FsInformationClass ;
};
#line 1239 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_DeviceIoControl_64 {
   ULONG OutputBufferLength ;
   ULONG InputBufferLength ;
   ULONG IoControlCode ;
   PVOID Type3InputBuffer ;
};
#line 1245 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QuerySecurity_65 {
   SECURITY_INFORMATION SecurityInformation ;
   ULONG Length ;
};
#line 1249 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_SetSecurity_66 {
   SECURITY_INFORMATION SecurityInformation ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
};
#line 1253 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_MountVolume_67 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1257 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_VerifyVolume_68 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1261 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Scsi_69 {
   struct _SCSI_REQUEST_BLOCK *Srb ;
};
#line 1264 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryDeviceRelations_70 {
   DEVICE_RELATION_TYPE Type ;
};
#line 1267 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryInterface_71 {
   GUID const   *InterfaceType ;
   USHORT Size ;
   USHORT Version ;
   PINTERFACE Interface ;
   PVOID InterfaceSpecificData ;
};
#line 1274 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_DeviceCapabilities_72 {
   PDEVICE_CAPABILITIES Capabilities ;
};
#line 1277 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_FilterResourceRequirements_73 {
   PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList ;
};
#line 1280 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_ReadWriteConfig_74 {
   ULONG WhichSpace ;
   PVOID Buffer ;
   ULONG Offset ;
   ULONG Length ;
};
#line 1286 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_SetLock_75 {
   BOOLEAN Lock ;
};
#line 1289 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryId_76 {
   BUS_QUERY_ID_TYPE IdType ;
};
#line 1292 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_QueryDeviceText_77 {
   DEVICE_TEXT_TYPE DeviceTextType ;
   LCID LocaleId ;
};
#line 1296 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_UsageNotification_78 {
   BOOLEAN InPath ;
   BOOLEAN Reserved[3] ;
   DEVICE_USAGE_NOTIFICATION_TYPE Type ;
};
#line 1301 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_WaitWake_79 {
   SYSTEM_POWER_STATE PowerState ;
};
#line 1304 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_PowerSequence_80 {
   PPOWER_SEQUENCE PowerSequence ;
};
#line 1307 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Power_81 {
   ULONG SystemContext ;
   POWER_STATE_TYPE Type ;
   POWER_STATE State ;
   POWER_ACTION ShutdownType ;
};
#line 1313 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_StartDevice_82 {
   PCM_RESOURCE_LIST AllocatedResources ;
   PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
};
#line 1317 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_WMI_83 {
   ULONG_PTR ProviderId ;
   PVOID DataPath ;
   ULONG BufferSize ;
   PVOID Buffer ;
};
#line 1323 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct __anonstruct_Others_84 {
   PVOID Argument1 ;
   PVOID Argument2 ;
   PVOID Argument3 ;
   PVOID Argument4 ;
};
#line 1329 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
union __anonunion_Parameters_55 {
   struct __anonstruct_Create_56 Create ;
   struct __anonstruct_Read_57 Read ;
   struct __anonstruct_Write_58 Write ;
   struct __anonstruct_QueryFile_59 QueryFile ;
   struct __anonstruct_SetFile_60 SetFile ;
   struct __anonstruct_QueryVolume_63 QueryVolume ;
   struct __anonstruct_DeviceIoControl_64 DeviceIoControl ;
   struct __anonstruct_QuerySecurity_65 QuerySecurity ;
   struct __anonstruct_SetSecurity_66 SetSecurity ;
   struct __anonstruct_MountVolume_67 MountVolume ;
   struct __anonstruct_VerifyVolume_68 VerifyVolume ;
   struct __anonstruct_Scsi_69 Scsi ;
   struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations ;
   struct __anonstruct_QueryInterface_71 QueryInterface ;
   struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities ;
   struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements ;
   struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig ;
   struct __anonstruct_SetLock_75 SetLock ;
   struct __anonstruct_QueryId_76 QueryId ;
   struct __anonstruct_QueryDeviceText_77 QueryDeviceText ;
   struct __anonstruct_UsageNotification_78 UsageNotification ;
   struct __anonstruct_WaitWake_79 WaitWake ;
   struct __anonstruct_PowerSequence_80 PowerSequence ;
   struct __anonstruct_Power_81 Power ;
   struct __anonstruct_StartDevice_82 StartDevice ;
   struct __anonstruct_WMI_83 WMI ;
   struct __anonstruct_Others_84 Others ;
};
#line 1358 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _IO_STACK_LOCATION {
   UCHAR MajorFunction ;
   UCHAR MinorFunction ;
   UCHAR Flags ;
   UCHAR Control ;
   union __anonunion_Parameters_55 Parameters ;
   PDEVICE_OBJECT DeviceObject ;
   PFILE_OBJECT FileObject ;
   NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
   PVOID Context ;
};
#line 1369 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
#line 1370 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#line 1371
#pragma pack(pop)
#line 1372 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _CONFIGURATION_INFORMATION {
   ULONG DiskCount ;
   ULONG FloppyCount ;
   ULONG CdRomCount ;
   ULONG TapeCount ;
   ULONG ScsiPortCount ;
   ULONG SerialCount ;
   ULONG ParallelCount ;
   BOOLEAN AtDiskPrimaryAddressClaimed ;
   BOOLEAN AtDiskSecondaryAddressClaimed ;
   ULONG Version ;
   ULONG MediumChangerCount ;
};
#line 1386 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
#line 1387 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _OBJECT_HANDLE_INFORMATION {
   ULONG HandleAttributes ;
   ACCESS_MASK GrantedAccess ;
};
#line 1391 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
#line 1392
enum _MEDIA_TYPE {
    Unknown = 0,
    F5_1Pt2_512 = 1,
    F3_1Pt44_512 = 2,
    F3_2Pt88_512 = 3,
    F3_20Pt8_512 = 4,
    F3_720_512 = 5,
    F5_360_512 = 6,
    F5_320_512 = 7,
    F5_320_1024 = 8,
    F5_180_512 = 9,
    F5_160_512 = 10,
    RemovableMedia = 11,
    FixedMedia = 12,
    F3_120M_512 = 13,
    F3_640_512 = 14,
    F5_640_512 = 15,
    F5_720_512 = 16,
    F3_1Pt2_512 = 17,
    F3_1Pt23_1024 = 18,
    F5_1Pt23_1024 = 19,
    F3_128Mb_512 = 20,
    F3_230Mb_512 = 21,
    F8_256_128 = 22
} ;
#line 1417 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _MEDIA_TYPE MEDIA_TYPE;
#line 1418 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
};
#line 1425 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FORMAT_PARAMETERS FORMAT_PARAMETERS;
#line 1426 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FORMAT_PARAMETERS *PFORMAT_PARAMETERS;
#line 1427 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef USHORT BAD_TRACK_NUMBER;
#line 1428 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef USHORT *PBAD_TRACK_NUMBER;
#line 1429 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType ;
   ULONG StartCylinderNumber ;
   ULONG EndCylinderNumber ;
   ULONG StartHeadNumber ;
   ULONG EndHeadNumber ;
   USHORT FormatGapLength ;
   USHORT SectorsPerTrack ;
   USHORT SectorNumber[1] ;
};
#line 1439 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FORMAT_EX_PARAMETERS FORMAT_EX_PARAMETERS;
#line 1440 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FORMAT_EX_PARAMETERS *PFORMAT_EX_PARAMETERS;
#line 1441 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DISK_GEOMETRY {
   LARGE_INTEGER Cylinders ;
   MEDIA_TYPE MediaType ;
   ULONG TracksPerCylinder ;
   ULONG SectorsPerTrack ;
   ULONG BytesPerSector ;
};
#line 1448 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DISK_GEOMETRY DISK_GEOMETRY;
#line 1449 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DISK_GEOMETRY *PDISK_GEOMETRY;
#line 1450
#pragma pack(push,1)
#line 1451
#pragma pack(pop)
#line 1452
#pragma pack(push,1)
#line 1453
#pragma pack(pop)
#line 1454
#pragma pack(push,1)
#line 1455
#pragma pack(pop)
#line 1456
#pragma pack(push,1)
#line 1457
#pragma pack(pop)
#line 1458
#pragma pack(push,1)
#line 1459
#pragma pack(pop)
#line 1460 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _TRANSFER_BUFFER {
   PHYSICAL_ADDRESS Logical ;
   PVOID Virtual ;
};
#line 1464 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _TRANSFER_BUFFER TRANSFER_BUFFER;
#line 1465 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _ACPI_FDI_DATA {
   ULONG DriveNumber ;
   ULONG DeviceType ;
   ULONG MaxCylinderNumber ;
   ULONG MaxSectorNumber ;
   ULONG MaxHeadNumber ;
   ULONG StepRateHeadUnloadTime ;
   ULONG HeadLoadTime ;
   ULONG MotorOffTime ;
   ULONG SectorLengthCode ;
   ULONG SectorPerTrack ;
   ULONG ReadWriteGapLength ;
   ULONG DataTransferLength ;
   ULONG FormatGapLength ;
   ULONG FormatFillCharacter ;
   ULONG HeadSettleTime ;
   ULONG MotorSettleTime ;
};
#line 1483 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _ACPI_FDI_DATA ACPI_FDI_DATA;
#line 1484
enum _ACPI_FDI_DEVICE_TYPE {
    CmosProblem = 0,
    Form525Capacity360 = 1,
    Form525Capacity1200 = 2,
    Form35Capacity720 = 3,
    Form35Capacity1440 = 4,
    Form35Capacity2880 = 5
} ;
#line 1492 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FDC_INFO {
   UCHAR FloppyControllerType ;
   UCHAR SpeedsAvailable ;
   ULONG AdapterBufferSize ;
   INTERFACE_TYPE BusType ;
   ULONG BusNumber ;
   ULONG ControllerNumber ;
   ULONG PeripheralNumber ;
   ULONG UnitNumber ;
   ULONG MaxTransferSize ;
   BOOLEAN AcpiBios ;
   BOOLEAN AcpiFdiSupported ;
   ACPI_FDI_DATA AcpiFdiData ;
   ULONG BufferCount ;
   ULONG BufferSize ;
   TRANSFER_BUFFER BufferAddress[] ;
};
#line 1509 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FDC_INFO FDC_INFO;
#line 1510 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FDC_INFO *PFDC_INFO;
#line 1511 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FDC_ENABLE_PARMS {
   UCHAR DriveOnValue ;
   USHORT TimeToWait ;
   BOOLEAN MotorStarted ;
};
#line 1516 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FDC_ENABLE_PARMS FDC_ENABLE_PARMS;
#line 1517 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _FDC_DISK_CHANGE_PARMS {
   UCHAR DriveStatus ;
   UCHAR DriveOnValue ;
};
#line 1521 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _FDC_DISK_CHANGE_PARMS FDC_DISK_CHANGE_PARMS;
#line 1522 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _ISSUE_FDC_COMMAND_PARMS {
   PUCHAR FifoInBuffer ;
   PUCHAR FifoOutBuffer ;
   PVOID IoHandle ;
   ULONG IoOffset ;
   ULONG TransferBytes ;
   ULONG TimeOut ;
};
#line 1530 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _ISSUE_FDC_COMMAND_PARMS ISSUE_FDC_COMMAND_PARMS;
#line 1531 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _SET_HD_BIT_PARMS {
   BOOLEAN DriveType144MB ;
   BOOLEAN Media144MB ;
   BOOLEAN More120MB ;
   UCHAR DeviceUnit ;
   BOOLEAN ChangedHdBit ;
};
#line 1538 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SET_HD_BIT_PARMS SET_HD_BIT_PARMS;
#line 1539 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _MOUNTDEV_NAME {
   USHORT NameLength ;
   WCHAR Name[1] ;
};
#line 1543 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_NAME MOUNTDEV_NAME;
#line 1544 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_NAME *PMOUNTDEV_NAME;
#line 1545 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _MOUNTDEV_UNIQUE_ID {
   USHORT UniqueIdLength ;
   UCHAR UniqueId[1] ;
};
#line 1549 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_UNIQUE_ID MOUNTDEV_UNIQUE_ID;
#line 1550 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_UNIQUE_ID *PMOUNTDEV_UNIQUE_ID;
#line 1551 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _MOUNTDEV_SUGGESTED_LINK_NAME {
   BOOLEAN UseOnlyIfThereAreNoOtherLinks ;
   USHORT NameLength ;
   WCHAR Name[1] ;
};
#line 1556 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME MOUNTDEV_SUGGESTED_LINK_NAME;
#line 1557 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME *PMOUNTDEV_SUGGESTED_LINK_NAME;
#line 1558 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _BOOT_SECTOR_INFO {
   UCHAR JumpByte[1] ;
   UCHAR Ignore1[2] ;
   UCHAR OemData[8] ;
   UCHAR BytesPerSector[2] ;
   UCHAR Ignore2[6] ;
   UCHAR NumberOfSectors[2] ;
   UCHAR MediaByte[1] ;
   UCHAR Ignore3[2] ;
   UCHAR SectorsPerTrack[2] ;
   UCHAR NumberOfHeads[2] ;
};
#line 1570 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _BOOT_SECTOR_INFO *PBOOT_SECTOR_INFO;
#line 1571
enum _DRIVE_MEDIA_TYPE {
    Drive360Media160 = 0,
    Drive360Media180 = 1,
    Drive360Media320 = 2,
    Drive360Media32X = 3,
    Drive360Media360 = 4,
    Drive720Media720 = 5,
    Drive120Media160 = 6,
    Drive120Media180 = 7,
    Drive120Media320 = 8,
    Drive120Media32X = 9,
    Drive120Media360 = 10,
    Drive120Media120 = 11,
    Drive144Media720 = 12,
    Drive144Media144 = 13,
    Drive288Media720 = 14,
    Drive288Media144 = 15,
    Drive288Media288 = 16
} ;
#line 1590 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _DRIVE_MEDIA_TYPE DRIVE_MEDIA_TYPE;
#line 1591
enum _DRIVE_MEDIA_TYPE_NEC98 {
    Drive360Media160Nec98 = 0,
    Drive360Media180Nec98 = 1,
    Drive360Media320Nec98 = 2,
    Drive360Media32XNec98 = 3,
    Drive360Media360Nec98 = 4,
    Drive120Media160Nec98 = 5,
    Drive120Media180Nec98 = 6,
    Drive120Media320Nec98 = 7,
    Drive120Media32XNec98 = 8,
    Drive120Media360Nec98 = 9,
    Drive120Media640Nec98 = 10,
    Drive120Media720Nec98 = 11,
    Drive120Media120Nec98 = 12,
    Drive120Media123Nec98 = 13,
    Drive144Media640Nec98 = 14,
    Drive144Media720Nec98 = 15,
    Drive144Media120Nec98 = 16,
    Drive144Media123Nec98 = 17,
    Drive144Media144Nec98 = 18,
    Drive12EMedia120Nec98 = 19,
    Drive12EMedia123Nec98 = 20
} ;
#line 1614 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef enum _DRIVE_MEDIA_TYPE_NEC98 DRIVE_MEDIA_TYPE_NEC98;
#line 1615 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DRIVE_MEDIA_LIMITS {
   DRIVE_MEDIA_TYPE HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE LowestDriveMediaType ;
};
#line 1619 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVE_MEDIA_LIMITS DRIVE_MEDIA_LIMITS;
#line 1620 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVE_MEDIA_LIMITS *PDRIVE_MEDIA_LIMITS;
#line 1621 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DRIVE_MEDIA_LIMITS_NEC98 {
   DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType ;
   DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType ;
};
#line 1625 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 DRIVE_MEDIA_LIMITS_NEC98;
#line 1626 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DRIVE_MEDIA_CONSTANTS {
   MEDIA_TYPE MediaType ;
   UCHAR StepRateHeadUnloadTime ;
   UCHAR HeadLoadTime ;
   UCHAR MotorOffTime ;
   UCHAR SectorLengthCode ;
   USHORT BytesPerSector ;
   UCHAR SectorsPerTrack ;
   UCHAR ReadWriteGapLength ;
   UCHAR FormatGapLength ;
   UCHAR FormatFillCharacter ;
   UCHAR HeadSettleTime ;
   USHORT MotorSettleTimeRead ;
   USHORT MotorSettleTimeWrite ;
   UCHAR MaximumTrack ;
   UCHAR CylinderShift ;
   UCHAR DataTransferRate ;
   UCHAR NumberOfHeads ;
   UCHAR DataLength ;
   UCHAR MediaByte ;
   UCHAR SkewDelta ;
};
#line 1648 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVE_MEDIA_CONSTANTS DRIVE_MEDIA_CONSTANTS;
#line 1649 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DRIVE_MEDIA_CONSTANTS *PDRIVE_MEDIA_CONSTANTS;
#line 1650 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _DISKETTE_EXTENSION {
   KSPIN_LOCK FlCancelSpinLock ;
   PDEVICE_OBJECT UnderlyingPDO ;
   PDEVICE_OBJECT TargetObject ;
   BOOLEAN IsStarted ;
   BOOLEAN IsRemoved ;
   BOOLEAN HoldNewRequests ;
   LIST_ENTRY NewRequestQueue ;
   KSPIN_LOCK NewRequestQueueSpinLock ;
   PDEVICE_OBJECT DeviceObject ;
   KSEMAPHORE RequestSemaphore ;
   KSPIN_LOCK ListSpinLock ;
   FAST_MUTEX ThreadReferenceMutex ;
   LONG ThreadReferenceCount ;
   PKTHREAD FloppyThread ;
   LIST_ENTRY ListEntry ;
   BOOLEAN HardwareFailed ;
   UCHAR HardwareFailCount ;
   ULONG MaxTransferSize ;
   UCHAR FifoBuffer[10] ;
   PUCHAR IoBuffer ;
   PMDL IoBufferMdl ;
   ULONG IoBufferSize ;
   PDRIVER_OBJECT DriverObject ;
   DRIVE_MEDIA_TYPE LastDriveMediaType ;
   BOOLEAN FloppyControllerAllocated ;
   BOOLEAN ACPI_BIOS ;
   UCHAR DriveType ;
   ULONG BytesPerSector ;
   ULONG ByteCapacity ;
   MEDIA_TYPE MediaType ;
   DRIVE_MEDIA_TYPE DriveMediaType ;
   UCHAR DeviceUnit ;
   UCHAR DriveOnValue ;
   BOOLEAN IsReadOnly ;
   DRIVE_MEDIA_CONSTANTS BiosDriveMediaConstants ;
   DRIVE_MEDIA_CONSTANTS DriveMediaConstants ;
   UCHAR PerpendicularMode ;
   BOOLEAN ControllerConfigurable ;
   UNICODE_STRING DeviceName ;
   UNICODE_STRING InterfaceString ;
   UNICODE_STRING ArcName ;
   BOOLEAN ReleaseFdcWithMotorRunning ;
   BOOLEAN PoweringDown ;
   FAST_MUTEX PowerDownMutex ;
   FAST_MUTEX HoldNewReqMutex ;
};
#line 1697 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _DISKETTE_EXTENSION DISKETTE_EXTENSION;
#line 1698 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef DISKETTE_EXTENSION *PDISKETTE_EXTENSION;
#line 1699 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _SENSE_DEVISE_STATUS_PTOS {
   UCHAR ST3_PTOS ;
};
#line 1702 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SENSE_DEVISE_STATUS_PTOS SENSE_DEVISE_STATUS_PTOS;
#line 1703 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
typedef struct _SENSE_DEVISE_STATUS_PTOS *PSENSE_DEVISE_STATUS_PTOS;
#line 1704
#pragma pack(push,8)
#line 1705
#pragma pack(pop)
#line 1706
struct _KAPC;
#line 1707
struct _KDPC;
#line 1708
#pragma pack(push,4)
#line 1709
#pragma pack(pop)
#line 1710
#pragma pack(push,4)
#line 1711
#pragma pack(pop)
#line 1712
#pragma pack(push,1)
#line 1713
#pragma pack(pop)
#line 1714
struct _DRIVER_OBJECT;
#line 1715
struct _DEVICE_OBJECT;
#line 1716
struct _DRIVER_OBJECT;
#line 1717
struct _FILE_OBJECT;
#line 1718
struct _IRP;
#line 1719
struct _SCSI_REQUEST_BLOCK;
#line 1720
#pragma pack(push,4)
#line 1721
#pragma pack(pop)
#line 1723
extern int sprintf(char * , char const   *  , ...) ;
#line 1724
extern int swprintf(wchar_t * , wchar_t const   *  , ...) ;
#line 1729
#pragma warning(push)
#line 1730
#pragma warning(disable:4035)
#line 1731
#pragma warning(pop)
#line 1733
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 1734
extern void *memset(void * , int  , size_t  ) ;
#line 1735
extern void *memmove(void * , void const   * , size_t  ) ;
#line 1736
extern PKTHREAD KeGetCurrentThread() ;
#line 1737
#pragma warning(disable:4103)
#line 1738
#pragma warning(disable:4103)
#line 1739
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) ;
#line 1744
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) ;
#line 1747
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) ;
#line 1749
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) ;
#line 1751
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) ;
#line 1754
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) ;
#line 1756
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) ;
#line 1757
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) ;
#line 1760
#pragma warning(push)
#line 1761
#pragma warning(disable:4035)
#line 1762
#pragma warning(pop)
#line 1763
extern LONG InterlockedExchange(PLONG Target , LONG Value ) ;
#line 1765
#pragma warning(disable:4035)
#line 1766
#pragma warning(push)
#line 1767
#pragma warning(disable:4164)
#line 1768
#pragma function(_enable)
#line 1769
#pragma function(_disable)
#line 1770
#pragma warning(pop)
#line 1771
#pragma warning(disable:4103)
#line 1772
#pragma warning(disable:4103)
#line 1773
#pragma warning(disable:4103)
#line 1774
#pragma warning(disable:4103)
#line 1775
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) ;
#line 1777
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) ;
#line 1779
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) ;
#line 1781
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) ;
#line 1783
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) ;
#line 1786
extern KPRIORITY KeSetPriorityThread(PKTHREAD Thread , KPRIORITY Priority ) ;
#line 1788
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) ;
#line 1792
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 1793
extern KIRQL KfAcquireSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 1794
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) ;
#line 1796
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
#line 1799
void ExFreePool(PVOID P ) ;
#line 1800
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) ;
#line 1801
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) ;
#line 1802
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 1805
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 1808
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) ;
#line 1810
extern void MmProbeAndLockPages(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                LOCK_OPERATION Operation ) ;
#line 1813
void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 1814
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) ;
#line 1820
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 1822
void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 1823
void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 1824
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 1825
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) ;
#line 1832
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#line 1833
#pragma warning(disable:4103)
#line 1834
#pragma warning(disable:4103)
#line 1835
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) ;
#line 1838
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 1840
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 1846
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 1855
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 1857
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) ;
#line 1859
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
#line 1864
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 1866
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 1867
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
#line 1868
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 1869
void IoFreeIrp(PIRP Irp ) ;
#line 1870
void IoFreeMdl(PMDL Mdl ) ;
#line 1871
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
#line 1872
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) ;
#line 1890
void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 1891
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
#line 1892
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) ;
#line 1896
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) ;
#line 1898
#pragma warning(disable:4200)
#line 1899
#pragma warning(default:4200)
#line 1900
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 1902
void PoStartNextPowerIrp(PIRP Irp ) ;
#line 1903
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) ;
#line 1909
void ObfDereferenceObject(PVOID Object ) ;
#line 1910
NTSTATUS ZwClose(HANDLE Handle ) ;
#line 1912
#pragma warning(disable:4103)
#line 1913
#pragma warning(disable:4103)
#line 1914
#pragma warning(disable:4103)
#line 1915
#pragma warning(disable:4103)
#line 1916
#pragma warning(disable:4103)
#line 1917
#pragma warning(disable:4103)
#line 1918
#pragma warning(disable:4103)
#line 1919
#pragma warning(disable:4103)
#line 1920
#pragma warning(disable:4103)
#line 1921
#pragma warning(disable:4103)
#line 1924 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
struct _GUID  const  MOUNTDEV_MOUNTED_DEVICE_GUID  =    {1408590605UL, (unsigned short)46783, (unsigned short)4560, {(unsigned char)148,
                                                                (unsigned char)242,
                                                                (unsigned char)0,
                                                                (unsigned char)160,
                                                                (unsigned char)201,
                                                                (unsigned char)30,
                                                                (unsigned char)251,
                                                                (unsigned char)139}};
#line 1927 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
DRIVE_MEDIA_LIMITS _DriveMediaLimits[5]  = {      {(DRIVE_MEDIA_TYPE )4, (DRIVE_MEDIA_TYPE )0}, 
        {(DRIVE_MEDIA_TYPE )11, (DRIVE_MEDIA_TYPE )6}, 
        {(DRIVE_MEDIA_TYPE )5, (DRIVE_MEDIA_TYPE )5}, 
        {(DRIVE_MEDIA_TYPE )13, (DRIVE_MEDIA_TYPE )12}, 
        {(DRIVE_MEDIA_TYPE )16, (DRIVE_MEDIA_TYPE )14}};
#line 1932 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[6]  = {      {(DRIVE_MEDIA_TYPE_NEC98 )4, (DRIVE_MEDIA_TYPE_NEC98 )0}, 
        {(DRIVE_MEDIA_TYPE_NEC98 )13, (DRIVE_MEDIA_TYPE_NEC98 )5}, 
        {(DRIVE_MEDIA_TYPE_NEC98 )11, (DRIVE_MEDIA_TYPE_NEC98 )5}, 
        {(DRIVE_MEDIA_TYPE_NEC98 )18, (DRIVE_MEDIA_TYPE_NEC98 )14}, 
        {(DRIVE_MEDIA_TYPE_NEC98 )18, (DRIVE_MEDIA_TYPE_NEC98 )14}, 
        {(DRIVE_MEDIA_TYPE_NEC98 )20, (DRIVE_MEDIA_TYPE_NEC98 )19}};
#line 1938 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PDRIVE_MEDIA_LIMITS DriveMediaLimits  ;
#line 1939 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[17]  = 
#line 1939
  {      {(MEDIA_TYPE )10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {(MEDIA_TYPE )9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {(MEDIA_TYPE )7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )8,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4, (UCHAR )128,
      (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )6, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )250, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {(MEDIA_TYPE )5,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {(MEDIA_TYPE )10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )1, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {(MEDIA_TYPE )9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )1, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {(MEDIA_TYPE )7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )8,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4, (UCHAR )128,
      (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )6, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )625, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )1, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {(MEDIA_TYPE )1,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15, (UCHAR )27,
      (UCHAR )84, (UCHAR )246, (UCHAR )15, (USHORT )625, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {(MEDIA_TYPE )5, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {(MEDIA_TYPE )2,
      (UCHAR )175, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )18, (UCHAR )27,
      (UCHAR )101, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )3}, 
        {(MEDIA_TYPE )5, (UCHAR )225, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {(MEDIA_TYPE )2,
      (UCHAR )209, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )18, (UCHAR )27,
      (UCHAR )101, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )3}, 
        {(MEDIA_TYPE )3, (UCHAR )161, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )36, (UCHAR )56, (UCHAR )83, (UCHAR )246, (UCHAR )15, (USHORT )500, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )3, (UCHAR )2, (UCHAR )255, (UCHAR )240, (UCHAR )6}};
#line 1974 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[21]  = 
#line 1974
  {      {(MEDIA_TYPE )10, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {(MEDIA_TYPE )9,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {(MEDIA_TYPE )7, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )8,
      (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )3, (USHORT )1024, (UCHAR )4, (UCHAR )128,
      (UCHAR )240, (UCHAR )246, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )6, (UCHAR )223, (UCHAR )2, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )246, (UCHAR )15, (USHORT )250, (USHORT )1000,
      (UCHAR )39, (UCHAR )0, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {(MEDIA_TYPE )10,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )254, (UCHAR )0}, 
        {(MEDIA_TYPE )9, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )1, (UCHAR )255, (UCHAR )252, (UCHAR )0}, 
        {(MEDIA_TYPE )7,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )39,
      (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255, (UCHAR )0}, 
        {(MEDIA_TYPE )8, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )3, (USHORT )1024,
      (UCHAR )4, (UCHAR )128, (UCHAR )240, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )255,
      (UCHAR )0}, 
        {(MEDIA_TYPE )6, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )39, (UCHAR )1, (UCHAR )2, (UCHAR )2, (UCHAR )255, (UCHAR )253, (UCHAR )0}, 
        {(MEDIA_TYPE )15,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )8, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )251, (UCHAR )0}, 
        {(MEDIA_TYPE )16, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )9, (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {(MEDIA_TYPE )1,
      (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )15, (UCHAR )27,
      (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )0}, 
        {(MEDIA_TYPE )19, (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )3, (USHORT )1024,
      (UCHAR )8, (UCHAR )53, (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )76, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254,
      (UCHAR )0}, 
        {(MEDIA_TYPE )14, (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )8, (UCHAR )42, (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000,
      (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )251, (UCHAR )0}, 
        {(MEDIA_TYPE )5,
      (UCHAR )223, (UCHAR )22, (UCHAR )37, (UCHAR )2, (USHORT )512, (UCHAR )9, (UCHAR )42,
      (UCHAR )80, (UCHAR )229, (UCHAR )15, (USHORT )1000, (USHORT )1000, (UCHAR )79,
      (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249, (UCHAR )2}, 
        {(MEDIA_TYPE )17, (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )15, (UCHAR )27, (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249,
      (UCHAR )0}, 
        {(MEDIA_TYPE )18, (UCHAR )207, (UCHAR )36, (UCHAR )37, (UCHAR )3, (USHORT )1024,
      (UCHAR )8, (UCHAR )53, (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )76, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254,
      (UCHAR )0}, 
        {(MEDIA_TYPE )2, (UCHAR )223, (UCHAR )36, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )18, (UCHAR )27, (UCHAR )108, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )240,
      (UCHAR )3}, 
        {(MEDIA_TYPE )1, (UCHAR )191, (UCHAR )50, (UCHAR )37, (UCHAR )2, (USHORT )512,
      (UCHAR )15, (UCHAR )27, (UCHAR )84, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )79, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )249,
      (UCHAR )0}, 
        {(MEDIA_TYPE )19, (UCHAR )191, (UCHAR )50, (UCHAR )37, (UCHAR )3, (USHORT )1024,
      (UCHAR )8, (UCHAR )53, (UCHAR )116, (UCHAR )229, (UCHAR )15, (USHORT )1000,
      (USHORT )1000, (UCHAR )76, (UCHAR )0, (UCHAR )0, (UCHAR )2, (UCHAR )255, (UCHAR )254,
      (UCHAR )0}};
#line 2017 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PDRIVE_MEDIA_CONSTANTS DriveMediaConstants  ;
#line 2018 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4]  ;
#line 2019
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) ;
#line 2020
void FloppyUnload(PDRIVER_OBJECT DriverObject ) ;
#line 2021
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ;
#line 2026
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2027
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2028
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2029
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2030
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2031
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2032
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) ;
#line 2034
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2035
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2036
void FloppyThread(PVOID Context ) ;
#line 2037
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) ;
#line 2038
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 2039
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) ;
#line 2041
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) ;
#line 2042
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2043
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) ;
#line 2044
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) ;
#line 2045
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2046
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) ;
#line 2048
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2049
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) ;
#line 2052
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) ;
#line 2053
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) ;
#line 2054
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2055
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2056
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
#line 2057
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 2058
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2059
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2060
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2061
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) ;
#line 2062
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 2063
#pragma alloc_text(INIT,DriverEntry)
#line 2064
#pragma alloc_text(PAGE,FloppyAddDevice)
#line 2065
#pragma alloc_text(PAGE,FloppyPnp)
#line 2066
#pragma alloc_text(PAGE,FloppyPower)
#line 2067
#pragma alloc_text(PAGE,FlConfigCallBack)
#line 2068
#pragma alloc_text(PAGE,FlInitializeControllerHardware)
#line 2069
#pragma alloc_text(PAGE,FlInterpretError)
#line 2070
#pragma alloc_text(PAGE,FlDatarateSpecifyConfigure)
#line 2071
#pragma alloc_text(PAGE,FlRecalibrateDrive)
#line 2072
#pragma alloc_text(PAGE,FlDetermineMediaType)
#line 2073
#pragma alloc_text(PAGE,FlCheckBootSector)
#line 2074
#pragma alloc_text(PAGE,FlConsolidateMediaTypeWithBootSector)
#line 2075
#pragma alloc_text(PAGE,FlIssueCommand)
#line 2076
#pragma alloc_text(PAGE,FlReadWriteTrack)
#line 2077
#pragma alloc_text(PAGE,FlReadWrite)
#line 2078
#pragma alloc_text(PAGE,FlFormat)
#line 2079
#pragma alloc_text(PAGE,FlFinishOperation)
#line 2080
#pragma alloc_text(PAGE,FlStartDrive)
#line 2081
#pragma alloc_text(PAGE,FloppyThread)
#line 2082
#pragma alloc_text(PAGE,FlAllocateIoBuffer)
#line 2083
#pragma alloc_text(PAGE,FlFreeIoBuffer)
#line 2084
#pragma alloc_text(PAGE,FloppyCreateClose)
#line 2085
#pragma alloc_text(PAGE,FloppyDeviceControl)
#line 2086
#pragma alloc_text(PAGE,FloppyReadWrite)
#line 2087
#pragma alloc_text(PAGE,FlCheckFormatParameters)
#line 2088
#pragma alloc_text(PAGE,FlFdcDeviceIo)
#line 2089
#pragma alloc_text(PAGE,FlHdbit)
#line 2090 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void errorFn(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 2098 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS myStatus  ;
#line 2099 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int s  ;
#line 2100 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int UNLOADED  ;
#line 2101 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int NP  ;
#line 2102 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int DC  ;
#line 2103 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int SKIP1  ;
#line 2104 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int SKIP2  ;
#line 2105 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int MPR1  ;
#line 2106 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int MPR3  ;
#line 2107 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int IPC  ;
#line 2108 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int pended  ;
#line 2109 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context )  ;
#line 2110 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int compRegistered  ;
#line 2111 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int lowerDriverReturn  ;
#line 2112 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int setEventCalled  ;
#line 2113 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int customIrp  ;
#line 2114 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void _BLAST_init(void) 
{ 

  {
#line 2118
  UNLOADED = 0;
#line 2119
  NP = 1;
#line 2120
  DC = 2;
#line 2121
  SKIP1 = 3;
#line 2122
  SKIP2 = 4;
#line 2123
  MPR1 = 5;
#line 2124
  MPR3 = 6;
#line 2125
  IPC = 7;
#line 2126
  s = UNLOADED;
#line 2127
  pended = 0;
#line 2128
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 2129
  compRegistered = 0;
#line 2130
  lowerDriverReturn = 0;
#line 2131
  setEventCalled = 0;
#line 2132
  customIrp = 0;
#line 2133
  return;
}
}
#line 2136 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
ULONG PagingReferenceCount  =    (ULONG )0;
#line 2137 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PFAST_MUTEX PagingMutex  =    (PFAST_MUTEX )((void *)0);
#line 2138 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) 
{ NTSTATUS ntStatus ;
  PVOID tmp ;

  {
  {
#line 2143
  ntStatus = 0L;
#line 2147
  DriverObject->MajorFunction[0] = & FloppyCreateClose;
#line 2148
  DriverObject->MajorFunction[2] = & FloppyCreateClose;
#line 2149
  DriverObject->MajorFunction[3] = & FloppyReadWrite;
#line 2150
  DriverObject->MajorFunction[4] = & FloppyReadWrite;
#line 2151
  DriverObject->MajorFunction[14] = & FloppyDeviceControl;
#line 2152
  DriverObject->MajorFunction[27] = & FloppyPnp;
#line 2153
  DriverObject->MajorFunction[22] = & FloppyPower;
#line 2154
  DriverObject->DriverUnload = & FloppyUnload;
#line 2155
  (DriverObject->DriverExtension)->AddDevice = & FloppyAddDevice;
#line 2156
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )0, (unsigned long )sizeof(FAST_MUTEX ),
                              1886350406UL);
#line 2157
  PagingMutex = (struct _FAST_MUTEX *)tmp;
  }
#line 2159
  if ((unsigned int )PagingMutex == (unsigned int )((void *)0)) {
#line 2160
    return (-1073741670L);
  } else {

  }
#line 2165
  PagingMutex->Count = 1L;
#line 2166
  PagingMutex->Contention = 0UL;
#line 2170
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2171
    DriveMediaLimits = (struct _DRIVE_MEDIA_LIMITS *)(_DriveMediaLimits_NEC98);
  } else {
#line 2173
    DriveMediaLimits = _DriveMediaLimits;
  }
#line 2175
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2176
    DriveMediaConstants = _DriveMediaConstants_NEC98;
  } else {
#line 2178
    DriveMediaConstants = _DriveMediaConstants;
  }
#line 2180
  return (ntStatus);
}
}
#line 2183 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FloppyUnload(PDRIVER_OBJECT DriverObject ) 
{ 

  {
#line 2192
  return;
}
}
#line 2195 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) 
{ NTSTATUS ntStatus ;
  PDEVICE_OBJECT deviceObject ;
  PDISKETTE_EXTENSION disketteExtension ;
  FDC_INFO fdcInfo ;
  UCHAR arcNameBuffer[256] ;
  STRING arcNameString ;
  WCHAR deviceNameBuffer[20] ;
  UNICODE_STRING deviceName ;
  USHORT i ;
  USHORT tmp ;
  PVOID tmp___0 ;
  PCONFIGURATION_INFORMATION tmp___1 ;

  {
  {
#line 2210
  ntStatus = 0L;
#line 2214
  fdcInfo.BufferCount = 0UL;
#line 2215
  fdcInfo.BufferSize = 0UL;
#line 2216
  ntStatus = FlFdcDeviceIo(PhysicalDeviceObject, (unsigned long )(((7 << 16) | (770 << 2)) | 3),
                           (void *)(& fdcInfo));
  }
#line 2218
  if (ntStatus >= 0L) {
#line 2219
    i = (unsigned short)0;
    {
#line 2221
    while (1) {
      while_0_continue: /* CIL Label */ ;
      {
#line 2224
      tmp = i;
#line 2225
      i = (unsigned short )((int )i + 1);
#line 2226
      swprintf(deviceNameBuffer, (wchar_t const   *)"\\\000D\000e\000v\000i\000c\000e\000\\\000F\000l\000o\000p\000p\000y\000%\000d\000",
               tmp);
#line 2229
      ntStatus = IoCreateDevice(DriverObject, (unsigned long )sizeof(DISKETTE_EXTENSION ),
                                & deviceName, 7UL, 261UL, (unsigned char)0, & deviceObject);
      }
#line 2232
      if (ntStatus == -1073741771L) {

      } else {
        goto while_3_break;
      }
    }
    while_0_break: /* CIL Label */ ;
    }
    while_3_break: ;
#line 2240
    if (ntStatus >= 0L) {
      {
#line 2241
      disketteExtension = (DISKETTE_EXTENSION *)deviceObject->DeviceExtension;
#line 2245
      tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )1, (unsigned long )deviceName.Length,
                                      1886350406UL);
#line 2246
      disketteExtension->DeviceName.Buffer = (WCHAR *)tmp___0;
      }
#line 2248
      if ((unsigned int )disketteExtension->DeviceName.Buffer == (unsigned int )((void *)0)) {
#line 2252
        return (-1073741670L);
      } else {

      }
      {
#line 2257
      disketteExtension->DeviceName.Length = (unsigned short)0;
#line 2258
      disketteExtension->DeviceName.MaximumLength = deviceName.Length;
#line 2260
      tmp___1 = IoGetConfigurationInformation();
#line 2261
      tmp___1->FloppyCount += 1UL;
#line 2262
      sprintf((char *)(arcNameBuffer), "%s(%d)disk(%d)fdisk(%d)", "\\ArcName\\multi",
              fdcInfo.BusNumber, fdcInfo.ControllerNumber, fdcInfo.PeripheralNumber);
#line 2265
      ntStatus = RtlAnsiStringToUnicodeString(& disketteExtension->ArcName, & arcNameString,
                                              (unsigned char)1);
      }
#line 2268
      if (ntStatus >= 0L) {
        {
#line 2270
        IoCreateSymbolicLink(& disketteExtension->ArcName, & deviceName);
        }
      } else {

      }
#line 2275
      deviceObject->Flags |= 8208UL;
#line 2276
      if (deviceObject->AlignmentRequirement < 1UL) {
#line 2277
        deviceObject->AlignmentRequirement = 1UL;
      } else {

      }
      {
#line 2281
      deviceObject->Flags &= 4294967167UL;
#line 2282
      disketteExtension->DriverObject = DriverObject;
#line 2283
      disketteExtension->UnderlyingPDO = PhysicalDeviceObject;
#line 2287
      disketteExtension->TargetObject = IoAttachDeviceToDeviceStack(deviceObject,
                                                                    PhysicalDeviceObject);
#line 2294
      disketteExtension->PowerDownMutex.Count = 1L;
#line 2295
      disketteExtension->PowerDownMutex.Contention = 0UL;
#line 2298
      disketteExtension->ThreadReferenceMutex.Count = 1L;
#line 2299
      disketteExtension->ThreadReferenceMutex.Contention = 0UL;
#line 2301
      disketteExtension->HoldNewReqMutex.Count = 1L;
#line 2302
      disketteExtension->HoldNewReqMutex.Contention = 0UL;
#line 2304
      disketteExtension->ListEntry.Blink = & disketteExtension->ListEntry;
#line 2305
      disketteExtension->ListEntry.Flink = disketteExtension->ListEntry.Blink;
#line 2306
      disketteExtension->ThreadReferenceCount = -1L;
#line 2307
      disketteExtension->IsStarted = (unsigned char)0;
#line 2308
      disketteExtension->IsRemoved = (unsigned char)0;
#line 2309
      disketteExtension->HoldNewRequests = (unsigned char)0;
#line 2310
      disketteExtension->NewRequestQueue.Blink = & disketteExtension->NewRequestQueue;
#line 2311
      disketteExtension->NewRequestQueue.Flink = disketteExtension->NewRequestQueue.Blink;
#line 2314
      disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 2315
      disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
#line 2316
      disketteExtension->DeviceObject = deviceObject;
#line 2317
      disketteExtension->IsReadOnly = (unsigned char)0;
#line 2318
      disketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
      }
#line 2320
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2321
        disketteExtension->ControllerConfigurable = (unsigned char)0;
      } else {
#line 2323
        disketteExtension->ControllerConfigurable = (unsigned char)1;
      }
    } else {

    }
  } else {

  }
#line 2331
  return (ntStatus);
}
}
#line 2334 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName , INTERFACE_TYPE BusType ,
                          ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                          CONFIGURATION_TYPE ControllerType , ULONG ControllerNumber ,
                          PKEY_VALUE_FULL_INFORMATION *ControllerInformation , CONFIGURATION_TYPE PeripheralType ,
                          ULONG PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  ULONG i ;
  PCM_FULL_RESOURCE_DESCRIPTOR peripheralData ;
  PCM_PARTIAL_RESOURCE_DESCRIPTOR partial ;
  PCM_FLOPPY_DEVICE_DATA fDeviceData ;
  UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
#line 2348
  disketteExtension = (DISKETTE_EXTENSION *)Context;
#line 2349
  if (! ((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataLength)) {
#line 2350
    return (-1073741811L);
  } else {

  }
#line 2354
  peripheralData = (struct _CM_FULL_RESOURCE_DESCRIPTOR *)((UCHAR *)*(PeripheralInformation + 1) + (*(PeripheralInformation + 1))->DataOffset);
#line 2355
  i = 0UL;
  {
#line 2357
  while (1) {
    while_1_continue: /* CIL Label */ ;

#line 2359
    if (i < peripheralData->PartialResourceList.Count) {

    } else {
      goto while_7_break;
    }
#line 2364
    partial = & peripheralData->PartialResourceList.PartialDescriptors[i];
#line 2365
    if ((int )partial->Type == 5) {
#line 2366
      biosDriveMediaConstants = & disketteExtension->BiosDriveMediaConstants;
#line 2367
      fDeviceData = (struct _CM_FLOPPY_DEVICE_DATA *)(partial + 1);
#line 2368
      if (fDeviceData->MaxDensity == 360UL) {
        goto switch_8_360;
      } else {
#line 2371
        if (fDeviceData->MaxDensity == 1200UL) {
          goto switch_8_1200;
        } else {
#line 2374
          if (fDeviceData->MaxDensity == 1185UL) {
            goto switch_8_1185;
          } else {
#line 2377
            if (fDeviceData->MaxDensity == 1423UL) {
              goto switch_8_1423;
            } else {
#line 2380
              if (fDeviceData->MaxDensity == 1440UL) {
                goto switch_8_1440;
              } else {
#line 2383
                if (fDeviceData->MaxDensity == 2880UL) {
                  goto switch_8_2880;
                } else {
#line 2386
                  if (fDeviceData->MaxDensity == 1201UL) {
                    goto switch_8_1201;
                  } else {
                    goto switch_8_default;
#line 2391
                    if (0) {
                      switch_8_360: 
#line 2393
                      driveType = (unsigned char)0;
                      goto switch_8_break;
                      switch_8_1200: 
#line 2396
                      driveType = (unsigned char)1;
                      goto switch_8_break;
                      switch_8_1185: 
#line 2399
                      driveType = (unsigned char)1;
                      goto switch_8_break;
                      switch_8_1423: 
#line 2402
                      driveType = (unsigned char)3;
                      goto switch_8_break;
                      switch_8_1440: 
#line 2405
                      driveType = (unsigned char)3;
                      goto switch_8_break;
                      switch_8_2880: 
#line 2408
                      driveType = (unsigned char)4;
                      goto switch_8_break;
                      switch_8_1201: ;
#line 2411
                      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2412
                        driveType = (unsigned char)5;
                        goto switch_8_break;
                      } else {

                      }
                      switch_8_default: 
#line 2420
                      driveType = (unsigned char)1;
                      goto switch_8_break;
                    } else {
                      switch_8_break: ;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 2435
      disketteExtension->DriveType = driveType;
#line 2436
      *biosDriveMediaConstants = *(DriveMediaConstants + (int )(DriveMediaLimits + (int )driveType)->HighestDriveMediaType);
#line 2437
      if ((int )fDeviceData->Version >= 2) {
#line 2438
        biosDriveMediaConstants->StepRateHeadUnloadTime = fDeviceData->StepRateHeadUnloadTime;
#line 2439
        biosDriveMediaConstants->HeadLoadTime = fDeviceData->HeadLoadTime;
#line 2440
        biosDriveMediaConstants->MotorOffTime = fDeviceData->MotorOffTime;
#line 2441
        biosDriveMediaConstants->SectorLengthCode = fDeviceData->SectorLengthCode;
#line 2442
        if ((int )fDeviceData->SectorPerTrack == 0) {
#line 2443
          return (0L);
        } else {

        }
#line 2447
        if (fDeviceData->MaxDensity == 0UL) {
#line 2448
          return (0L);
        } else {

        }
#line 2452
        biosDriveMediaConstants->SectorsPerTrack = fDeviceData->SectorPerTrack;
#line 2453
        biosDriveMediaConstants->ReadWriteGapLength = fDeviceData->ReadWriteGapLength;
#line 2454
        biosDriveMediaConstants->FormatGapLength = fDeviceData->FormatGapLength;
#line 2455
        biosDriveMediaConstants->FormatFillCharacter = fDeviceData->FormatFillCharacter;
#line 2456
        biosDriveMediaConstants->HeadSettleTime = fDeviceData->HeadSettleTime;
#line 2457
        biosDriveMediaConstants->MotorSettleTimeRead = (unsigned short )(((int )fDeviceData->MotorSettleTime * 1000) / 8);
#line 2458
        biosDriveMediaConstants->MotorSettleTimeWrite = (unsigned short )(((int )fDeviceData->MotorSettleTime * 1000) / 8);
#line 2459
        if ((int )fDeviceData->MaximumTrackValue == 0) {
#line 2460
          return (0L);
        } else {

        }
#line 2464
        biosDriveMediaConstants->MaximumTrack = fDeviceData->MaximumTrackValue;
#line 2465
        biosDriveMediaConstants->DataLength = fDeviceData->DataTransferLength;
      } else {

      }
    } else {

    }
#line 2472
    i += 1UL;
  }
  while_1_break: /* CIL Label */ ;
  }
  while_7_break: ;
#line 2476
  return (0L);
}
}
#line 2479 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO FdcInfo ) 
{ UCHAR driveType ;
  PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants ;

  {
#line 2484
  biosDriveMediaConstants = & DisketteExtension->BiosDriveMediaConstants;
#line 2485
  if (! FdcInfo->AcpiFdiSupported) {
#line 2486
    return (-1073741823L);
  } else {

  }
#line 2490
  if ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType) == 1) {
    goto switch_11_1;
  } else {
#line 2493
    if ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType) == 2) {
      goto switch_11_2;
    } else {
#line 2496
      if ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType) == 3) {
        goto switch_11_3;
      } else {
#line 2499
        if ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType) == 4) {
          goto switch_11_4;
        } else {
#line 2502
          if ((int )((enum _ACPI_FDI_DEVICE_TYPE )FdcInfo->AcpiFdiData.DeviceType) == 5) {
            goto switch_11_5;
          } else {
            goto switch_11_default;
#line 2507
            if (0) {
              switch_11_1: 
#line 2509
              driveType = (unsigned char)0;
              goto switch_11_break;
              switch_11_2: 
#line 2512
              driveType = (unsigned char)1;
              goto switch_11_break;
              switch_11_3: 
#line 2515
              driveType = (unsigned char)2;
              goto switch_11_break;
              switch_11_4: 
#line 2518
              driveType = (unsigned char)3;
              goto switch_11_break;
              switch_11_5: 
#line 2521
              driveType = (unsigned char)4;
              goto switch_11_break;
              switch_11_default: 
#line 2524
              driveType = (unsigned char)1;
              goto switch_11_break;
            } else {
              switch_11_break: ;
            }
          }
        }
      }
    }
  }
#line 2535
  DisketteExtension->DriveType = driveType;
#line 2536
  *biosDriveMediaConstants = *(DriveMediaConstants + (int )(DriveMediaLimits + (int )driveType)->HighestDriveMediaType);
#line 2537
  biosDriveMediaConstants->StepRateHeadUnloadTime = (unsigned char )FdcInfo->AcpiFdiData.StepRateHeadUnloadTime;
#line 2538
  biosDriveMediaConstants->HeadLoadTime = (unsigned char )FdcInfo->AcpiFdiData.HeadLoadTime;
#line 2539
  biosDriveMediaConstants->MotorOffTime = (unsigned char )FdcInfo->AcpiFdiData.MotorOffTime;
#line 2540
  biosDriveMediaConstants->SectorLengthCode = (unsigned char )FdcInfo->AcpiFdiData.SectorLengthCode;
#line 2541
  biosDriveMediaConstants->SectorsPerTrack = (unsigned char )FdcInfo->AcpiFdiData.SectorPerTrack;
#line 2542
  biosDriveMediaConstants->ReadWriteGapLength = (unsigned char )FdcInfo->AcpiFdiData.ReadWriteGapLength;
#line 2543
  biosDriveMediaConstants->FormatGapLength = (unsigned char )FdcInfo->AcpiFdiData.FormatGapLength;
#line 2544
  biosDriveMediaConstants->FormatFillCharacter = (unsigned char )FdcInfo->AcpiFdiData.FormatFillCharacter;
#line 2545
  biosDriveMediaConstants->HeadSettleTime = (unsigned char )FdcInfo->AcpiFdiData.HeadSettleTime;
#line 2546
  biosDriveMediaConstants->MotorSettleTimeRead = (unsigned short )(((int )((unsigned char )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8);
#line 2547
  biosDriveMediaConstants->MotorSettleTimeWrite = (unsigned short )(((int )((unsigned short )FdcInfo->AcpiFdiData.MotorSettleTime) * 1000) / 8);
#line 2548
  biosDriveMediaConstants->MaximumTrack = (unsigned char )FdcInfo->AcpiFdiData.MaxCylinderNumber;
#line 2549
  biosDriveMediaConstants->DataLength = (unsigned char )FdcInfo->AcpiFdiData.DataTransferLength;
#line 2550
  return (0L);
}
}
#line 2553 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS status ;
  HANDLE threadHandle ;
  PIO_STACK_LOCATION irpSp ;
  OBJECT_ATTRIBUTES ObjAttributes ;

  {
#line 2561
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 2564
  if ((int )DisketteExtension->PoweringDown == 1) {
#line 2570
    myStatus = -1073741101L;
#line 2571
    Irp->IoStatus.__annonCompField4.Status = -1073741101L;
#line 2572
    Irp->IoStatus.Information = 0UL;
#line 2573
    return (-1073741101L);
  } else {

  }
#line 2584
  DisketteExtension->ThreadReferenceCount += 1L;
#line 2586
  if (DisketteExtension->ThreadReferenceCount == 0L) {
#line 2588
    DisketteExtension->ThreadReferenceCount += 1L;
#line 2590
    PagingReferenceCount += 1UL;
#line 2592
    if (PagingReferenceCount == 1UL) {

    } else {

    }
    {
#line 2601
    ObjAttributes.Length = (unsigned long )sizeof(OBJECT_ATTRIBUTES );
#line 2602
    ObjAttributes.RootDirectory = (void *)0;
#line 2603
    ObjAttributes.Attributes = 512UL;
#line 2604
    ObjAttributes.ObjectName = (UNICODE_STRING *)((void *)0);
#line 2605
    ObjAttributes.SecurityDescriptor = (void *)0;
#line 2606
    ObjAttributes.SecurityQualityOfService = (void *)0;
#line 2607
    status = PsCreateSystemThread(& threadHandle, 0UL, & ObjAttributes, (void *)0L,
                                  (CLIENT_ID *)((void *)0), & FloppyThread, (void *)DisketteExtension);
    }
#line 2610
    if (! (status >= 0L)) {
#line 2612
      DisketteExtension->ThreadReferenceCount = -1L;
#line 2614
      PagingReferenceCount -= 1UL;
#line 2616
      if (PagingReferenceCount == 0UL) {

      } else {

      }
#line 2627
      return (status);
    } else {

    }
    {
#line 2632
    status = ObReferenceObjectByHandle(threadHandle, 1048576UL, (struct _OBJECT_TYPE *)((void *)0),
                                       (char)0, (PVOID *)(& DisketteExtension->FloppyThread),
                                       (struct _OBJECT_HANDLE_INFORMATION *)((void *)0));
#line 2634
    ZwClose(threadHandle);
    }
#line 2637
    if (! (status >= 0L)) {
#line 2638
      return (status);
    } else {

    }
  } else {

  }
#line 2647
  (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 2648
  if (pended == 0) {
#line 2649
    pended = 1;
  } else {
    {
#line 2652
    errorFn();
    }
  }
  {
#line 2656
  ExfInterlockedInsertTailList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                               & DisketteExtension->ListSpinLock);
#line 2658
  KeReleaseSemaphore(& DisketteExtension->RequestSemaphore, 0L, 1L, (unsigned char)0);
  }
#line 2660
  return (259L);
}
}
#line 2663 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ 

  {
  {
#line 2670
  myStatus = 0L;
#line 2671
  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 2672
  Irp->IoStatus.Information = 1UL;
#line 2673
  IofCompleteRequest(Irp, (char)0);
  }
#line 2675
  return (0L);
}
}
#line 2678 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PDISK_GEOMETRY outputBuffer ;
  NTSTATUS ntStatus ;
  ULONG outputBufferLength ;
  UCHAR i ;
  DRIVE_MEDIA_TYPE lowestDriveMediaType ;
  DRIVE_MEDIA_TYPE highestDriveMediaType ;
  ULONG formatExParametersSize ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  NTSTATUS tmp ;
  PMOUNTDEV_NAME mountName ;
  PMOUNTDEV_UNIQUE_ID uniqueId ;
  BOOLEAN tmp___0 ;
  PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName ;
  WCHAR driveLetterNameBuffer[10] ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;
  PWSTR valueName ;
  UNICODE_STRING driveLetterName ;
  PVOID tmp___1 ;
  int tmp___2 ;

  {
#line 2705
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 2706
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 2709
  if (disketteExtension->HoldNewRequests) {
#line 2710
    if (irpSp->Parameters.DeviceIoControl.IoControlCode != (unsigned long )((50 << 16) | (3 << 14))) {
      {
#line 2712
      ntStatus = FloppyQueueRequest(disketteExtension, Irp);
      }
#line 2715
      return (ntStatus);
    } else {

    }
  } else {

  }
#line 2725
  if (disketteExtension->IsRemoved) {
    {
#line 2727
    Irp->IoStatus.Information = 0UL;
#line 2728
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 2729
    myStatus = -1073741738L;
#line 2730
    IofCompleteRequest(Irp, (char)0);
    }
#line 2732
    return (-1073741738L);
  } else {

  }
#line 2736
  if (! disketteExtension->IsStarted) {
#line 2737
    if (s == NP) {
#line 2738
      s = SKIP1;
    } else {
      {
#line 2741
      errorFn();
      }
    }
    {
#line 2745
    Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 2746
    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 2747
    tmp = IofCallDriver(disketteExtension->TargetObject, Irp);
    }
#line 2749
    return (tmp);
  } else {

  }
#line 2753
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((77UL << 16) | (unsigned long )(2 << 2))) {
    goto switch_16_exp_0;
  } else {
#line 2756
    if (irpSp->Parameters.DeviceIoControl.IoControlCode == 77UL << 16) {
      goto switch_16_exp_1;
    } else {
#line 2759
      if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (6 << 2))) {
        goto switch_16_exp_2;
      } else {
#line 2762
        if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
          goto switch_16_exp_3;
        } else {
#line 2765
          if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (1 << 14)) | (512 << 2))) {
            goto switch_16_exp_4;
          } else {
#line 2768
            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((45 << 16) | (1 << 14)) | (512 << 2))) {
              goto switch_16_exp_5;
            } else {
#line 2771
              if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(7 << 16)) {
                goto switch_16_exp_6;
              } else {
#line 2774
                if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((7 << 16) | (9 << 2))) {
                  goto switch_16_exp_7;
                } else {
#line 2777
                  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((7 << 16) | (768 << 2))) {
                    goto switch_16_exp_8;
                  } else {
#line 2780
                    if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((45 << 16) | (768 << 2))) {
                      goto switch_16_exp_9;
                    } else {
#line 2783
                      if (irpSp->Parameters.DeviceIoControl.IoControlCode == ((77UL << 16) | (unsigned long )(3 << 2))) {
                        goto switch_16_exp_10;
                      } else {
#line 2786
                        if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((7 << 16) | (248 << 2))) {
                          goto switch_16_exp_11;
                        } else {
                          goto switch_16_default;
#line 2791
                          if (0) {
                            switch_16_exp_0: ;
#line 2795
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(MOUNTDEV_NAME )) {
#line 2796
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {

                            }
#line 2801
                            mountName = (struct _MOUNTDEV_NAME *)Irp->AssociatedIrp.SystemBuffer;
#line 2802
                            mountName->NameLength = disketteExtension->DeviceName.Length;
#line 2803
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )(sizeof(USHORT ) + (unsigned int )mountName->NameLength)) {
#line 2804
                              ntStatus = -2147483643L;
#line 2805
                              Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_NAME );
                              goto switch_16_break;
                            } else {

                            }
                            {
#line 2811
                            memcpy((void *)(mountName->Name), (void const   *)disketteExtension->DeviceName.Buffer,
                                   (unsigned int )mountName->NameLength);
#line 2813
                            ntStatus = 0L;
#line 2814
                            Irp->IoStatus.Information = (unsigned long )(sizeof(USHORT ) + (unsigned int )mountName->NameLength);
                            }
                            goto switch_16_break;
                            switch_16_exp_1: ;
#line 2820
                            if (! disketteExtension->InterfaceString.Buffer) {
#line 2821
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {
#line 2824
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(MOUNTDEV_UNIQUE_ID )) {
#line 2825
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                            }
#line 2831
                            uniqueId = (struct _MOUNTDEV_UNIQUE_ID *)Irp->AssociatedIrp.SystemBuffer;
#line 2832
                            uniqueId->UniqueIdLength = disketteExtension->InterfaceString.Length;
#line 2833
                            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )(sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength)) {
#line 2834
                              ntStatus = -2147483643L;
#line 2835
                              Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_UNIQUE_ID );
                              goto switch_16_break;
                            } else {

                            }
                            {
#line 2841
                            memcpy((void *)(uniqueId->UniqueId), (void const   *)disketteExtension->InterfaceString.Buffer,
                                   (unsigned int )uniqueId->UniqueIdLength);
#line 2843
                            ntStatus = 0L;
#line 2844
                            Irp->IoStatus.Information = (unsigned long )(sizeof(USHORT ) + (unsigned int )uniqueId->UniqueIdLength);
                            }
                            goto switch_16_break;
                            switch_16_exp_2: ;
                            switch_16_exp_3: ;
#line 2849
                            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(FORMAT_PARAMETERS )) {
#line 2852
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            } else {

                            }
                            {
#line 2858
                            tmp___0 = FlCheckFormatParameters(disketteExtension, (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer);
                            }
#line 2860
                            if (tmp___0) {

                            } else {
#line 2865
                              ntStatus = -1073741811L;
                              goto switch_16_break;
                            }
#line 2868
                            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((7 << 16) | (3 << 14)) | (11 << 2))) {
#line 2869
                              if (irpSp->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(FORMAT_EX_PARAMETERS )) {
#line 2870
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
#line 2875
                              formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
#line 2876
                              formatExParametersSize = (unsigned long )((long )(& ((FORMAT_EX_PARAMETERS *)0)->SectorNumber)) + (unsigned long )((unsigned int )formatExParameters->SectorsPerTrack * sizeof(USHORT ));
#line 2877
                              if (irpSp->Parameters.DeviceIoControl.InputBufferLength < formatExParametersSize) {
#line 2878
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {
#line 2881
                                if ((int )formatExParameters->FormatGapLength >= 256) {
#line 2882
                                  ntStatus = -1073741811L;
                                  goto switch_16_break;
                                } else {
#line 2885
                                  if ((int )formatExParameters->SectorsPerTrack >= 256) {
#line 2886
                                    ntStatus = -1073741811L;
                                    goto switch_16_break;
                                  } else {

                                  }
                                }
                              }
                            } else {

                            }
                            switch_16_exp_4: ;
                            switch_16_exp_5: ;
                            switch_16_exp_6: ;
                            switch_16_exp_7: 
                            {
#line 2903
                            ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                            }
                            goto switch_16_break;
                            switch_16_exp_8: ;
                            switch_16_exp_9: 
#line 2910
                            lowestDriveMediaType = (DriveMediaLimits + (int )disketteExtension->DriveType)->LowestDriveMediaType;
#line 2911
                            highestDriveMediaType = (DriveMediaLimits + (int )disketteExtension->DriveType)->HighestDriveMediaType;
#line 2912
                            outputBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
#line 2913
                            if (outputBufferLength < (unsigned long )sizeof(DISK_GEOMETRY )) {
#line 2916
                              ntStatus = -1073741789L;
                              goto switch_16_break;
                            } else {

                            }
#line 2921
                            ntStatus = 0L;
#line 2922
                            if (outputBufferLength < (unsigned long )(sizeof(DISK_GEOMETRY ) * (unsigned int )(((int )highestDriveMediaType - (int )lowestDriveMediaType) + 1))) {
#line 2925
                              ntStatus = -2147483643L;
#line 2926
                              highestDriveMediaType = (enum _DRIVE_MEDIA_TYPE )((unsigned long )((int )lowestDriveMediaType - 1) + outputBufferLength / (unsigned long )sizeof(DISK_GEOMETRY ));
                            } else {

                            }
#line 2930
                            outputBuffer = (struct _DISK_GEOMETRY *)Irp->AssociatedIrp.SystemBuffer;
#line 2931
                            i = (unsigned char )lowestDriveMediaType;
                            {
#line 2933
                            while (1) {
                              while_2_continue: /* CIL Label */ ;

#line 2935
                              if ((int )i <= (int )((unsigned char )highestDriveMediaType)) {

                              } else {
                                goto while_25_break;
                              }
#line 2940
                              outputBuffer->MediaType = (DriveMediaConstants + (int )i)->MediaType;
#line 2941
                              outputBuffer->Cylinders.__annonCompField1.LowPart = (unsigned long )((int )(DriveMediaConstants + (int )i)->MaximumTrack + 1);
#line 2942
                              outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 2943
                              outputBuffer->TracksPerCylinder = (unsigned long )(DriveMediaConstants + (int )i)->NumberOfHeads;
#line 2944
                              outputBuffer->SectorsPerTrack = (unsigned long )(DriveMediaConstants + (int )i)->SectorsPerTrack;
#line 2945
                              outputBuffer->BytesPerSector = (unsigned long )(DriveMediaConstants + (int )i)->BytesPerSector;
#line 2948
                              outputBuffer += 1;
#line 2949
                              Irp->IoStatus.Information += (unsigned long )sizeof(DISK_GEOMETRY );
#line 2950
                              i = (unsigned char )((int )i + 1);
                            }
                            while_2_break: /* CIL Label */ ;
                            }
                            while_25_break: ;
                            goto switch_16_break;
                            switch_16_exp_10: ;
#line 2956
                            if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 2959
                              if (! (DeviceObject->Characteristics & 1UL)) {
#line 2960
                                ntStatus = -1073741275L;
                                goto switch_16_break;
                              } else {

                              }
#line 2965
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(MOUNTDEV_SUGGESTED_LINK_NAME )) {
#line 2966
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                              {
#line 2972
                              tmp___1 = ExAllocatePoolWithTag((enum _POOL_TYPE )1,
                                                              (unsigned long )(sizeof(WCHAR ) * 64U),
                                                              1886350406UL);
#line 2974
                              valueName = (WCHAR *)tmp___1;
                              }
#line 2976
                              if (! valueName) {
#line 2977
                                ntStatus = -1073741670L;
                                goto switch_16_break;
                              } else {

                              }
                              {
#line 2983
                              memset((void *)valueName, 0, sizeof(WCHAR ) * 64U);
#line 2984
                              memcpy((void *)valueName, (void const   *)disketteExtension->DeviceName.Buffer,
                                     (unsigned int )disketteExtension->DeviceName.Length);
#line 2986
                              driveLetterName.Buffer = driveLetterNameBuffer;
#line 2987
                              driveLetterName.MaximumLength = (unsigned short)20;
#line 2988
                              driveLetterName.Length = (unsigned short)0;
#line 2989
                              memset((void *)(queryTable), 0, 2U * sizeof(RTL_QUERY_REGISTRY_TABLE ));
#line 2990
                              queryTable[0].Flags = 36UL;
#line 2991
                              queryTable[0].Name = valueName;
#line 2992
                              queryTable[0].EntryContext = (void *)(& driveLetterName);
#line 2993
                              ntStatus = RtlQueryRegistryValues(0UL, (WCHAR const   *)"\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                                                                queryTable, (void *)0,
                                                                (void *)0);
                              }
#line 2997
                              if (! (ntStatus >= 0L)) {
                                goto switch_16_break;
                              } else {

                              }
#line 3005
                              if ((int )driveLetterName.Length != 4) {
#line 3007
                                ntStatus = -1073741275L;
                                goto switch_16_break;
                              } else {
#line 3012
                                if ((int )*(driveLetterName.Buffer + 0) < 65) {
#line 3014
                                  ntStatus = -1073741275L;
                                  goto switch_16_break;
                                } else {
#line 3019
                                  if ((int )*(driveLetterName.Buffer + 0) > 90) {
#line 3021
                                    ntStatus = -1073741275L;
                                    goto switch_16_break;
                                  } else {
#line 3026
                                    if ((int )*(driveLetterName.Buffer + 1) != 58) {
#line 3028
                                      ntStatus = -1073741275L;
                                      goto switch_16_break;
                                    } else {

                                    }
                                  }
                                }
                              }
#line 3038
                              suggestedName = (struct _MOUNTDEV_SUGGESTED_LINK_NAME *)Irp->AssociatedIrp.SystemBuffer;
#line 3039
                              suggestedName->UseOnlyIfThereAreNoOtherLinks = (unsigned char)1;
#line 3040
                              suggestedName->NameLength = (unsigned short)28;
#line 3041
                              Irp->IoStatus.Information = (unsigned long )((long )(& ((MOUNTDEV_SUGGESTED_LINK_NAME *)0)->Name) + 28L);
#line 3042
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < Irp->IoStatus.Information) {
#line 3044
                                Irp->IoStatus.Information = (unsigned long )sizeof(MOUNTDEV_SUGGESTED_LINK_NAME );
#line 3045
                                ntStatus = -2147483643L;
                                goto switch_16_break;
                              } else {

                              }
                              {
#line 3053
                              RtlDeleteRegistryValue(0UL, (WCHAR const   *)"\\\000R\000e\000g\000i\000s\000t\000r\000y\000\\\000M\000a\000c\000h\000i\000n\000e\000\\\000S\000y\000s\000t\000e\000m\000\\\000D\000I\000S\000K\000",
                                                     (WCHAR const   *)valueName);
#line 3056
                              memcpy((void *)(suggestedName->Name), (void const   *)"\\\000D\000o\000s\000D\000e\000v\000i\000c\000e\000s\000\\\000",
                                     24U);
#line 3058
                              suggestedName->Name[12] = *(driveLetterName.Buffer + 0);
#line 3059
                              suggestedName->Name[13] = (unsigned short )':';
                              }
                              goto switch_16_break;
                            } else {

                            }
                            switch_16_exp_11: ;
#line 3066
                            if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3069
                              if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SENSE_DEVISE_STATUS_PTOS )) {
#line 3072
                                ntStatus = -1073741811L;
                                goto switch_16_break;
                              } else {

                              }
                              {
#line 3080
                              ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                              }
                              goto switch_16_break;
                            } else {

                            }
                            switch_16_default: ;
#line 3087
                            if (s == NP) {
#line 3088
                              s = SKIP1;
                            } else {
                              {
#line 3091
                              errorFn();
                              }
                            }
                            {
#line 3095
                            Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3096
                            Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3097
                            ntStatus = IofCallDriver(disketteExtension->TargetObject,
                                                     Irp);
                            }
#line 3100
                            return (ntStatus);
                          } else {
                            switch_16_break: ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3117
  if (ntStatus != 259L) {
#line 3118
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3119
    myStatus = ntStatus;
#line 3120
    if (! (ntStatus >= 0L)) {
#line 3121
      if (ntStatus == -1073741661L) {
#line 3122
        tmp___2 = 1;
      } else {
#line 3124
        if (ntStatus == -1073741643L) {
#line 3125
          tmp___2 = 1;
        } else {
#line 3127
          if (ntStatus == -1073741662L) {
#line 3128
            tmp___2 = 1;
          } else {
#line 3130
            if (ntStatus == -1073741805L) {
#line 3131
              tmp___2 = 1;
            } else {
#line 3133
              if (ntStatus == -2147483626L) {
#line 3134
                tmp___2 = 1;
              } else {
#line 3136
                if (ntStatus == -1073741804L) {
#line 3137
                  tmp___2 = 1;
                } else {
#line 3139
                  if (ntStatus == -1073741806L) {
#line 3140
                    tmp___2 = 1;
                  } else {
#line 3142
                    tmp___2 = 0;
                  }
                }
              }
            }
          }
        }
      }
#line 3150
      if ((unsigned char )tmp___2) {

      } else {

      }
    } else {

    }
    {
#line 3161
    IofCompleteRequest(Irp, (char)0);
    }
  } else {

  }
#line 3166
  return (ntStatus);
}
}
#line 3169 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  KEVENT doneEvent ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  PCONFIGURATION_INFORMATION tmp ;

  {
#line 3180
  ntStatus = 0L;
#line 3185
  PagingReferenceCount += 1UL;
#line 3187
  if (PagingReferenceCount == 1UL) {

  } else {

  }
#line 3196
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3197
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3199
  if (disketteExtension->IsRemoved) {
    {
#line 3201
    Irp->IoStatus.Information = 0UL;
#line 3202
    Irp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 3203
    myStatus = -1073741738L;
#line 3204
    IofCompleteRequest(Irp, (char)0);
    }
#line 3206
    return (-1073741738L);
  } else {

  }
#line 3210
  if ((int )irpSp->MinorFunction == 0) {
    goto switch_32_0;
  } else {
#line 3213
    if ((int )irpSp->MinorFunction == 5) {
      goto switch_32_5;
    } else {
#line 3216
      if ((int )irpSp->MinorFunction == 1) {
        goto switch_32_1;
      } else {
#line 3219
        if ((int )irpSp->MinorFunction == 6) {
          goto switch_32_6;
        } else {
#line 3222
          if ((int )irpSp->MinorFunction == 3) {
            goto switch_32_3;
          } else {
#line 3225
            if ((int )irpSp->MinorFunction == 4) {
              goto switch_32_4;
            } else {
#line 3228
              if ((int )irpSp->MinorFunction == 2) {
                goto switch_32_2;
              } else {
                goto switch_32_default;
#line 3233
                if (0) {
                  switch_32_0: 
                  {
#line 3236
                  ntStatus = FloppyStartDevice(DeviceObject, Irp);
                  }
                  goto switch_32_break;
                  switch_32_5: ;
                  switch_32_1: ;
#line 3241
                  if ((int )irpSp->MinorFunction == 5) {

                  } else {

                  }
#line 3248
                  if (! disketteExtension->IsStarted) {
#line 3249
                    if (s == NP) {
#line 3250
                      s = SKIP1;
                    } else {
                      {
#line 3253
                      errorFn();
                      }
                    }
                    {
#line 3257
                    Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3258
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3259
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
#line 3261
                    return (ntStatus);
                  } else {

                  }
                  {
#line 3267
                  disketteExtension->HoldNewRequests = (unsigned char)1;
#line 3269
                  ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
                  }
#line 3271
                  if (ntStatus == 259L) {
                    {
#line 3273
                    KeWaitForSingleObject((void *)disketteExtension->FloppyThread,
                                          (enum _KWAIT_REASON )0, (char)0, (unsigned char)0,
                                          (LARGE_INTEGER *)((void *)0));
                    }
#line 3276
                    if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {

                    } else {

                    }
#line 3283
                    disketteExtension->FloppyThread = (struct _KTHREAD *)((void *)0);
#line 3284
                    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3285
                    myStatus = 0L;
#line 3286
                    if (s == NP) {
#line 3287
                      s = SKIP1;
                    } else {
                      {
#line 3290
                      errorFn();
                      }
                    }
                    {
#line 3294
                    Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3295
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3296
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                  } else {
                    {
#line 3300
                    ntStatus = -1073741823L;
#line 3301
                    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3302
                    myStatus = ntStatus;
#line 3303
                    Irp->IoStatus.Information = 0UL;
#line 3304
                    IofCompleteRequest(Irp, (char)0);
                    }
                  }
                  goto switch_32_break;
                  switch_32_6: ;
                  switch_32_3: ;
#line 3310
                  if ((int )irpSp->MinorFunction == 6) {

                  } else {

                  }
#line 3317
                  if (! disketteExtension->IsStarted) {
#line 3318
                    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3319
                    myStatus = 0L;
#line 3320
                    if (s == NP) {
#line 3321
                      s = SKIP1;
                    } else {
                      {
#line 3324
                      errorFn();
                      }
                    }
                    {
#line 3328
                    Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3329
                    Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3330
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
                  } else {
                    {
#line 3334
                    Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3335
                    myStatus = 0L;
#line 3336
                    irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3337
                    nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 3338
                    memcpy((void *)nextIrpSp, (void const   *)irpSp___0, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 3339
                    nextIrpSp->Control = (unsigned char)0;
                    }
#line 3342
                    if (s != NP) {
                      {
#line 3344
                      errorFn();
                      }
                    } else {
#line 3347
                      if (compRegistered != 0) {
                        {
#line 3349
                        errorFn();
                        }
                      } else {
#line 3352
                        compRegistered = 1;
#line 3353
                        compFptr = & FloppyPnpComplete;
                      }
                    }
                    {
#line 3357
                    irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 3358
                    irpSp___1->CompletionRoutine = & FloppyPnpComplete;
#line 3359
                    irpSp___1->Context = (void *)(& doneEvent);
#line 3360
                    irpSp___1->Control = (unsigned char)0;
#line 3361
                    irpSp___1->Control = (unsigned char)64;
#line 3362
                    irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 128);
#line 3363
                    irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 32);
#line 3364
                    ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                    }
#line 3366
                    if (ntStatus == 259L) {
                      {
#line 3368
                      KeWaitForSingleObject((void *)(& doneEvent), (enum _KWAIT_REASON )0,
                                            (char)0, (unsigned char)0, (LARGE_INTEGER *)((void *)0));
#line 3369
                      ntStatus = myStatus;
                      }
                    } else {

                    }
                    {
#line 3376
                    disketteExtension->HoldNewRequests = (unsigned char)0;
#line 3378
                    FloppyProcessQueuedRequests(disketteExtension);
#line 3379
                    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3380
                    myStatus = ntStatus;
#line 3381
                    Irp->IoStatus.Information = 0UL;
#line 3382
                    IofCompleteRequest(Irp, (char)0);
                    }
                  }
                  goto switch_32_break;
                  switch_32_4: 
#line 3389
                  disketteExtension->IsStarted = (unsigned char)0;
#line 3390
                  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3391
                  myStatus = 0L;
#line 3392
                  if (s == NP) {
#line 3393
                    s = SKIP1;
                  } else {
                    {
#line 3396
                    errorFn();
                    }
                  }
                  {
#line 3400
                  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3401
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3402
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
                  goto switch_32_break;
                  switch_32_2: 
                  {
#line 3410
                  disketteExtension->HoldNewRequests = (unsigned char)0;
#line 3412
                  disketteExtension->IsStarted = (unsigned char)0;
#line 3413
                  disketteExtension->IsRemoved = (unsigned char)1;
#line 3414
                  FloppyProcessQueuedRequests(disketteExtension);
                  }
#line 3416
                  if (s == NP) {
#line 3417
                    s = SKIP1;
                  } else {
                    {
#line 3420
                    errorFn();
                    }
                  }
                  {
#line 3424
                  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3425
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3426
                  Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3427
                  myStatus = 0L;
#line 3428
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
#line 3430
                  if ((unsigned int )disketteExtension->InterfaceString.Buffer != (unsigned int )((void *)0)) {
                    {
#line 3432
                    IoSetDeviceInterfaceState(& disketteExtension->InterfaceString,
                                              (unsigned char)0);
                    }
                  } else {

                  }
#line 3444
                  if ((int )disketteExtension->ArcName.Length != 0) {
                    {
#line 3446
                    IoDeleteSymbolicLink(& disketteExtension->ArcName);
                    }
                  } else {

                  }
                  {
#line 3456
                  tmp = IoGetConfigurationInformation();
#line 3457
                  tmp->FloppyCount -= 1UL;
                  }
                  goto switch_32_break;
                  switch_32_default: ;
#line 3463
                  if (s == NP) {
#line 3464
                    s = SKIP1;
                  } else {
                    {
#line 3467
                    errorFn();
                    }
                  }
                  {
#line 3471
                  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3472
                  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3473
                  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
                  }
                } else {
                  switch_32_break: ;
                }
              }
            }
          }
        }
      }
    }
  }
#line 3488
  PagingReferenceCount -= 1UL;
#line 3490
  if (PagingReferenceCount == 0UL) {

  } else {

  }
#line 3500
  return (ntStatus);
}
}
#line 3503 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS ntStatus ;
  NTSTATUS pnpStatus ;
  KEVENT doneEvent ;
  FDC_INFO fdcInfo ;
  CONFIGURATION_TYPE Dc ;
  CONFIGURATION_TYPE Fp ;
  PDISKETTE_EXTENSION disketteExtension ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION irpSp___0 ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___1 ;
  INTERFACE_TYPE InterfaceType ;

  {
  {
#line 3518
  Dc = (enum _CONFIGURATION_TYPE )13;
#line 3519
  Fp = (enum _CONFIGURATION_TYPE )26;
#line 3520
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3521
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3530
  irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3531
  nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 3532
  memcpy((void *)nextIrpSp, (void const   *)irpSp___0, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 3533
  nextIrpSp->Control = (unsigned char)0;
  }
#line 3535
  if (s != NP) {
    {
#line 3537
    errorFn();
    }
  } else {
#line 3540
    if (compRegistered != 0) {
      {
#line 3542
      errorFn();
      }
    } else {
#line 3545
      compRegistered = 1;
#line 3546
      compFptr = & FloppyPnpComplete;
    }
  }
  {
#line 3550
  irpSp___1 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 3551
  irpSp___1->CompletionRoutine = & FloppyPnpComplete;
#line 3552
  irpSp___1->Context = (void *)(& doneEvent);
#line 3553
  irpSp___1->Control = (unsigned char)0;
#line 3554
  irpSp___1->Control = (unsigned char)64;
#line 3555
  irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 128);
#line 3556
  irpSp___1->Control = (unsigned char )((int )irpSp___1->Control | 32);
#line 3557
  ntStatus = IofCallDriver(disketteExtension->TargetObject, Irp);
  }
#line 3559
  if (ntStatus == 259L) {
    {
#line 3561
    ntStatus = KeWaitForSingleObject((void *)(& doneEvent), (enum _KWAIT_REASON )0,
                                     (char)0, (unsigned char)0, (LARGE_INTEGER *)((void *)0));
#line 3562
    ntStatus = myStatus;
    }
  } else {

  }
  {
#line 3568
  fdcInfo.BufferCount = 0UL;
#line 3569
  fdcInfo.BufferSize = 0UL;
#line 3570
  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (770 << 2)) | 3),
                           (void *)(& fdcInfo));
  }
#line 3573
  if (ntStatus >= 0L) {
#line 3574
    disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;
#line 3575
    if (fdcInfo.AcpiBios) {
#line 3576
      if (fdcInfo.AcpiFdiSupported) {
        {
#line 3578
        ntStatus = FlAcpiConfigureFloppy(disketteExtension, & fdcInfo);
        }
#line 3580
        if ((int )disketteExtension->DriveType == 4) {
#line 3581
          disketteExtension->PerpendicularMode = (unsigned char )((int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber));
        } else {

        }
      } else {
        goto _L;
      }
    } else {
      _L: 
#line 3590
      if ((int )disketteExtension->DriveType == 4) {
#line 3591
        disketteExtension->PerpendicularMode = (unsigned char )((int )disketteExtension->PerpendicularMode | (1 << fdcInfo.PeripheralNumber));
      } else {

      }
#line 3595
      InterfaceType = (enum _INTERFACE_TYPE )0;
      {
#line 3597
      while (1) {
        while_3_continue: /* CIL Label */ ;

#line 3599
        if ((int )InterfaceType < 16) {

        } else {
          goto while_43_break;
        }
        {
#line 3605
        fdcInfo.BusType = InterfaceType;
#line 3606
        ntStatus = IoQueryDeviceDescription(& fdcInfo.BusType, & fdcInfo.BusNumber,
                                            & Dc, & fdcInfo.ControllerNumber, & Fp,
                                            & fdcInfo.PeripheralNumber, & FlConfigCallBack,
                                            (void *)disketteExtension);
        }
#line 3611
        if (ntStatus >= 0L) {
          goto while_43_break;
        } else {

        }
#line 3618
        InterfaceType = (enum _INTERFACE_TYPE )((int )InterfaceType + 1);
      }
      while_3_break: /* CIL Label */ ;
      }
      while_43_break: ;
    }
#line 3623
    if (ntStatus >= 0L) {
#line 3624
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 3625
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.UnitNumber;
#line 3626
        disketteExtension->DriveOnValue = (unsigned char )fdcInfo.UnitNumber;
      } else {
#line 3628
        disketteExtension->DeviceUnit = (unsigned char )fdcInfo.PeripheralNumber;
#line 3629
        disketteExtension->DriveOnValue = (unsigned char )(fdcInfo.PeripheralNumber | (unsigned long )(16 << fdcInfo.PeripheralNumber));
      }
      {
#line 3632
      pnpStatus = IoRegisterDeviceInterface(disketteExtension->UnderlyingPDO, (GUID const   *)((GUID *)(& MOUNTDEV_MOUNTED_DEVICE_GUID)),
                                            (UNICODE_STRING *)((void *)0), & disketteExtension->InterfaceString);
      }
#line 3635
      if (pnpStatus >= 0L) {
        {
#line 3637
        pnpStatus = IoSetDeviceInterfaceState(& disketteExtension->InterfaceString,
                                              (unsigned char)1);
        }
      } else {

      }
      {
#line 3644
      disketteExtension->IsStarted = (unsigned char)1;
#line 3646
      disketteExtension->HoldNewRequests = (unsigned char)0;
#line 3648
      FloppyProcessQueuedRequests(disketteExtension);
      }
    } else {

    }
  } else {

  }
  {
#line 3657
  Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3658
  myStatus = ntStatus;
#line 3659
  IofCompleteRequest(Irp, (char)0);
  }
#line 3661
  return (ntStatus);
}
}
#line 3664 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) 
{ 

  {
  {
#line 3669
  KeSetEvent((struct _KEVENT *)Context, 1L, (unsigned char)0);
  }
#line 3671
  return (-1073741802L);
}
}
#line 3674 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  PIO_STACK_LOCATION irpSp ;
  POWER_STATE_TYPE type ;
  POWER_STATE state ;
  BOOLEAN WaitForCompletion ;

  {
#line 3683
  ntStatus = myStatus;
#line 3684
  WaitForCompletion = (unsigned char)1;
#line 3687
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3688
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3689
  type = irpSp->Parameters.Power.Type;
#line 3690
  state = irpSp->Parameters.Power.State;
#line 3691
  if ((int )irpSp->MinorFunction == 3) {
    goto switch_46_3;
  } else {
#line 3694
    if ((int )irpSp->MinorFunction == 2) {
      goto switch_46_2;
    } else {
      goto switch_46_default;
#line 3699
      if (0) {
        switch_46_3: ;
#line 3703
        if ((int )type == 0) {
#line 3704
          if ((int )state.SystemState > 5) {
#line 3705
            ntStatus = 0L;
            goto switch_46_break;
          } else {

          }
        } else {

        }
#line 3716
        if (disketteExtension->ThreadReferenceCount >= 0L) {
          {
#line 3724
          Irp->IoStatus.Information = 0UL;
#line 3725
          Irp->IoStatus.__annonCompField4.Status = -2147483631L;
#line 3726
          myStatus = -2147483631L;
#line 3727
          IofCompleteRequest(Irp, (char)0);
          }
#line 3729
          return (-2147483631L);
        } else {

        }
#line 3735
        ntStatus = 0L;
        goto switch_46_break;
        switch_46_2: ;
#line 3739
        if ((int )type == 0) {
#line 3743
          if ((int )state.SystemState == 1) {
#line 3746
            disketteExtension->PoweringDown = (unsigned char)0;
#line 3747
            WaitForCompletion = (unsigned char)0;
          } else {
#line 3751
            WaitForCompletion = (unsigned char)1;
#line 3752
            disketteExtension->PoweringDown = (unsigned char)1;
          }
#line 3757
          if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
#line 3758
            if ((int )WaitForCompletion == 1) {
              {
#line 3760
              KeWaitForSingleObject((void *)disketteExtension->FloppyThread, (enum _KWAIT_REASON )0,
                                    (char)0, (unsigned char)0, (LARGE_INTEGER *)((void *)0));
              }
            } else {

            }
          } else {

          }
        } else {

        }
#line 3773
        ntStatus = 0L;
        goto switch_46_break;
        switch_46_default: ;
        goto switch_46_break;
      } else {
        switch_46_break: ;
      }
    }
  }
#line 3786
  if (s == NP) {
#line 3787
    s = SKIP1;
  } else {
    {
#line 3790
    errorFn();
    }
  }
  {
#line 3794
  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3795
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3796
  ntStatus = PoCallDriver(disketteExtension->TargetObject, Irp);
  }
#line 3798
  return (ntStatus);
}
}
#line 3801 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  NTSTATUS ntStatus ;
  PDISKETTE_EXTENSION disketteExtension ;

  {
#line 3810
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3811
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3814
  if (disketteExtension->HoldNewRequests) {
    {
#line 3816
    ntStatus = FloppyQueueRequest(disketteExtension, Irp);
    }
#line 3819
    return (ntStatus);
  } else {

  }
#line 3826
  if (disketteExtension->IsRemoved) {
    goto _L;
  } else {
#line 3829
    if (! disketteExtension->IsStarted) {
      _L: 
#line 3831
      if (disketteExtension->IsRemoved) {
#line 3832
        ntStatus = -1073741738L;
      } else {
#line 3834
        ntStatus = -1073741823L;
      }
      {
#line 3837
      Irp->IoStatus.Information = 0UL;
#line 3838
      Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3839
      myStatus = ntStatus;
#line 3840
      IofCompleteRequest(Irp, (char)0);
      }
#line 3842
      return (ntStatus);
    } else {

    }
  }
#line 3847
  if ((int )disketteExtension->MediaType > 0) {
#line 3848
    if (irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart + irpSp->Parameters.Read.Length > disketteExtension->ByteCapacity) {
      goto _L___1;
    } else {
#line 3851
      if ((irpSp->Parameters.Read.Length & (disketteExtension->BytesPerSector - 1UL)) != 0UL) {
        _L___1: 
#line 3857
        ntStatus = -1073741811L;
      } else {
        goto _L___0;
      }
    }
  } else {
    _L___0: 
#line 3864
    if (irpSp->Parameters.Read.Length) {
      {
#line 3868
      ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
      }
    } else {
      {
#line 3871
      Irp->IoStatus.Information = 0UL;
#line 3872
      Irp->IoStatus.__annonCompField4.Status = 0L;
#line 3873
      myStatus = 0L;
#line 3877
      IofCompleteRequest(Irp, (char)0);
      }
#line 3879
      return (0L);
    }
  }
#line 3882
  if (ntStatus != 259L) {
    {
#line 3883
    Irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 3884
    myStatus = ntStatus;
#line 3888
    IofCompleteRequest(Irp, (char)0);
    }
  } else {

  }
#line 3893
  return (ntStatus);
}
}
#line 3896 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) 
{ 

  {
#line 3900
  if ((int )StatusRegister1 & 32) {
    goto _L;
  } else {
#line 3903
    if ((int )StatusRegister2 & 32) {
      _L: ;
#line 3907
      return (-1073741761L);
    } else {

    }
  }
#line 3912
  if ((int )StatusRegister1 & 16) {
#line 3915
    return (-1073741764L);
  } else {

  }
#line 3919
  if ((int )StatusRegister1 & 4) {
    goto _L___0;
  } else {
#line 3922
    if ((int )StatusRegister1 & 128) {
      _L___0: ;
#line 3926
      return (-1073741803L);
    } else {

    }
  }
#line 3931
  if ((int )StatusRegister2 & 1) {
    goto _L___1;
  } else {
#line 3934
    if ((int )StatusRegister2 & 2) {
      goto _L___1;
    } else {
#line 3937
      if ((int )StatusRegister2 & 64) {
        _L___1: ;
#line 3941
        return (-1073741668L);
      } else {

      }
    }
  }
#line 3947
  if ((int )StatusRegister1 & 2) {
#line 3950
    return (-1073741662L);
  } else {

  }
#line 3954
  if ((int )StatusRegister1 & 1) {
#line 3957
    return (-1073741467L);
  } else {

  }
#line 3961
  if ((int )StatusRegister2 & 16) {
#line 3964
    return (-1073741466L);
  } else {

  }
#line 3970
  return (-1073741465L);
}
}
#line 3973 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  int tmp ;

  {
#line 3980
  if (myStatus != 0L) {
#line 3981
    if (DisketteExtension->HardwareFailed) {
#line 3982
      DisketteExtension->HardwareFailCount = (unsigned char )((int )DisketteExtension->HardwareFailCount + 1);
#line 3983
      if ((int )DisketteExtension->HardwareFailCount < 2) {
        {
#line 3985
        ntStatus = FlInitializeControllerHardware(DisketteExtension);
        }
#line 3987
        if (ntStatus >= 0L) {
          {
#line 3990
          DisketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
#line 3995
          DisketteExtension->ThreadReferenceCount += 1L;
#line 3997
          ExfInterlockedInsertHeadList(& DisketteExtension->ListEntry, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                       & DisketteExtension->ListSpinLock);
          }
#line 4000
          return;
        } else {

        }
      } else {

      }
    } else {

    }
  } else {

  }
#line 4015
  DisketteExtension->HardwareFailCount = (unsigned char)0;
#line 4016
  if (! (myStatus >= 0L)) {
#line 4017
    if (myStatus == -1073741661L) {
#line 4018
      tmp = 1;
    } else {
#line 4020
      if (myStatus == -1073741643L) {
#line 4021
        tmp = 1;
      } else {
#line 4023
        if (myStatus == -1073741662L) {
#line 4024
          tmp = 1;
        } else {
#line 4026
          if (myStatus == -1073741805L) {
#line 4027
            tmp = 1;
          } else {
#line 4029
            if (myStatus == -2147483626L) {
#line 4030
              tmp = 1;
            } else {
#line 4032
              if (myStatus == -1073741804L) {
#line 4033
                tmp = 1;
              } else {
#line 4035
                if (myStatus == -1073741806L) {
#line 4036
                  tmp = 1;
                } else {
#line 4038
                  tmp = 0;
                }
              }
            }
          }
        }
      }
    }
#line 4046
    if ((unsigned char )tmp) {

    } else {

    }
  } else {

  }
#line 4056
  if (myStatus != 0L) {
#line 4057
    if (myStatus != -2147483626L) {
#line 4058
      if (myStatus != -1073741805L) {

      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: ;
  }
  {
#line 4077
  IofCompleteRequest(Irp, (char)1);
  }
#line 4079
  return;
}
}
#line 4082 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN WriteOperation ,
                      BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) 
{ LARGE_INTEGER delay ;
  BOOLEAN motorStarted ;
  UCHAR driveStatus ;
  NTSTATUS ntStatus ;
  FDC_ENABLE_PARMS fdcEnableParms ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;

  {
#line 4092
  ntStatus = 0L;
#line 4095
  *(DriveMediaConstants + (int )(DriveMediaLimits + (int )DisketteExtension->DriveType)->HighestDriveMediaType) = DisketteExtension->BiosDriveMediaConstants;
#line 4096
  if ((int )DisketteExtension->MediaType == -1) {
#line 4097
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
  } else {
#line 4099
    if ((int )DisketteExtension->MediaType == 0) {
#line 4100
      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + 0);
    } else {

    }
  }
#line 4105
  fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
#line 4106
  if (WriteOperation) {
#line 4107
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeWrite;
  } else {
#line 4109
    fdcEnableParms.TimeToWait = DisketteExtension->DriveMediaConstants.MotorSettleTimeRead;
  }
  {
#line 4112
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (774 << 2)) | 3),
                           (void *)(& fdcEnableParms));
#line 4114
  motorStarted = fdcEnableParms.MotorStarted;
  }
#line 4116
  if (ntStatus >= 0L) {
    {
#line 4118
    fdcDiskChangeParms.DriveOnValue = DisketteExtension->DriveOnValue;
#line 4119
    ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                             (void *)(& fdcDiskChangeParms));
#line 4121
    driveStatus = fdcDiskChangeParms.DriveStatus;
    }
  } else {

  }
#line 4126
  if (! (ntStatus >= 0L)) {
#line 4127
    return (ntStatus);
  } else {

  }
#line 4131
  if ((int )DisketteExtension->DriveType == 0) {
#line 4132
    if (motorStarted) {
      goto _L___1;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: 
#line 4139
    if ((int )DisketteExtension->DriveType != 0) {
#line 4140
      if ((int )driveStatus & 128) {
        _L___1: 
#line 4144
        DisketteExtension->MediaType = (enum _MEDIA_TYPE )-1;
#line 4145
        if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 4146
          if (Irp) {

          } else {

          }
#line 4153
          (DisketteExtension->DeviceObject)->Flags |= 2UL;
        } else {

        }
#line 4157
        if ((int )DisketteExtension->DriveType != 0) {
#line 4158
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
            {
#line 4160
            DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 4161
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4162
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
            }
#line 4166
            if (! (ntStatus >= 0L)) {
#line 4169
              return (ntStatus);
            } else {

            }
#line 4173
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 4174
              driveStatus = (unsigned char)127;
            } else {
#line 4176
              driveStatus = (unsigned char)128;
            }
#line 4178
            if ((int )driveStatus & 128) {
#line 4181
              if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 4182
                (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
              } else {

              }
#line 4186
              return (-1073741805L);
            } else {

            }
          } else {

          }
          {
#line 4194
          DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 4195
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4196
          DisketteExtension->FifoBuffer[2] = (unsigned char)1;
#line 4197
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
          }
#line 4200
          if (! (ntStatus >= 0L)) {
#line 4203
            return (ntStatus);
          } else {
#line 4205
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L;
            } else {
#line 4208
              if ((int )DisketteExtension->FifoBuffer[1] != 1) {
                _L: 
#line 4212
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4213
                return (-1073741464L);
              } else {

              }
            }
          }
          {
#line 4220
          DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 4221
          DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4222
          DisketteExtension->FifoBuffer[2] = (unsigned char)0;
#line 4223
          delay.__annonCompField1.LowPart = 4294966396UL;
#line 4224
          delay.__annonCompField1.HighPart = -1L;
#line 4225
          KeDelayExecutionThread((char)0, (unsigned char)0, & delay);
#line 4226
          ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
#line 4228
          delay.__annonCompField1.LowPart = 4294967291UL;
#line 4229
          delay.__annonCompField1.HighPart = -1L;
#line 4230
          KeDelayExecutionThread((char)0, (unsigned char)0, & delay);
          }
#line 4232
          if (! (ntStatus >= 0L)) {
#line 4235
            return (ntStatus);
          } else {
#line 4237
            if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
              goto _L___0;
            } else {
#line 4240
              if ((int )DisketteExtension->FifoBuffer[1] != 0) {
                _L___0: 
#line 4244
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4245
                return (-1073741464L);
              } else {

              }
            }
          }
#line 4251
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
            {
#line 4253
            DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 4254
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4255
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
            }
#line 4259
            if (! (ntStatus >= 0L)) {
#line 4262
              return (ntStatus);
            } else {

            }
#line 4266
            if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 4267
              driveStatus = (unsigned char)127;
            } else {
#line 4269
              driveStatus = (unsigned char)128;
            }
          } else {
            {
#line 4273
            ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                                     (void *)(& fdcDiskChangeParms));
#line 4275
            driveStatus = fdcDiskChangeParms.DriveStatus;
            }
#line 4277
            if (! (ntStatus >= 0L)) {
#line 4278
              return (ntStatus);
            } else {

            }
          }
#line 4283
          if ((int )driveStatus & 128) {
#line 4286
            if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 4287
              (DisketteExtension->DeviceObject)->Flags &= 4294967293UL;
            } else {

            }
#line 4291
            return (-1073741805L);
          } else {

          }
        } else {

        }
#line 4298
        if ((int )IgnoreChange == 0) {
#line 4299
          if ((int )((DisketteExtension->DeviceObject)->Vpb)->Flags & 1) {
#line 4302
            return (-2147483626L);
          } else {
#line 4304
            return (-1073741435L);
          }
        } else {

        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
#line 4314
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
#line 4316
        FlHdbit(DisketteExtension);
        }
      } else {

      }
    }
  }
#line 4323
  if (SetUpMedia) {
#line 4324
    if ((int )DisketteExtension->MediaType == -1) {
      {
#line 4326
      ntStatus = FlDetermineMediaType(DisketteExtension);
      }
    } else {
#line 4329
      if ((int )DisketteExtension->MediaType == 0) {
#line 4332
        return (-1073741804L);
      } else {
#line 4334
        if ((int )DisketteExtension->DriveMediaType != (int )DisketteExtension->LastDriveMediaType) {
          {
#line 4336
          ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
          }
#line 4338
          if (! (ntStatus >= 0L)) {

          } else {

          }
        } else {

        }
      }
    }
  } else {

  }
#line 4352
  if (WriteOperation) {
#line 4353
    if (ntStatus >= 0L) {
      {
#line 4355
      DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 4356
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4357
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
      }
#line 4360
      if (! (ntStatus >= 0L)) {
#line 4363
        return (ntStatus);
      } else {

      }
#line 4367
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4368
        if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
#line 4371
          return (-1073741805L);
        } else {

        }
      } else {

      }
#line 4378
      if ((int )DisketteExtension->FifoBuffer[0] & 64) {
#line 4381
        return (-1073741662L);
      } else {

      }
    } else {

    }
  } else {

  }
#line 4391
  return (ntStatus);
}
}
#line 4394 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
#line 4398
  ntStatus = 0L;
#line 4399
  if (DisketteExtension->ControllerConfigurable) {
#line 4400
    DisketteExtension->FifoBuffer[0] = (unsigned char)17;
#line 4401
    DisketteExtension->FifoBuffer[1] = (unsigned char)0;
#line 4402
    DisketteExtension->FifoBuffer[2] = (unsigned char)15;
#line 4403
    DisketteExtension->FifoBuffer[2] = (unsigned char )((int )DisketteExtension->FifoBuffer[2] + 16);
#line 4404
    if (! DisketteExtension->DriveMediaConstants.CylinderShift) {
#line 4405
      DisketteExtension->FifoBuffer[2] = (unsigned char )((int )DisketteExtension->FifoBuffer[2] + 64);
    } else {

    }
    {
#line 4410
    DisketteExtension->FifoBuffer[3] = (unsigned char)0;
#line 4411
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
    }
#line 4414
    if (ntStatus == -1073741661L) {
#line 4415
      DisketteExtension->ControllerConfigurable = (unsigned char)0;
#line 4416
      ntStatus = 0L;
    } else {

    }
  } else {

  }
#line 4423
  if (ntStatus >= 0L) {
    goto _L;
  } else {
#line 4426
    if (ntStatus == -1073741661L) {
      _L: 
      {
#line 4429
      DisketteExtension->FifoBuffer[0] = (unsigned char)13;
#line 4430
      DisketteExtension->FifoBuffer[1] = DisketteExtension->DriveMediaConstants.StepRateHeadUnloadTime;
#line 4431
      DisketteExtension->FifoBuffer[2] = DisketteExtension->DriveMediaConstants.HeadLoadTime;
#line 4432
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
      }
#line 4435
      if (ntStatus >= 0L) {
        {
#line 4437
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (777 << 2)) | 3),
                                 (void *)(& DisketteExtension->DriveMediaConstants.DataTransferRate));
        }
#line 4440
        if (ntStatus >= 0L) {
          {
#line 4442
          ntStatus = FlRecalibrateDrive(DisketteExtension);
          }
        } else {

        }
      } else {

      }
    } else {

    }
  }
#line 4456
  if (ntStatus >= 0L) {
#line 4457
    DisketteExtension->LastDriveMediaType = DisketteExtension->DriveMediaType;
  } else {
#line 4459
    DisketteExtension->LastDriveMediaType = (enum _DRIVE_MEDIA_TYPE )0;
  }
#line 4463
  return (ntStatus);
}
}
#line 4466 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  UCHAR recalibrateCount ;
  UCHAR fifoBuffer[2] ;

  {
#line 4472
  recalibrateCount = (unsigned char)0;
  {
#line 4474
  while (1) {
    while_4_continue: /* CIL Label */ ;
    {
#line 4477
    DisketteExtension->FifoBuffer[0] = (unsigned char)11;
#line 4478
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4479
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
    }
#line 4482
    if (! (ntStatus >= 0L)) {

    } else {

    }
#line 4488
    if (ntStatus >= 0L) {
#line 4489
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
#line 4491
        fifoBuffer[0] = DisketteExtension->FifoBuffer[0];
#line 4492
        fifoBuffer[1] = DisketteExtension->FifoBuffer[1];
#line 4493
        DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 4494
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 4495
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
        }
#line 4498
        if (! (ntStatus >= 0L)) {
#line 4501
          return (ntStatus);
        } else {

        }
#line 4505
        DisketteExtension->FifoBuffer[0] = fifoBuffer[0];
#line 4506
        DisketteExtension->FifoBuffer[1] = fifoBuffer[1];
      } else {

      }
#line 4510
      if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
        goto _L;
      } else {
#line 4513
        if ((int )DisketteExtension->FifoBuffer[1] != 0) {
          _L: 
#line 4517
          DisketteExtension->HardwareFailed = (unsigned char)1;
#line 4518
          ntStatus = -1073741464L;
        } else {

        }
      }
    } else {

    }
#line 4526
    recalibrateCount = (unsigned char )((int )recalibrateCount + 1);
#line 4527
    if (! (ntStatus >= 0L)) {
#line 4528
      if ((int )recalibrateCount < 2) {

      } else {
        goto while_93_break;
      }
    } else {
      goto while_93_break;
    }
  }
  while_4_break: /* CIL Label */ ;
  }
  while_93_break: ;
#line 4541
  return (ntStatus);
}
}
#line 4544 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  BOOLEAN mediaTypesExhausted ;
  ULONG retries ;
  USHORT sectorLengthCode ;
  PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
#line 4558
  retries = 0UL;
#line 4561
  DisketteExtension->IsReadOnly = (unsigned char)0;
#line 4562
  retries = 0UL;
  {
#line 4564
  while (1) {
    while_5_continue: /* CIL Label */ ;

#line 4566
    if (retries < 3UL) {

    } else {
      goto while_99_break;
    }
#line 4571
    if (retries) {
      {
#line 4575
      FlInitializeControllerHardware(DisketteExtension);
      }
    } else {

    }
#line 4580
    DisketteExtension->DriveMediaType = (DriveMediaLimits + (int )DisketteExtension->DriveType)->HighestDriveMediaType;
#line 4581
    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )DisketteExtension->DriveMediaType);
#line 4582
    mediaTypesExhausted = (unsigned char)0;
    {
#line 4584
    while (1) {
      while_6_continue: /* CIL Label */ ;

#line 4586
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
#line 4588
        sectorLengthCode = (unsigned short )(DriveMediaConstants + (int )DisketteExtension->DriveMediaType)->SectorLengthCode;
#line 4589
        FlHdbit(DisketteExtension);
        }
      } else {

      }
      {
#line 4595
      ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
      }
#line 4597
      if (! (ntStatus >= 0L)) {
#line 4600
        mediaTypesExhausted = (unsigned char)1;
      } else {
        {
#line 4603
        driveMediaConstants = DriveMediaConstants + (int )DisketteExtension->DriveMediaType;
#line 4604
        DisketteExtension->FifoBuffer[1] = (unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2));
#line 4605
        DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 4606
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
        }
#line 4609
        if (! (ntStatus >= 0L)) {
          goto _L;
        } else {
#line 4612
          if (((int )DisketteExtension->FifoBuffer[0] & -33) != (int )((unsigned char )((int )DisketteExtension->DeviceUnit | (((int )driveMediaConstants->NumberOfHeads - 1) << 2)))) {
            goto _L;
          } else {
#line 4615
            if ((int )DisketteExtension->FifoBuffer[1] != 0) {
              goto _L;
            } else {
#line 4618
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                goto _L;
              } else {
#line 4621
                if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4622
                  if ((int )DisketteExtension->FifoBuffer[6] != (int )sectorLengthCode) {
                    _L: 
#line 4626
                    DisketteExtension->DriveMediaType = (enum _DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
#line 4627
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )DisketteExtension->DriveMediaType);
#line 4628
                    if (ntStatus != -1073741661L) {
#line 4629
                      ntStatus = -1073741804L;
                    } else {

                    }
#line 4633
                    if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + (int )DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 4634
                      DisketteExtension->MediaType = (enum _MEDIA_TYPE )0;
#line 4635
                      mediaTypesExhausted = (unsigned char)1;
                    } else {

                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
#line 4646
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4647
                    DisketteExtension->MediaType = driveMediaConstants->MediaType;
#line 4648
                    DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 4651
                    DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 4652
                    DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )DisketteExtension->DriveMediaType);
#line 4653
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4654
                      tmp = 1024;
                    } else {
#line 4656
                      tmp = 512;
                    }
                    {
#line 4659
                    tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )tmp,
                                                    1886350406UL);
#line 4660
                    bootSector = (struct _BOOT_SECTOR_INFO *)tmp___0;
                    }
#line 4662
                    if (! bootSector) {
#line 4663
                      return (-1073741670L);
                    } else {

                    }
#line 4667
                    offset.__annonCompField1.HighPart = 0L;
#line 4668
                    offset.__annonCompField1.LowPart = (unsigned long )offset.__annonCompField1.HighPart;
#line 4669
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4670
                      tmp___1 = 1024;
                    } else {
#line 4672
                      tmp___1 = 512;
                    }
                    {
#line 4675
                    irp = IoBuildAsynchronousFsdRequest(3UL, DisketteExtension->DeviceObject,
                                                        (void *)bootSector, (unsigned long )tmp___1,
                                                        & offset, (struct _IO_STATUS_BLOCK *)((void *)0));
                    }
#line 4679
                    if (! irp) {
#line 4685
                      return (-1073741670L);
                    } else {

                    }
                    {
#line 4690
                    irp->CurrentLocation = (char )((int )irp->CurrentLocation - 1);
#line 4691
                    irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation -= 1;
#line 4692
                    ntStatus = FlReadWrite(DisketteExtension, irp, (unsigned char)1);
                    }
#line 4702
                    if (! (ntStatus >= 0L)) {
#line 4705
                      DisketteExtension->DriveMediaType = (enum _DRIVE_MEDIA_TYPE )((int )DisketteExtension->DriveMediaType - 1);
#line 4706
                      DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )DisketteExtension->DriveMediaType);
#line 4707
                      if (ntStatus != -1073741661L) {
#line 4708
                        ntStatus = -1073741804L;
                      } else {

                      }
#line 4712
                      if ((int )((char )DisketteExtension->DriveMediaType) < (int )((char )(DriveMediaLimits + (int )DisketteExtension->DriveType)->LowestDriveMediaType)) {
#line 4713
                        DisketteExtension->MediaType = (enum _MEDIA_TYPE )0;
#line 4714
                        mediaTypesExhausted = (unsigned char)1;
                      } else {

                      }
                    } else {

                    }
                  } else {

                  }
                }
              }
            }
          }
        }
      }
#line 4732
      if (! (ntStatus >= 0L)) {
#line 4733
        if (! mediaTypesExhausted) {

        } else {
          goto while_101_break;
        }
      } else {
        goto while_101_break;
      }
    }
    while_6_break: /* CIL Label */ ;
    }
    while_101_break: ;
#line 4744
    if (ntStatus >= 0L) {
      goto while_99_break;
    } else {

    }
#line 4751
    retries += 1UL;
  }
  while_5_break: /* CIL Label */ ;
  }
  while_99_break: ;
#line 4755
  if (! (ntStatus >= 0L)) {
    goto _L___1;
  } else {
#line 4758
    if (mediaTypesExhausted) {
      _L___1: ;
#line 4762
      return (ntStatus);
    } else {

    }
  }
  {
#line 4767
  DisketteExtension->MediaType = driveMediaConstants->MediaType;
#line 4768
  DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 4769
  DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 4773
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )DisketteExtension->DriveMediaType);
#line 4774
  FlCheckBootSector(DisketteExtension);
  }
#line 4776
  return (ntStatus);
}
}
#line 4779 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize ) 
{ BOOLEAN allocateContiguous ;
  LARGE_INTEGER maxDmaAddress ;
  PVOID tmp ;
  PVOID tmp___0 ;

  {
#line 4786
  if (DisketteExtension->IoBuffer) {
#line 4787
    if (DisketteExtension->IoBufferSize >= BufferSize) {
#line 4788
      return;
    } else {

    }
    {
#line 4793
    FlFreeIoBuffer(DisketteExtension);
    }
  } else {

  }
#line 4798
  if (BufferSize > DisketteExtension->MaxTransferSize) {
#line 4799
    allocateContiguous = (unsigned char)1;
  } else {
#line 4801
    allocateContiguous = (unsigned char)0;
  }
#line 4803
  if (allocateContiguous) {
    {
#line 4805
    maxDmaAddress.QuadPart = 16777215LL;
#line 4806
    tmp = MmAllocateContiguousMemory(BufferSize, maxDmaAddress);
#line 4807
    DisketteExtension->IoBuffer = (UCHAR *)tmp;
    }
  } else {
    {
#line 4811
    tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, BufferSize, 1886350406UL);
#line 4812
    DisketteExtension->IoBuffer = (UCHAR *)tmp___0;
    }
  }
#line 4815
  if (! DisketteExtension->IoBuffer) {
#line 4816
    return;
  } else {

  }
  {
#line 4821
  DisketteExtension->IoBufferMdl = IoAllocateMdl((void *)DisketteExtension->IoBuffer,
                                                 BufferSize, (unsigned char)0, (unsigned char)0,
                                                 (struct _IRP *)((void *)0));
  }
#line 4824
  if (! DisketteExtension->IoBufferMdl) {
#line 4825
    if (allocateContiguous) {

    } else {

    }
#line 4834
    DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 4835
    return;
  } else {

  }
  {
#line 4840
  MmProbeAndLockPages(DisketteExtension->IoBufferMdl, (char)0, (enum _LOCK_OPERATION )2);
  }
#line 4844
  if (allocateContiguous) {

  } else {

  }
#line 4853
  DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 4854
  return;
#line 4855
  DisketteExtension->IoBufferSize = BufferSize;
}
}
#line 4858 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) 
{ BOOLEAN contiguousBuffer ;

  {
#line 4862
  if (! DisketteExtension->IoBuffer) {
#line 4863
    return;
  } else {

  }
#line 4867
  if (DisketteExtension->IoBufferSize > DisketteExtension->MaxTransferSize) {
#line 4868
    contiguousBuffer = (unsigned char)1;
  } else {
#line 4870
    contiguousBuffer = (unsigned char)0;
  }
#line 4873
  DisketteExtension->IoBufferSize = 0UL;
#line 4876
  DisketteExtension->IoBufferMdl = (struct _MDL *)((void *)0);
#line 4878
  if (contiguousBuffer) {

  } else {

  }
#line 4887
  DisketteExtension->IoBuffer = (UCHAR *)((void *)0);
#line 4888
  return;
}
}
#line 4891 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FloppyThread(PVOID Context ) 
{ PIRP irp ;
  PIO_STACK_LOCATION irpSp ;
  PLIST_ENTRY request ;
  PDISKETTE_EXTENSION disketteExtension ;
  NTSTATUS ntStatus ;
  NTSTATUS waitStatus ;
  LARGE_INTEGER queueWait ;
  LARGE_INTEGER acquireWait ;
  PKTHREAD tmp ;
  PDISK_GEOMETRY outputBuffer ;
  PSENSE_DEVISE_STATUS_PTOS outputBuffer___0 ;

  {
  {
#line 4906
  disketteExtension = (DISKETTE_EXTENSION *)Context;
#line 4907
  ntStatus = 0L;
#line 4908
  tmp = KeGetCurrentThread();
#line 4909
  KeSetPriorityThread(tmp, 16L);
#line 4910
  queueWait.QuadPart = -30000000LL;
#line 4911
  acquireWait.QuadPart = -150000000LL;
  }
  {
#line 4914
  while (1) {
    while_7_continue: /* CIL Label */ ;
    {
#line 4917
    waitStatus = KeWaitForSingleObject((void *)(& disketteExtension->RequestSemaphore),
                                       (enum _KWAIT_REASON )0, (char)0, (unsigned char)0,
                                       & queueWait);
    }
#line 4920
    if (waitStatus == 258L) {
#line 4921
      if (! ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1)) {
#line 4922
        if (disketteExtension->FloppyControllerAllocated) {
          {
#line 4926
          FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                        (void *)0);
#line 4928
          FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                        (void *)disketteExtension->DeviceObject);
#line 4930
          disketteExtension->FloppyControllerAllocated = (unsigned char)0;
          }
        } else {

        }
      } else {

      }
#line 4941
      if (disketteExtension->ThreadReferenceCount == 0L) {
#line 4942
        disketteExtension->ThreadReferenceCount = -1L;
#line 4943
        if ((unsigned int )disketteExtension->FloppyThread != (unsigned int )((void *)0)) {
#line 4946
          disketteExtension->FloppyThread = (struct _KTHREAD *)((void *)0);
        } else {

        }
#line 4954
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 4955
          if (disketteExtension->ReleaseFdcWithMotorRunning) {
            {
#line 4957
            ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                     (void *)(& acquireWait));
#line 4959
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                          (void *)0);
#line 4961
            FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                          (void *)disketteExtension->DeviceObject);
#line 4963
            disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 4964
            disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
            }
          } else {

          }
        } else {

        }
#line 4974
        PagingReferenceCount -= 1UL;
#line 4976
        if (PagingReferenceCount == 0UL) {

        } else {

        }
        {
#line 4989
        PsTerminateSystemThread(0L);
        }
      } else {

      }
      goto __Cont;
    } else {

    }
    {
#line 5002
    while (1) {
      while_8_continue: /* CIL Label */ ;
      while_117_continue: 
#line 5005
      request = (struct _LIST_ENTRY *)((void *)0);
#line 5007
      if (request) {

      } else {
        goto while_117_break;
      }
#line 5014
      disketteExtension->ThreadReferenceCount -= 1L;
#line 5016
      disketteExtension->HardwareFailed = (unsigned char)0;
#line 5017
      irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 5020
      if ((int )disketteExtension->PoweringDown == 1) {
        {
#line 5027
        irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 5028
        irp->IoStatus.__annonCompField4.Status = -1073741101L;
#line 5029
        irp->IoStatus.Information = 0UL;
#line 5030
        IofCompleteRequest(irp, (char)0);
        }
        goto while_117_continue;
      } else {

      }
#line 5041
      irpSp = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5044
      if ((int )irpSp->MajorFunction == 27) {
        goto switch_121_27;
      } else {
#line 5047
        if ((int )irpSp->MajorFunction == 3) {
          goto switch_121_3;
        } else {
#line 5050
          if ((int )irpSp->MajorFunction == 4) {
            goto switch_121_4;
          } else {
#line 5053
            if ((int )irpSp->MajorFunction == 14) {
              goto switch_121_14;
            } else {
              goto switch_121_default;
#line 5058
              if (0) {
                switch_121_27: ;
#line 5062
                if ((int )irpSp->MinorFunction == 1) {
                  goto _L;
                } else {
#line 5065
                  if ((int )irpSp->MinorFunction == 5) {
                    _L: 
#line 5067
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5068
                      if (disketteExtension->ReleaseFdcWithMotorRunning) {
                        {
#line 5070
                        FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                      (void *)(& acquireWait));
#line 5072
                        disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
#line 5073
                        disketteExtension->FloppyControllerAllocated = (unsigned char)1;
                        }
                      } else {

                      }
                    } else {

                    }
#line 5081
                    if (disketteExtension->FloppyControllerAllocated) {
                      {
#line 5083
                      FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (775 << 2)) | 3),
                                    (void *)0);
#line 5085
                      FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                                    (void *)disketteExtension->DeviceObject);
#line 5087
                      disketteExtension->FloppyControllerAllocated = (unsigned char)0;
                      }
                    } else {

                    }
#line 5094
                    disketteExtension->ThreadReferenceCount = -1L;
#line 5097
                    PagingReferenceCount -= 1UL;
#line 5099
                    if (PagingReferenceCount == 0UL) {

                    } else {

                    }
                    {
#line 5108
                    PsTerminateSystemThread(0L);
                    }
                  } else {
#line 5111
                    ntStatus = -1073741808L;
                  }
                }
                goto switch_121_break;
                switch_121_3: ;
                switch_121_4: ;
#line 5117
                if (! disketteExtension->FloppyControllerAllocated) {
                  {
#line 5119
                  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                           (void *)(& acquireWait));
                  }
#line 5122
                  if (ntStatus >= 0L) {
#line 5123
                    disketteExtension->FloppyControllerAllocated = (unsigned char)1;
#line 5124
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5125
                      disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
                    } else {

                    }
                  } else {
                    goto switch_121_break;
                  }
                } else {

                }
#line 5135
                if ((disketteExtension->DeviceObject)->Flags & 2UL) {
#line 5136
                  if (! ((int )irpSp->Flags & 2)) {
#line 5139
                    ntStatus = -2147483626L;
                  } else {
                    {
#line 5142
                    ntStatus = FlReadWrite(disketteExtension, irp, (unsigned char)0);
                    }
                  }
                } else {
                  {
#line 5147
                  ntStatus = FlReadWrite(disketteExtension, irp, (unsigned char)0);
                  }
                }
                goto switch_121_break;
                switch_121_14: ;
#line 5152
                if (! disketteExtension->FloppyControllerAllocated) {
                  {
#line 5154
                  ntStatus = FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (768 << 2)) | 3),
                                           (void *)(& acquireWait));
                  }
#line 5157
                  if (ntStatus >= 0L) {
#line 5158
                    disketteExtension->FloppyControllerAllocated = (unsigned char)1;
#line 5159
                    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5160
                      disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)0;
                    } else {

                    }
                  } else {
                    goto switch_121_break;
                  }
                } else {

                }
#line 5170
                if ((disketteExtension->DeviceObject)->Flags & 2UL) {
#line 5171
                  if (! ((int )irpSp->Flags & 2)) {
#line 5174
                    ntStatus = -2147483626L;
                  } else {
                    goto _L___2;
                  }
                } else {
                  _L___2: 
#line 5180
                  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((45 << 16) | (1 << 14)) | (512 << 2))) {
                    goto switch_125_exp_12;
                  } else {
#line 5183
                    if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (1 << 14)) | (512 << 2))) {
                      goto switch_125_exp_13;
                    } else {
#line 5186
                      if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((7 << 16) | (9 << 2))) {
                        goto switch_125_exp_14;
                      } else {
#line 5189
                        if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(7 << 16)) {
                          goto switch_125_exp_15;
                        } else {
#line 5192
                          if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (11 << 2))) {
                            goto switch_125_exp_16;
                          } else {
#line 5195
                            if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((7 << 16) | (3 << 14)) | (6 << 2))) {
                              goto switch_125_exp_17;
                            } else {
#line 5198
                              if (irpSp->Parameters.DeviceIoControl.IoControlCode == (ULONG )((7 << 16) | (248 << 2))) {
                                goto switch_125_exp_18;
                              } else {
#line 5201
                                if (0) {
                                  switch_125_exp_12: ;
                                  switch_125_exp_13: 
                                  {
#line 5207
                                  ntStatus = FlStartDrive(disketteExtension, irp,
                                                          (unsigned char)0, (unsigned char)0,
                                                          (unsigned char )(! (! ((int )irpSp->Flags & 2))));
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_14: ;
#line 5214
                                  if (disketteExtension->IsReadOnly) {
#line 5215
                                    ntStatus = -1073741811L;
                                  } else {
                                    {
#line 5218
                                    ntStatus = FlStartDrive(disketteExtension, irp,
                                                            (unsigned char)1, (unsigned char)0,
                                                            (unsigned char)1);
                                    }
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_15: ;
#line 5226
                                  if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(DISK_GEOMETRY )) {
#line 5227
                                    ntStatus = -1073741811L;
                                  } else {
                                    {
#line 5230
                                    ntStatus = FlStartDrive(disketteExtension, irp,
                                                            (unsigned char)0, (unsigned char)1,
                                                            (unsigned char )(! (! ((int )irpSp->Flags & 2))));
                                    }
                                  }
#line 5234
                                  if (ntStatus >= 0L) {
                                    goto _L___0;
                                  } else {
#line 5237
                                    if (ntStatus == -1073741804L) {
                                      _L___0: 
#line 5239
                                      outputBuffer = (struct _DISK_GEOMETRY *)irp->AssociatedIrp.SystemBuffer;
#line 5240
                                      ntStatus = 0L;
#line 5241
                                      outputBuffer->MediaType = disketteExtension->MediaType;
#line 5242
                                      if ((int )disketteExtension->MediaType == 0) {
#line 5245
                                        outputBuffer->Cylinders.__annonCompField1.LowPart = 0UL;
#line 5246
                                        outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 5247
                                        outputBuffer->TracksPerCylinder = 0UL;
#line 5248
                                        outputBuffer->SectorsPerTrack = 0UL;
#line 5249
                                        outputBuffer->BytesPerSector = 0UL;
                                      } else {
#line 5253
                                        outputBuffer->Cylinders.__annonCompField1.LowPart = (unsigned long )((int )disketteExtension->DriveMediaConstants.MaximumTrack + 1);
#line 5254
                                        outputBuffer->Cylinders.__annonCompField1.HighPart = 0L;
#line 5255
                                        outputBuffer->TracksPerCylinder = (unsigned long )disketteExtension->DriveMediaConstants.NumberOfHeads;
#line 5256
                                        outputBuffer->SectorsPerTrack = (unsigned long )disketteExtension->DriveMediaConstants.SectorsPerTrack;
#line 5257
                                        outputBuffer->BytesPerSector = (unsigned long )disketteExtension->DriveMediaConstants.BytesPerSector;
                                      }
                                    } else {

                                    }
                                  }
#line 5265
                                  irp->IoStatus.Information = (unsigned long )sizeof(DISK_GEOMETRY );
                                  goto switch_125_break;
                                  switch_125_exp_16: ;
                                  switch_125_exp_17: 
                                  {
#line 5272
                                  ntStatus = FlStartDrive(disketteExtension, irp,
                                                          (unsigned char)1, (unsigned char)0,
                                                          (unsigned char)0);
                                  }
#line 5275
                                  if (ntStatus >= 0L) {
                                    goto _L___1;
                                  } else {
#line 5278
                                    if (ntStatus == -1073741804L) {
                                      _L___1: 
                                      {
#line 5281
                                      FlAllocateIoBuffer(disketteExtension, 4096UL);
                                      }
#line 5283
                                      if (disketteExtension->IoBuffer) {
                                        {
#line 5285
                                        ntStatus = FlFormat(disketteExtension, irp);
                                        }
                                      } else {
#line 5288
                                        ntStatus = -1073741670L;
                                      }
                                    } else {

                                    }
                                  }
                                  goto switch_125_break;
                                  switch_125_exp_18: ;
#line 5296
                                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
                                    {
#line 5298
                                    disketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 5299
                                    disketteExtension->FifoBuffer[1] = disketteExtension->DeviceUnit;
#line 5300
                                    ntStatus = FlIssueCommand(disketteExtension, disketteExtension->FifoBuffer,
                                                              disketteExtension->FifoBuffer,
                                                              (struct _MDL *)((void *)0),
                                                              0UL, 0UL);
                                    }
#line 5304
                                    if (ntStatus >= 0L) {
#line 5305
                                      outputBuffer___0 = (struct _SENSE_DEVISE_STATUS_PTOS *)irp->AssociatedIrp.SystemBuffer;
#line 5306
                                      outputBuffer___0->ST3_PTOS = Result_Status3_PTOS[0].ST3_PTOS;
#line 5307
                                      irp->IoStatus.Information = (unsigned long )sizeof(SENSE_DEVISE_STATUS_PTOS );
                                    } else {

                                    }
                                    goto switch_125_break;
                                  } else {

                                  }
                                } else {
                                  switch_125_break: ;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                goto switch_121_break;
                switch_121_default: 
#line 5330
                ntStatus = -1073741822L;
              } else {
                switch_121_break: ;
              }
            }
          }
        }
      }
#line 5339
      if (ntStatus == -2147483631L) {
        {
#line 5341
        while (1) {
          while_9_continue: /* CIL Label */ ;
          {
#line 5344
          disketteExtension->HardwareFailed = (unsigned char)0;
#line 5345
          irp->IoStatus.__annonCompField4.Status = -2147483631L;
#line 5346
          IofCompleteRequest(irp, (char)1);
#line 5347
          request = (struct _LIST_ENTRY *)((void *)0);
          }
#line 5349
          if (! request) {
            goto while_134_break;
          } else {

          }
#line 5356
          disketteExtension->ThreadReferenceCount -= 1L;
#line 5358
          irp = (IRP *)((CHAR *)request - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
        }
        while_9_break: /* CIL Label */ ;
        }
        while_134_break: ;
      } else {
#line 5364
        irp->IoStatus.__annonCompField4.Status = ntStatus;
#line 5365
        if (disketteExtension->IoBuffer) {
          {
#line 5367
          FlFreeIoBuffer(disketteExtension);
          }
        } else {

        }
        {
#line 5373
        FlFinishOperation(irp, disketteExtension);
        }
      }
    }
    while_8_break: /* CIL Label */ ;
    }
    while_117_break: ;
#line 5379
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5380
      if (disketteExtension->FloppyControllerAllocated) {
        {
#line 5382
        FlFdcDeviceIo(disketteExtension->TargetObject, (unsigned long )(((7 << 16) | (769 << 2)) | 3),
                      (void *)disketteExtension->DeviceObject);
#line 5384
        disketteExtension->FloppyControllerAllocated = (unsigned char)0;
#line 5385
        disketteExtension->ReleaseFdcWithMotorRunning = (unsigned char)1;
        }
      } else {

      }
    } else {

    }
    __Cont: ;
  }
  while_7_break: /* CIL Label */ ;
  }

#line 5398
  return;
}
}
#line 5399 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension ,
                                          PBOOT_SECTOR_INFO BootSector ) 
{ USHORT bpbNumberOfSectors ;
  USHORT bpbNumberOfHeads ;
  USHORT bpbSectorsPerTrack ;
  USHORT bpbBytesPerSector ;
  USHORT bpbMediaByte ;
  USHORT bpbMaximumTrack ;
  MEDIA_TYPE bpbMediaType ;
  ULONG i ;
  ULONG n ;
  PDRIVE_MEDIA_CONSTANTS readidDriveMediaConstants ;
  BOOLEAN changeToBpbMedia ;
  int tmp ;
  SIZE_T tmp___0 ;

  {
#line 5418
  if ((int )BootSector->JumpByte[0] != 235) {
#line 5419
    if ((int )BootSector->JumpByte[0] != 233) {
#line 5420
      return;
    } else {

    }
  } else {

  }
#line 5427
  bpbNumberOfSectors = (unsigned short )((int )BootSector->NumberOfSectors[1] * 256 + (int )BootSector->NumberOfSectors[0]);
#line 5428
  bpbNumberOfHeads = (unsigned short )((int )BootSector->NumberOfHeads[1] * 256 + (int )BootSector->NumberOfHeads[0]);
#line 5429
  bpbSectorsPerTrack = (unsigned short )((int )BootSector->SectorsPerTrack[1] * 256 + (int )BootSector->SectorsPerTrack[0]);
#line 5430
  bpbBytesPerSector = (unsigned short )((int )BootSector->BytesPerSector[1] * 256 + (int )BootSector->BytesPerSector[0]);
#line 5431
  bpbMediaByte = (unsigned short )BootSector->MediaByte[0];
#line 5432
  if (! bpbNumberOfHeads) {
#line 5433
    return;
  } else {
#line 5435
    if (! bpbSectorsPerTrack) {
#line 5436
      return;
    } else {

    }
  }
#line 5441
  bpbMaximumTrack = (unsigned short )(((int )bpbNumberOfSectors / (int )bpbNumberOfHeads) / (int )bpbSectorsPerTrack - 1);
#line 5442
  bpbMediaType = (enum _MEDIA_TYPE )0;
#line 5443
  i = 0UL;
  {
#line 5445
  while (1) {
    while_10_continue: /* CIL Label */ ;

#line 5447
    if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5448
      tmp = 21;
    } else {
#line 5450
      tmp = 17;
    }
#line 5452
    if (i < (unsigned long )tmp) {

    } else {
      goto while_136_break;
    }
#line 5457
    if ((int )bpbBytesPerSector == (int )(DriveMediaConstants + i)->BytesPerSector) {
#line 5458
      if ((int )bpbSectorsPerTrack == (int )(DriveMediaConstants + i)->SectorsPerTrack) {
#line 5459
        if ((int )bpbMaximumTrack == (int )(DriveMediaConstants + i)->MaximumTrack) {
#line 5460
          if ((int )bpbNumberOfHeads == (int )(DriveMediaConstants + i)->NumberOfHeads) {
#line 5461
            if ((int )bpbMediaByte == (int )(DriveMediaConstants + i)->MediaByte) {
#line 5462
              bpbMediaType = (DriveMediaConstants + i)->MediaType;
              goto while_136_break;
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
#line 5479
    i += 1UL;
  }
  while_10_break: /* CIL Label */ ;
  }
  while_136_break: ;
#line 5483
  if ((int )DisketteExtension->DriveType == 3) {
#line 5484
    if ((int )bpbMediaType == 15) {
      goto switch_137_15;
    } else {
#line 5487
      if ((int )bpbMediaType == 16) {
        goto switch_137_16;
      } else {
#line 5490
        if ((int )bpbMediaType == 1) {
          goto switch_137_1;
        } else {
#line 5493
          if ((int )bpbMediaType == 19) {
            goto switch_137_19;
          } else {
            goto switch_137_default;
#line 5498
            if (0) {
              switch_137_15: 
#line 5500
              bpbMediaType = (enum _MEDIA_TYPE )14;
              goto switch_137_break;
              switch_137_16: 
#line 5503
              bpbMediaType = (enum _MEDIA_TYPE )5;
              goto switch_137_break;
              switch_137_1: 
#line 5506
              bpbMediaType = (enum _MEDIA_TYPE )17;
              goto switch_137_break;
              switch_137_19: 
#line 5509
              bpbMediaType = (enum _MEDIA_TYPE )18;
              goto switch_137_break;
              switch_137_default: ;
              goto switch_137_break;
            } else {
              switch_137_break: ;
            }
          }
        }
      }
    }
  } else {

  }
#line 5528
  if ((int )bpbMediaType == (int )DisketteExtension->MediaType) {
#line 5529
    changeToBpbMedia = (unsigned char)0;
  } else {
#line 5533
    readidDriveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 5534
    if ((int )bpbBytesPerSector == (int )readidDriveMediaConstants->BytesPerSector) {
#line 5535
      if ((int )bpbSectorsPerTrack < 256) {
#line 5536
        if ((int )bpbMaximumTrack == (int )readidDriveMediaConstants->MaximumTrack) {
#line 5537
          if ((int )bpbNumberOfHeads <= (int )readidDriveMediaConstants->NumberOfHeads) {
#line 5538
            changeToBpbMedia = (unsigned char)1;
          } else {
#line 5540
            changeToBpbMedia = (unsigned char)0;
          }
        } else {
#line 5543
          changeToBpbMedia = (unsigned char)0;
        }
      } else {
#line 5546
        changeToBpbMedia = (unsigned char)0;
      }
    } else {
#line 5549
      changeToBpbMedia = (unsigned char)0;
    }
#line 5553
    if ((int )bpbMediaType == 0) {
#line 5554
      bpbMediaType = readidDriveMediaConstants->MediaType;
#line 5555
      DisketteExtension->DriveMediaConstants.SkewDelta = (unsigned char)0;
    } else {

    }
  }
#line 5560
  if (changeToBpbMedia) {
#line 5561
    i = (unsigned long )(DriveMediaLimits + (int )DisketteExtension->DriveType)->LowestDriveMediaType;
#line 5562
    n = (unsigned long )(DriveMediaLimits + (int )DisketteExtension->DriveType)->HighestDriveMediaType;
    {
#line 5564
    while (1) {
      while_11_continue: /* CIL Label */ ;

#line 5566
      if (i <= n) {

      } else {
        goto while_142_break;
      }
#line 5571
      if ((int )bpbMediaType == (int )(DriveMediaConstants + i)->MediaType) {
#line 5572
        DisketteExtension->DriveMediaType = (enum _DRIVE_MEDIA_TYPE )i;
        goto while_142_break;
      } else {

      }
#line 5577
      i += 1UL;
    }
    while_11_break: /* CIL Label */ ;
    }
    while_142_break: 
    {
#line 5582
    DisketteExtension->MediaType = bpbMediaType;
#line 5583
    DisketteExtension->ByteCapacity = (unsigned long )((int )bpbNumberOfSectors * (int )bpbBytesPerSector);
#line 5584
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )bpbSectorsPerTrack;
#line 5585
    DisketteExtension->DriveMediaConstants.NumberOfHeads = (unsigned char )bpbNumberOfHeads;
#line 5586
    tmp___0 = RtlCompareMemory((void const   *)(BootSector->OemData), (void const   *)"MSDMF3.",
                               7UL);
    }
#line 5588
    if (tmp___0 == 7UL) {
#line 5589
      DisketteExtension->IsReadOnly = (unsigned char)1;
    } else {

    }
  } else {

  }
#line 5596
  return;
}
}
#line 5599 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) 
{ PBOOT_SECTOR_INFO bootSector ;
  LARGE_INTEGER offset ;
  PIRP irp ;
  NTSTATUS status ;
  int tmp ;
  PVOID tmp___0 ;
  int tmp___1 ;

  {
#line 5609
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5610
    tmp = 1024;
  } else {
#line 5612
    tmp = 512;
  }
  {
#line 5615
  tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )tmp, 1886350406UL);
#line 5616
  bootSector = (struct _BOOT_SECTOR_INFO *)tmp___0;
  }
#line 5618
  if (! bootSector) {
#line 5619
    return;
  } else {

  }
#line 5623
  offset.__annonCompField1.HighPart = 0L;
#line 5624
  offset.__annonCompField1.LowPart = (unsigned long )offset.__annonCompField1.HighPart;
#line 5625
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5626
    tmp___1 = 1024;
  } else {
#line 5628
    tmp___1 = 512;
  }
  {
#line 5631
  irp = IoBuildAsynchronousFsdRequest(3UL, DisketteExtension->DeviceObject, (void *)bootSector,
                                      (unsigned long )tmp___1, & offset, (struct _IO_STATUS_BLOCK *)((void *)0));
  }
#line 5634
  if (! irp) {
#line 5638
    return;
  } else {

  }
  {
#line 5643
  irp->CurrentLocation = (char )((int )irp->CurrentLocation - 1);
#line 5644
  irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation -= 1;
#line 5645
  status = FlReadWrite(DisketteExtension, irp, (unsigned char)1);
  }
#line 5651
  return;
}
}
#line 5654 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl , ULONG IoOffset ,
                          BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head , UCHAR Sector ,
                          UCHAR NumberOfSectors , BOOLEAN NeedSeek ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG transferBytes ;
  LARGE_INTEGER headSettleTime ;
  NTSTATUS status ;
  ULONG seekRetry ;
  ULONG ioRetry ;
  BOOLEAN recalibrateDrive ;
  UCHAR i ;

  {
#line 5668
  recalibrateDrive = (unsigned char)0;
#line 5671
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 5672
  byteToSectorShift = (unsigned long )(7 + (int )driveMediaConstants->SectorLengthCode);
#line 5673
  transferBytes = (unsigned long )NumberOfSectors << byteToSectorShift;
#line 5674
  headSettleTime.__annonCompField1.LowPart = (unsigned long )(- (10000 * (int )driveMediaConstants->HeadSettleTime));
#line 5675
  headSettleTime.__annonCompField1.HighPart = -1L;
#line 5676
  seekRetry = 0UL;
#line 5677
  ioRetry = 0UL;
  {
#line 5679
  while (1) {
    while_12_continue: /* CIL Label */ ;

#line 5681
    if (seekRetry < 3UL) {

    } else {
      goto while_144_break;
    }
#line 5686
    if (recalibrateDrive) {
      {
#line 5690
      FlRecalibrateDrive(DisketteExtension);
      }
    } else {

    }
#line 5695
    if (recalibrateDrive) {
      goto _L___0;
    } else {
#line 5698
      if (NeedSeek) {
#line 5699
        if (! DisketteExtension->ControllerConfigurable) {
          goto _L___0;
        } else {
#line 5702
          if ((int )driveMediaConstants->CylinderShift != 0) {
            _L___0: 
            {
#line 5705
            DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 5706
            DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 5707
            DisketteExtension->FifoBuffer[2] = (unsigned char )((int )Cylinder << (int )driveMediaConstants->CylinderShift);
#line 5708
            status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                    DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                    0UL, 0UL);
            }
#line 5711
            if (status >= 0L) {
#line 5712
              if (! ((int )DisketteExtension->FifoBuffer[0] & 32)) {
#line 5713
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5714
                status = -1073741464L;
              } else {
#line 5716
                if ((int )DisketteExtension->FifoBuffer[1] != (int )Cylinder << (int )driveMediaConstants->CylinderShift) {
#line 5717
                  DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5718
                  status = -1073741464L;
                } else {

                }
              }
#line 5723
              if (status >= 0L) {
                {
#line 5725
                KeDelayExecutionThread((char)0, (unsigned char)0, & headSettleTime);
#line 5726
                DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 5727
                DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 5728
                status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                        DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                        0UL, 0UL);
                }
#line 5732
                if (status >= 0L) {
#line 5733
                  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5734
                    if ((int )DisketteExtension->FifoBuffer[0] & 8) {
#line 5735
                      return (-1073741661L);
                    } else {

                    }
                  } else {

                  }
#line 5742
                  if ((int )DisketteExtension->FifoBuffer[0] != (((int )Head << 2) | (int )DisketteExtension->DeviceUnit)) {
                    {
#line 5744
                    DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5745
                    status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
                    }
                  } else {
#line 5748
                    if ((int )DisketteExtension->FifoBuffer[1] != 0) {
                      {
#line 5750
                      DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5751
                      status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                DisketteExtension->FifoBuffer[2]);
                      }
                    } else {
#line 5755
                      if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                        {
#line 5757
                        DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5758
                        status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                  DisketteExtension->FifoBuffer[2]);
                        }
                      } else {
#line 5762
                        if ((int )DisketteExtension->FifoBuffer[3] != (int )Cylinder) {
                          {
#line 5764
                          DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5765
                          status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                                    DisketteExtension->FifoBuffer[2]);
                          }
                        } else {

                        }
                      }
                    }
                  }
                } else {

                }
              } else {

              }
            } else {

            }
          } else {
#line 5786
            status = 0L;
          }
        }
      } else {
#line 5790
        status = 0L;
      }
    }
#line 5793
    if (! (status >= 0L)) {
#line 5796
      recalibrateDrive = (unsigned char)1;
      goto __Cont;
    } else {

    }
    {
#line 5802
    while (1) {
      while_13_continue: /* CIL Label */ ;
#line 5804
      DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )Head << 2) | (int )DisketteExtension->DeviceUnit);
#line 5805
      DisketteExtension->FifoBuffer[2] = Cylinder;
#line 5806
      DisketteExtension->FifoBuffer[3] = Head;
#line 5807
      DisketteExtension->FifoBuffer[4] = (unsigned char )((int )Sector + 1);
#line 5808
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->SectorLengthCode;
#line 5809
      DisketteExtension->FifoBuffer[6] = (unsigned char )((int )Sector + (int )NumberOfSectors);
#line 5810
      DisketteExtension->FifoBuffer[7] = driveMediaConstants->ReadWriteGapLength;
#line 5811
      DisketteExtension->FifoBuffer[8] = driveMediaConstants->DataLength;
#line 5812
      if (WriteOperation) {
#line 5813
        DisketteExtension->FifoBuffer[0] = (unsigned char)66;
      } else {
#line 5815
        DisketteExtension->FifoBuffer[0] = (unsigned char)64;
      }
      {
#line 5818
      status = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              IoMdl, IoOffset, transferBytes);
      }
#line 5821
      if (status >= 0L) {
#line 5822
        if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 5823
          if ((int )DisketteExtension->FifoBuffer[0] & 8) {
#line 5824
            return (-1073741661L);
          } else {

          }
        } else {

        }
#line 5831
        if (((int )DisketteExtension->FifoBuffer[0] & 192) != 0) {
#line 5832
          if (((int )DisketteExtension->FifoBuffer[0] & 192) != 64) {
            {
#line 5834
            DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5835
            status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
            }
          } else {
#line 5838
            if ((int )DisketteExtension->FifoBuffer[1] != 128) {
              {
#line 5840
              DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5841
              status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
              }
            } else {
#line 5844
              if ((int )DisketteExtension->FifoBuffer[2] != 0) {
                {
#line 5846
                DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5847
                status = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
                }
              } else {
                goto _L___1;
              }
            }
          }
        } else {
          _L___1: 
#line 5856
          if ((int )DisketteExtension->FifoBuffer[5] != 1) {
#line 5857
            DisketteExtension->HardwareFailed = (unsigned char)1;
#line 5858
            status = -1073741465L;
          } else {

          }
        }
      } else {

      }
#line 5867
      if (status >= 0L) {
        goto while_149_break;
      } else {

      }
#line 5872
      if (ioRetry >= 2UL) {
        goto while_149_break;
      } else {

      }
#line 5879
      ioRetry += 1UL;
    }
    while_13_break: /* CIL Label */ ;
    }
    while_149_break: ;
#line 5883
    if (status >= 0L) {
      goto while_144_break;
    } else {

    }
#line 5888
    recalibrateDrive = (unsigned char)1;
    __Cont: 
#line 5890
    seekRetry += 1UL;
  }
  while_12_break: /* CIL Label */ ;
  }
  while_144_break: ;
#line 5894
  if (! (status >= 0L)) {
#line 5895
    if ((int )NumberOfSectors > 1) {
#line 5898
      i = (unsigned char)0;
      {
#line 5900
      while (1) {
        while_14_continue: /* CIL Label */ ;

#line 5902
        if ((int )i < (int )NumberOfSectors) {

        } else {
          goto while_153_break;
        }
        {
#line 5908
        status = FlReadWriteTrack(DisketteExtension, IoMdl, IoOffset + ((unsigned long )i << byteToSectorShift),
                                  WriteOperation, Cylinder, Head, (unsigned char )((int )Sector + (int )i),
                                  (unsigned char)1, (unsigned char)0);
        }
#line 5912
        if (! (status >= 0L)) {
#line 5915
          DisketteExtension->HardwareFailed = (unsigned char)1;
          goto while_153_break;
        } else {

        }
#line 5920
        i = (unsigned char )((int )i + 1);
      }
      while_14_break: /* CIL Label */ ;
      }
      while_153_break: ;
    } else {

    }
  } else {

  }
#line 5930
  return (status);
}
}
#line 5933 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN DriveStarted ) 
{ PIO_STACK_LOCATION irpSp ;
  BOOLEAN writeOperation ;
  NTSTATUS status ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  ULONG byteToSectorShift ;
  ULONG currentSector ;
  ULONG firstSector ;
  ULONG lastSector ;
  ULONG trackSize ;
  UCHAR sectorsPerTrack ;
  UCHAR numberOfHeads ;
  UCHAR currentHead ;
  UCHAR currentCylinder ;
  UCHAR trackSector ;
  PCHAR userBuffer ;
  UCHAR skew ;
  UCHAR skewDelta ;
  UCHAR numTransferSectors ;
  PMDL mdl ;
  PCHAR ioBuffer ;
  ULONG ioOffset ;
  PVOID tmp___0 ;

  {
#line 5958
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5961
  if ((int )irpSp->MajorFunction == 4) {
#line 5962
    if (DisketteExtension->IsReadOnly) {
#line 5965
      return (-1073741811L);
    } else {

    }
#line 5969
    writeOperation = (unsigned char)1;
  } else {
#line 5971
    writeOperation = (unsigned char)0;
  }
#line 5975
  if (DriveStarted) {
#line 5976
    status = 0L;
  } else {
    {
#line 5979
    status = FlStartDrive(DisketteExtension, Irp, writeOperation, (unsigned char)1,
                          (unsigned char )(! (! ((int )irpSp->Flags & 2))));
    }
  }
#line 5982
  if (! (status >= 0L)) {
#line 5985
    return (status);
  } else {

  }
#line 5989
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    {
#line 5991
    FlHdbit(DisketteExtension);
    }
  } else {

  }
#line 5996
  if ((int )DisketteExtension->MediaType == 0) {
#line 5999
    return (-1073741804L);
  } else {

  }
#line 6003
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 6004
  byteToSectorShift = (unsigned long )(7 + (int )driveMediaConstants->SectorLengthCode);
#line 6005
  firstSector = irpSp->Parameters.Read.ByteOffset.__annonCompField1.LowPart >> byteToSectorShift;
#line 6006
  lastSector = firstSector + (irpSp->Parameters.Read.Length >> byteToSectorShift);
#line 6007
  sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
#line 6008
  numberOfHeads = driveMediaConstants->NumberOfHeads;
#line 6009
  if ((int )(Irp->MdlAddress)->MdlFlags & 5) {
#line 6010
    userBuffer = (CHAR *)(Irp->MdlAddress)->MappedSystemVa;
  } else {
#line 6013
    tmp___0 = (void *)0;
#line 6014
    userBuffer = (CHAR *)tmp___0;
  }
#line 6017
  if ((unsigned int )userBuffer == (unsigned int )((void *)0)) {
#line 6020
    return (-1073741670L);
  } else {

  }
#line 6024
  trackSize = (unsigned long )sectorsPerTrack << byteToSectorShift;
#line 6025
  skew = (unsigned char)0;
#line 6026
  skewDelta = driveMediaConstants->SkewDelta;
#line 6027
  currentSector = firstSector;
  {
#line 6029
  while (1) {
    while_15_continue: /* CIL Label */ ;

#line 6031
    if (currentSector < lastSector) {

    } else {
      goto while_161_break;
    }
#line 6036
    currentCylinder = (unsigned char )((currentSector / (unsigned long )sectorsPerTrack) / (unsigned long )numberOfHeads);
#line 6037
    trackSector = (unsigned char )(currentSector % (unsigned long )sectorsPerTrack);
#line 6038
    currentHead = (unsigned char )((currentSector / (unsigned long )sectorsPerTrack) % (unsigned long )numberOfHeads);
#line 6039
    numTransferSectors = (unsigned char )((int )sectorsPerTrack - (int )trackSector);
#line 6040
    if (lastSector - currentSector < (unsigned long )numTransferSectors) {
#line 6041
      numTransferSectors = (unsigned char )(lastSector - currentSector);
    } else {

    }
#line 6045
    if (trackSize > DisketteExtension->MaxTransferSize) {
      {
#line 6049
      FlAllocateIoBuffer(DisketteExtension, trackSize);
      }
#line 6051
      if (! DisketteExtension->IoBuffer) {
#line 6054
        return (-1073741670L);
      } else {

      }
#line 6058
      mdl = DisketteExtension->IoBufferMdl;
#line 6059
      ioBuffer = (CHAR *)DisketteExtension->IoBuffer;
#line 6060
      ioOffset = 0UL;
#line 6061
      if (writeOperation) {
        {
#line 6063
        memmove((void *)ioBuffer, (void const   *)(userBuffer + ((currentSector - firstSector) << byteToSectorShift)),
                (unsigned int )((unsigned long )numTransferSectors << byteToSectorShift));
        }
      } else {

      }
    } else {
#line 6070
      mdl = Irp->MdlAddress;
#line 6071
      ioOffset = (currentSector - firstSector) << byteToSectorShift;
    }
#line 6073
    if ((int )skew >= (int )numTransferSectors + (int )trackSector) {
#line 6074
      skew = (unsigned char)0;
    } else {

    }
#line 6078
    if ((int )skew < (int )trackSector) {
#line 6079
      skew = trackSector;
    } else {

    }
    {
#line 6084
    status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset + (((unsigned long )skew - (unsigned long )trackSector) << byteToSectorShift),
                              writeOperation, currentCylinder, currentHead, skew,
                              (unsigned char )(((int )numTransferSectors + (int )trackSector) - (int )skew),
                              (unsigned char)1);
    }
#line 6089
    if (status >= 0L) {
#line 6090
      if ((int )skew > (int )trackSector) {
        {
#line 6092
        status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset, writeOperation,
                                  currentCylinder, currentHead, trackSector, (unsigned char )((int )skew - (int )trackSector),
                                  (unsigned char)0);
        }
      } else {
#line 6097
        skew = (unsigned char )(((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack);
      }
    } else {
#line 6100
      skew = (unsigned char )(((int )numTransferSectors + (int )trackSector) % (int )sectorsPerTrack);
    }
#line 6102
    if (! (status >= 0L)) {
      goto while_161_break;
    } else {

    }
#line 6107
    if (! writeOperation) {
#line 6108
      if (trackSize > DisketteExtension->MaxTransferSize) {
        {
#line 6110
        memmove((void *)(userBuffer + ((currentSector - firstSector) << byteToSectorShift)),
                (void const   *)ioBuffer, (unsigned int )((unsigned long )numTransferSectors << byteToSectorShift));
        }
      } else {

      }
    } else {

    }
#line 6119
    skew = (unsigned char )(((int )skew + (int )skewDelta) % (int )sectorsPerTrack);
#line 6120
    currentSector += (unsigned long )numTransferSectors;
  }
  while_15_break: /* CIL Label */ ;
  }
  while_161_break: 
#line 6124
  Irp->IoStatus.Information = (currentSector - firstSector) << byteToSectorShift;
#line 6125
  if (status >= 0L) {
#line 6126
    if (firstSector == 0UL) {
      {
#line 6128
      FlConsolidateMediaTypeWithBootSector(DisketteExtension, (struct _BOOT_SECTOR_INFO *)userBuffer);
      }
    } else {

    }
  } else {

  }
#line 6138
  return (status);
}
}
#line 6141 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ LARGE_INTEGER headSettleTime ;
  PIO_STACK_LOCATION irpSp ;
  PBAD_TRACK_NUMBER badTrackBuffer ;
  PFORMAT_PARAMETERS formatParameters ;
  PFORMAT_EX_PARAMETERS formatExParameters ;
  PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  NTSTATUS ntStatus ;
  ULONG badTrackBufferLength ;
  DRIVE_MEDIA_TYPE driveMediaType ;
  UCHAR driveStatus ;
  UCHAR numberOfBadTracks ;
  UCHAR currentTrack ;
  UCHAR endTrack ;
  UCHAR whichSector ;
  UCHAR retryCount ;
  BOOLEAN bufferOverflow ;
  FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;
  ULONG length ;
  UCHAR tmp ;

  {
#line 6163
  numberOfBadTracks = (unsigned char)0;
#line 6164
  bufferOverflow = (unsigned char)0;
#line 6167
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6168
  formatParameters = (struct _FORMAT_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
#line 6169
  if (irpSp->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((7 << 16) | (3 << 14)) | (11 << 2))) {
#line 6170
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)Irp->AssociatedIrp.SystemBuffer;
  } else {
#line 6172
    formatExParameters = (struct _FORMAT_EX_PARAMETERS *)((void *)0);
  }
#line 6176
  badTrackBufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;
#line 6177
  driveMediaType = (DriveMediaLimits + (int )DisketteExtension->DriveType)->HighestDriveMediaType;
  {
#line 6179
  while (1) {
    while_16_continue: /* CIL Label */ ;

#line 6181
    if ((int )(DriveMediaConstants + (int )driveMediaType)->MediaType != (int )formatParameters->MediaType) {
#line 6182
      if ((int )driveMediaType > (int )(DriveMediaLimits + (int )DisketteExtension->DriveType)->LowestDriveMediaType) {

      } else {
        goto while_167_break;
      }
    } else {
      goto while_167_break;
    }
#line 6190
    driveMediaType = (enum _DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
  while_16_break: /* CIL Label */ ;
  }
  while_167_break: 
#line 6194
  driveMediaConstants = DriveMediaConstants + (int )driveMediaType;
#line 6195
  DisketteExtension->MediaType = formatParameters->MediaType;
#line 6196
  DisketteExtension->DriveMediaType = driveMediaType;
#line 6197
  DisketteExtension->DriveMediaConstants = *(DriveMediaConstants + (int )driveMediaType);
#line 6198
  if (formatExParameters) {
#line 6199
    DisketteExtension->DriveMediaConstants.SectorsPerTrack = (unsigned char )formatExParameters->SectorsPerTrack;
#line 6200
    DisketteExtension->DriveMediaConstants.FormatGapLength = (unsigned char )formatExParameters->FormatGapLength;
  } else {

  }
#line 6204
  driveMediaConstants = & DisketteExtension->DriveMediaConstants;
#line 6205
  DisketteExtension->BytesPerSector = (unsigned long )driveMediaConstants->BytesPerSector;
#line 6206
  DisketteExtension->ByteCapacity = (unsigned long )((((int )driveMediaConstants->BytesPerSector * (int )driveMediaConstants->SectorsPerTrack) * (1 + (int )driveMediaConstants->MaximumTrack)) * (int )driveMediaConstants->NumberOfHeads);
#line 6207
  currentTrack = (unsigned char )(formatParameters->StartCylinderNumber * (unsigned long )driveMediaConstants->NumberOfHeads + formatParameters->StartHeadNumber);
#line 6208
  endTrack = (unsigned char )(formatParameters->EndCylinderNumber * (unsigned long )driveMediaConstants->NumberOfHeads + formatParameters->EndHeadNumber);
#line 6211
  if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
    {
#line 6213
    FlHdbit(DisketteExtension);
    }
  } else {

  }
#line 6218
  if ((int )DisketteExtension->LastDriveMediaType != (int )driveMediaType) {
    {
#line 6220
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
    }
#line 6222
    if (! (ntStatus >= 0L)) {
#line 6223
      return (ntStatus);
    } else {

    }
  } else {

  }
#line 6230
  DisketteExtension->IsReadOnly = (unsigned char)0;
  {
#line 6232
  while (1) {
    while_17_continue: /* CIL Label */ ;
    {
#line 6234
    DisketteExtension->FifoBuffer[0] = (unsigned char)16;
#line 6235
    DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 6236
    DisketteExtension->FifoBuffer[2] = (unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift);
#line 6240
    ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer, DisketteExtension->FifoBuffer,
                              (struct _MDL *)((void *)0), 0UL, 0UL);
    }
#line 6243
    if (ntStatus >= 0L) {
#line 6244
      if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 6245
        if ((int )DisketteExtension->FifoBuffer[1] == (int )((unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads << (int )driveMediaConstants->CylinderShift))) {
          {
#line 6247
          headSettleTime.__annonCompField1.LowPart = (unsigned long )(- (10000 * (int )driveMediaConstants->HeadSettleTime));
#line 6248
          headSettleTime.__annonCompField1.HighPart = -1L;
#line 6249
          KeDelayExecutionThread((char)0, (unsigned char)0, & headSettleTime);
          }
#line 6251
          if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {

          } else {
            {
#line 6255
            DisketteExtension->FifoBuffer[0] = (unsigned char)84;
#line 6256
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 6257
            ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                      DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                      0UL, 0UL);
            }
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
#line 6269
        DisketteExtension->HardwareFailed = (unsigned char)1;
#line 6270
        ntStatus = -1073741464L;
      }
    } else {

    }
#line 6275
    if (! (ntStatus >= 0L)) {
#line 6278
      return (ntStatus);
    } else {

    }
#line 6282
    whichSector = (unsigned char)0;
    {
#line 6284
    while (1) {
      while_18_continue: /* CIL Label */ ;

#line 6286
      if ((int )whichSector < (int )driveMediaConstants->SectorsPerTrack) {

      } else {
        goto while_173_break;
      }
#line 6291
      *(DisketteExtension->IoBuffer + (int )whichSector * 4) = (unsigned char )((int )currentTrack / (int )driveMediaConstants->NumberOfHeads);
#line 6292
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 1)) = (unsigned char )((int )currentTrack % (int )driveMediaConstants->NumberOfHeads);
#line 6293
      if (formatExParameters) {
#line 6294
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (unsigned char )formatExParameters->SectorNumber[whichSector];
      } else {
#line 6296
        *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 2)) = (unsigned char )((int )whichSector + 1);
      }
#line 6298
      *(DisketteExtension->IoBuffer + ((int )whichSector * 4 + 3)) = driveMediaConstants->SectorLengthCode;
#line 6301
      whichSector = (unsigned char )((int )whichSector + 1);
    }
    while_18_break: /* CIL Label */ ;
    }
    while_173_break: 
#line 6305
    retryCount = (unsigned char)0;
    {
#line 6307
    while (1) {
      while_19_continue: /* CIL Label */ ;
      {
#line 6309
      length = (unsigned long )driveMediaConstants->BytesPerSector;
#line 6310
      DisketteExtension->FifoBuffer[0] = (unsigned char)71;
#line 6311
      DisketteExtension->FifoBuffer[1] = (unsigned char )(((int )currentTrack % (int )driveMediaConstants->NumberOfHeads << 2) | (int )DisketteExtension->DeviceUnit);
#line 6312
      DisketteExtension->FifoBuffer[2] = driveMediaConstants->SectorLengthCode;
#line 6313
      DisketteExtension->FifoBuffer[3] = driveMediaConstants->SectorsPerTrack;
#line 6314
      DisketteExtension->FifoBuffer[4] = driveMediaConstants->FormatGapLength;
#line 6315
      DisketteExtension->FifoBuffer[5] = driveMediaConstants->FormatFillCharacter;
#line 6319
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, DisketteExtension->IoBufferMdl,
                                0UL, length);
      }
#line 6323
      if (! (ntStatus >= 0L)) {

      } else {

      }
#line 6329
      if (ntStatus >= 0L) {
#line 6330
        if ((int )DisketteExtension->FifoBuffer[0] & 208) {
          goto _L___0;
        } else {
#line 6333
          if ((int )DisketteExtension->FifoBuffer[1] & 16) {
            goto _L___0;
          } else {
#line 6336
            if ((int )DisketteExtension->FifoBuffer[2] != 0) {
              _L___0: 
              {
#line 6341
              DisketteExtension->HardwareFailed = (unsigned char)1;
#line 6342
              ntStatus = FlInterpretError(DisketteExtension->FifoBuffer[1], DisketteExtension->FifoBuffer[2]);
              }
            } else {

            }
          }
        }
      } else {

      }
#line 6352
      if (! (ntStatus >= 0L)) {
#line 6353
        tmp = retryCount;
#line 6354
        retryCount = (unsigned char )((int )retryCount + 1);
#line 6355
        if ((int )tmp < 3) {

        } else {
          goto while_175_break;
        }
      } else {
        goto while_175_break;
      }
    }
    while_19_break: /* CIL Label */ ;
    }
    while_175_break: ;
#line 6366
    if (! (ntStatus >= 0L)) {
#line 6367
      if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
        {
#line 6369
        DisketteExtension->FifoBuffer[0] = (unsigned char)14;
#line 6370
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
#line 6371
        ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                  DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                  0UL, 0UL);
        }
#line 6374
        if (! (ntStatus >= 0L)) {
#line 6377
          return (ntStatus);
        } else {

        }
#line 6381
        if ((int )DisketteExtension->FifoBuffer[0] & 32) {
#line 6382
          driveStatus = (unsigned char)127;
        } else {
#line 6384
          driveStatus = (unsigned char)128;
        }
      } else {
        {
#line 6388
        ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (776 << 2)) | 3),
                                 (void *)(& fdcDiskChangeParms));
#line 6390
        driveStatus = fdcDiskChangeParms.DriveStatus;
        }
      }
#line 6393
      if ((int )DisketteExtension->DriveType != 0) {
#line 6394
        if ((int )driveStatus & 128) {
#line 6395
          return (-1073741805L);
        } else {

        }
      } else {

      }
#line 6404
      if (badTrackBufferLength >= (unsigned long )((unsigned int )((int )numberOfBadTracks + 1) * sizeof(BAD_TRACK_NUMBER ))) {
#line 6405
        badTrackBuffer = (USHORT *)Irp->AssociatedIrp.SystemBuffer;
#line 6406
        *(badTrackBuffer + (int )numberOfBadTracks) = (unsigned short )currentTrack;
      } else {
#line 6408
        bufferOverflow = (unsigned char)1;
      }
#line 6410
      numberOfBadTracks = (unsigned char )((int )numberOfBadTracks + 1);
    } else {

    }
#line 6414
    currentTrack = (unsigned char )((int )currentTrack + 1);
#line 6415
    if ((int )currentTrack <= (int )endTrack) {

    } else {
      goto while_169_break;
    }
  }
  while_17_break: /* CIL Label */ ;
  }
  while_169_break: ;
#line 6423
  if (ntStatus >= 0L) {
#line 6424
    if (bufferOverflow) {
#line 6425
      ntStatus = -2147483643L;
    } else {

    }
  } else {

  }
#line 6432
  return (ntStatus);
}
}
#line 6435 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension , PFORMAT_PARAMETERS FormatParameters ) 
{ PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
  DRIVE_MEDIA_TYPE driveMediaType ;

  {
#line 6440
  driveMediaType = (DriveMediaLimits + (int )DisketteExtension->DriveType)->HighestDriveMediaType;
  {
#line 6442
  while (1) {
    while_20_continue: /* CIL Label */ ;

#line 6444
    if ((int )(DriveMediaConstants + (int )driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
#line 6445
      if ((int )driveMediaType > (int )(DriveMediaLimits + (int )DisketteExtension->DriveType)->LowestDriveMediaType) {

      } else {
        goto while_181_break;
      }
    } else {
      goto while_181_break;
    }
#line 6453
    driveMediaType = (enum _DRIVE_MEDIA_TYPE )((int )driveMediaType - 1);
  }
  while_20_break: /* CIL Label */ ;
  }
  while_181_break: ;
#line 6457
  if ((int )(DriveMediaConstants + (int )driveMediaType)->MediaType != (int )FormatParameters->MediaType) {
#line 6458
    return ((unsigned char)0);
  } else {
#line 6460
    driveMediaConstants = DriveMediaConstants + (int )driveMediaType;
#line 6461
    if (FormatParameters->StartHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
#line 6462
      return ((unsigned char)0);
    } else {
#line 6464
      if (FormatParameters->EndHeadNumber > (unsigned long )((int )driveMediaConstants->NumberOfHeads - 1)) {
#line 6465
        return ((unsigned char)0);
      } else {
#line 6467
        if (FormatParameters->StartCylinderNumber > (unsigned long )driveMediaConstants->MaximumTrack) {
#line 6468
          return ((unsigned char)0);
        } else {
#line 6470
          if (FormatParameters->EndCylinderNumber > (unsigned long )driveMediaConstants->MaximumTrack) {
#line 6471
            return ((unsigned char)0);
          } else {
#line 6473
            if (FormatParameters->EndCylinderNumber < FormatParameters->StartCylinderNumber) {
#line 6474
              return ((unsigned char)0);
            } else {
#line 6476
              if ((int )((KUSER_SHARED_DATA * const  )4292804608U)->AlternativeArchitecture == 1) {
#line 6477
                if ((int )FormatParameters->MediaType == 6) {
#line 6478
                  return ((unsigned char)0);
                } else {
#line 6480
                  if ((int )FormatParameters->MediaType == 7) {
#line 6481
                    return ((unsigned char)0);
                  } else {
#line 6483
                    if ((int )FormatParameters->MediaType == 8) {
#line 6484
                      return ((unsigned char)0);
                    } else {
#line 6486
                      if ((int )FormatParameters->MediaType == 9) {
#line 6487
                        return ((unsigned char)0);
                      } else {
#line 6489
                        if ((int )FormatParameters->MediaType == 10) {
#line 6490
                          return ((unsigned char)0);
                        } else {

                        }
                      }
                    }
                  }
                }
              } else {

              }
#line 6501
              return ((unsigned char)1);
            }
          }
        }
      }
    }
  }
}
}
#line 6510 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR FifoInBuffer ,
                        PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset , ULONG TransferBytes ) 
{ NTSTATUS ntStatus ;
  ISSUE_FDC_COMMAND_PARMS issueCommandParms ;

  {
  {
#line 6516
  issueCommandParms.FifoInBuffer = FifoInBuffer;
#line 6517
  issueCommandParms.FifoOutBuffer = FifoOutBuffer;
#line 6518
  issueCommandParms.IoHandle = (void *)IoMdl;
#line 6519
  issueCommandParms.IoOffset = IoOffset;
#line 6520
  issueCommandParms.TransferBytes = TransferBytes;
#line 6521
  issueCommandParms.TimeOut = 4UL;
#line 6525
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (771 << 2)) | 3),
                           (void *)(& issueCommandParms));
  }
#line 6528
  if (ntStatus == -1073741661L) {
#line 6529
    DisketteExtension->HardwareFailed = (unsigned char)1;
  } else {
#line 6531
    if (ntStatus == -1073741464L) {
#line 6532
      DisketteExtension->HardwareFailed = (unsigned char)1;
    } else {

    }
  }
#line 6537
  return (ntStatus);
}
}
#line 6540 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;

  {
  {
#line 6545
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (773 << 2)) | 3),
                           (void *)0);
  }
#line 6548
  if (ntStatus >= 0L) {
#line 6549
    if ((int )DisketteExtension->PerpendicularMode != 0) {
      {
#line 6551
      DisketteExtension->FifoBuffer[0] = (unsigned char)21;
#line 6552
      DisketteExtension->FifoBuffer[1] = (unsigned char )(128 | ((int )DisketteExtension->PerpendicularMode << 2));
#line 6553
      ntStatus = FlIssueCommand(DisketteExtension, DisketteExtension->FifoBuffer,
                                DisketteExtension->FifoBuffer, (struct _MDL *)((void *)0),
                                0UL, 0UL);
      }
    } else {

    }
  } else {

  }
#line 6562
  return (ntStatus);
}
}
#line 6565 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data ) 
{ NTSTATUS ntStatus ;
  PIRP irp ;
  PIO_STACK_LOCATION irpStack ;
  KEVENT doneEvent ;
  IO_STATUS_BLOCK ioStatus ;

  {
  {
#line 6577
  irp = IoBuildDeviceIoControlRequest(Ioctl, DeviceObject, (void *)0, 0UL, (void *)0,
                                      0UL, (unsigned char)1, & doneEvent, & ioStatus);
  }
#line 6580
  if ((unsigned int )irp == (unsigned int )((void *)0)) {
#line 6583
    return (-1073741670L);
  } else {

  }
  {
#line 6588
  irpStack = irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 6589
  irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;
#line 6590
  ntStatus = IofCallDriver(DeviceObject, irp);
  }
#line 6592
  if (ntStatus == 259L) {
    {
#line 6594
    KeWaitForSingleObject((void *)(& doneEvent), (enum _KWAIT_REASON )5, (char)0,
                          (unsigned char)0, (LARGE_INTEGER *)((void *)0));
#line 6595
    ntStatus = ioStatus.__annonCompField4.Status;
    }
  } else {

  }
#line 6600
  return (ntStatus);
}
}
#line 6603 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) 
{ NTSTATUS ntStatus ;
  SHORT st5 ;
  BOOLEAN media144MB ;
  BOOLEAN mediaUpTo120MB ;
  BOOLEAN supportDrive ;
  SET_HD_BIT_PARMS setHdBitParameter ;

  {
#line 6612
  st5 = (short)0;
#line 6613
  media144MB = (unsigned char)0;
#line 6614
  mediaUpTo120MB = (unsigned char)0;
#line 6615
  supportDrive = (unsigned char)1;
#line 6618
  if ((int )DisketteExtension->DriveMediaType == 18) {
    goto switch_186_18;
  } else {
#line 6621
    if ((int )DisketteExtension->DriveMediaType == 16) {
      goto switch_186_16;
    } else {
#line 6624
      if ((int )DisketteExtension->DriveMediaType == 17) {
        goto switch_186_17;
      } else {
#line 6627
        if ((int )DisketteExtension->DriveMediaType == 12) {
          goto switch_186_12;
        } else {
#line 6630
          if ((int )DisketteExtension->DriveMediaType == 13) {
            goto switch_186_13;
          } else {
#line 6633
            if ((int )DisketteExtension->DriveMediaType == 19) {
              goto switch_186_19;
            } else {
#line 6636
              if ((int )DisketteExtension->DriveMediaType == 20) {
                goto switch_186_20;
              } else {
#line 6639
                if ((int )DisketteExtension->DriveMediaType == 0) {
                  goto switch_186_0;
                } else {
#line 6642
                  if ((int )DisketteExtension->DriveMediaType == 1) {
                    goto switch_186_1;
                  } else {
#line 6645
                    if ((int )DisketteExtension->DriveMediaType == 2) {
                      goto switch_186_2;
                    } else {
#line 6648
                      if ((int )DisketteExtension->DriveMediaType == 3) {
                        goto switch_186_3;
                      } else {
#line 6651
                        if ((int )DisketteExtension->DriveMediaType == 4) {
                          goto switch_186_4;
                        } else {
#line 6654
                          if ((int )DisketteExtension->DriveMediaType == 5) {
                            goto switch_186_5;
                          } else {
#line 6657
                            if ((int )DisketteExtension->DriveMediaType == 6) {
                              goto switch_186_6;
                            } else {
#line 6660
                              if ((int )DisketteExtension->DriveMediaType == 7) {
                                goto switch_186_7;
                              } else {
#line 6663
                                if ((int )DisketteExtension->DriveMediaType == 8) {
                                  goto switch_186_8;
                                } else {
#line 6666
                                  if ((int )DisketteExtension->DriveMediaType == 9) {
                                    goto switch_186_9;
                                  } else {
#line 6669
                                    if ((int )DisketteExtension->DriveMediaType == 10) {
                                      goto switch_186_10;
                                    } else {
#line 6672
                                      if ((int )DisketteExtension->DriveMediaType == 11) {
                                        goto switch_186_11;
                                      } else {
#line 6675
                                        if ((int )DisketteExtension->DriveMediaType == 14) {
                                          goto switch_186_14;
                                        } else {
#line 6678
                                          if ((int )DisketteExtension->DriveMediaType == 15) {
                                            goto switch_186_15;
                                          } else {
                                            goto switch_186_default;
#line 6683
                                            if (0) {
                                              switch_186_18: 
#line 6685
                                              media144MB = (unsigned char)1;
                                              switch_186_16: ;
                                              switch_186_17: ;
                                              switch_186_12: ;
                                              switch_186_13: ;
                                              switch_186_19: ;
                                              switch_186_20: 
#line 6692
                                              mediaUpTo120MB = (unsigned char)1;
                                              switch_186_0: ;
                                              switch_186_1: ;
                                              switch_186_2: ;
                                              switch_186_3: ;
                                              switch_186_4: ;
                                              switch_186_5: ;
                                              switch_186_6: ;
                                              switch_186_7: ;
                                              switch_186_8: ;
                                              switch_186_9: ;
                                              switch_186_10: ;
                                              switch_186_11: ;
                                              switch_186_14: ;
                                              switch_186_15: ;
                                              goto switch_186_break;
                                              switch_186_default: 
#line 6709
                                              mediaUpTo120MB = (unsigned char)1;
                                              goto switch_186_break;
                                            } else {
                                              switch_186_break: ;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 6736
  setHdBitParameter.Media144MB = media144MB;
#line 6737
  setHdBitParameter.More120MB = mediaUpTo120MB;
#line 6738
  setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
#line 6739
  if ((int )DisketteExtension->DriveType == 3) {
#line 6740
    setHdBitParameter.DriveType144MB = (unsigned char)1;
  } else {
#line 6742
    setHdBitParameter.DriveType144MB = (unsigned char)0;
  }
  {
#line 6745
  ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, (unsigned long )(((7 << 16) | (785 << 2)) | 3),
                           (void *)(& setHdBitParameter));
  }
#line 6748
  if (! (ntStatus >= 0L)) {
#line 6749
    return (ntStatus);
  } else {

  }
#line 6753
  if (setHdBitParameter.ChangedHdBit) {
    {
#line 6755
    ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
    }
  } else {

  }
#line 6760
  return (ntStatus);
}
}
#line 6763 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) 
{ KIRQL oldIrql ;
  NTSTATUS ntStatus ;
  LONG tmp ;

  {
#line 6771
  PagingReferenceCount += 1UL;
#line 6773
  if (PagingReferenceCount == 1UL) {

  } else {

  }
  {
#line 6782
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
#line 6783
  InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)(& FloppyCancelQueuedRequest)));
  }
#line 6785
  if (Irp->Cancel) {
    {
#line 6787
    tmp = InterlockedExchange((LONG *)((PVOID *)(& Irp->CancelRoutine)), (long )((void *)0));
    }
#line 6789
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
      {
#line 6791
      Irp->IoStatus.__annonCompField4.Status = -1073741536L;
#line 6792
      myStatus = -1073741536L;
#line 6793
      Irp->IoStatus.Information = 0UL;
#line 6795
      IofCompleteRequest(Irp, (char)0);
#line 6797
      PagingReferenceCount -= 1UL;
      }
#line 6799
      if (PagingReferenceCount == 0UL) {

      } else {

      }
#line 6808
      ntStatus = -1073741536L;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 6815
    Irp->IoStatus.__annonCompField4.Status = 259L;
#line 6816
    myStatus = 259L;
#line 6817
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
#line 6818
    if (pended == 0) {
#line 6819
      pended = 1;
    } else {
      {
#line 6822
      errorFn();
      }
    }
    {
#line 6826
    ExfInterlockedInsertTailList(& DisketteExtension->NewRequestQueue, & Irp->Tail.Overlay.__annonCompField17.ListEntry,
                                 & DisketteExtension->NewRequestQueueSpinLock);
#line 6829
    ntStatus = 259L;
    }
  }
#line 6832
  return (ntStatus);
}
}
#line 6835 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PDISKETTE_EXTENSION disketteExtension ;
  KIRQL oldIrql ;
  PLIST_ENTRY _EX_Blink ;
  PLIST_ENTRY _EX_Flink ;

  {
  {
#line 6842
  disketteExtension = (DISKETTE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6846
  oldIrql = KfAcquireSpinLock(& disketteExtension->FlCancelSpinLock);
#line 6847
  Irp->IoStatus.__annonCompField4.Status = -1073741536L;
#line 6848
  myStatus = -1073741536L;
#line 6849
  Irp->IoStatus.Information = 0UL;
  }
#line 6851
  if (Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink) {
#line 6852
    _EX_Flink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Flink;
#line 6853
    _EX_Blink = Irp->Tail.Overlay.__annonCompField17.ListEntry.Blink;
#line 6854
    _EX_Blink->Flink = _EX_Flink;
#line 6855
    _EX_Flink->Blink = _EX_Blink;
  } else {

  }
  {
#line 6862
  IofCompleteRequest(Irp, (char)0);
#line 6864
  PagingReferenceCount -= 1UL;
  }
#line 6866
  if (PagingReferenceCount == 0UL) {

  } else {

  }
#line 6876
  return;
}
}
#line 6879 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) 
{ KIRQL oldIrql ;
  PLIST_ENTRY headOfList ;
  PIRP currentIrp ;
  PIO_STACK_LOCATION irpSp ;
  LONG tmp ;

  {
  {
#line 6888
  oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
  }
  {
#line 6891
  while (1) {
    while_21_continue: /* CIL Label */ ;
    {
#line 6894
    headOfList = ExfInterlockedRemoveHeadList(& DisketteExtension->NewRequestQueue,
                                              & DisketteExtension->NewRequestQueueSpinLock);
    }
#line 6897
    if ((unsigned int )headOfList != (unsigned int )((void *)0)) {

    } else {
      goto while_188_break;
    }
    {
#line 6903
    currentIrp = (IRP *)((CHAR *)headOfList - (unsigned long )(& ((IRP *)0)->Tail.Overlay.__annonCompField17.ListEntry));
#line 6904
    tmp = InterlockedExchange((LONG *)((PVOID *)(& currentIrp->CancelRoutine)), (long )((void *)0));
    }
#line 6906
    if ((void (*)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ))((void *)tmp)) {
#line 6907
      irpSp = currentIrp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
    } else {
#line 6909
      currentIrp->Tail.Overlay.__annonCompField17.ListEntry.Flink = (struct _LIST_ENTRY *)((void *)0);
#line 6910
      currentIrp = (struct _IRP *)((void *)0);
    }
#line 6915
    if (currentIrp) {
#line 6916
      if (DisketteExtension->IsRemoved) {
        {
#line 6918
        currentIrp->IoStatus.Information = 0UL;
#line 6919
        currentIrp->IoStatus.__annonCompField4.Status = -1073741738L;
#line 6920
        IofCompleteRequest(currentIrp, (char)0);
        }
      } else {
#line 6923
        if ((int )irpSp->MajorFunction == 3) {
          goto switch_189_3;
        } else {
#line 6926
          if ((int )irpSp->MajorFunction == 4) {
            goto switch_189_4;
          } else {
#line 6929
            if ((int )irpSp->MajorFunction == 14) {
              goto switch_189_14;
            } else {
              goto switch_189_default;
#line 6934
              if (0) {
                switch_189_3: ;
                switch_189_4: 
                {
#line 6938
                FloppyReadWrite(DisketteExtension->DeviceObject, currentIrp);
                }
                goto switch_189_break;
                switch_189_14: 
                {
#line 6943
                FloppyDeviceControl(DisketteExtension->DeviceObject, currentIrp);
                }
                goto switch_189_break;
                switch_189_default: 
                {
#line 6948
                currentIrp->IoStatus.Information = 0UL;
#line 6949
                currentIrp->IoStatus.__annonCompField4.Status = -1073741823L;
#line 6950
                IofCompleteRequest(currentIrp, (char)0);
                }
              } else {
                switch_189_break: ;
              }
            }
          }
        }
      }
    } else {

    }
#line 6963
    if (currentIrp) {
#line 6966
      PagingReferenceCount -= 1UL;
#line 6968
      if (PagingReferenceCount == 0UL) {

      } else {

      }
    } else {

    }
    {
#line 6982
    oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
    }
  }
  while_21_break: /* CIL Label */ ;
  }
  while_188_break: ;
#line 6990
  return;
}
}
#line 6997
#pragma warning(push)
#line 6998
#pragma warning(disable:4035)
#line 6999
#pragma warning(pop)
#line 7001
#pragma warning(disable:4103)
#line 7002
#pragma warning(disable:4103)
#line 7003
#pragma warning(push)
#line 7004
#pragma warning(disable:4035)
#line 7005
#pragma warning(pop)
#line 7006
#pragma warning(disable:4035)
#line 7007
#pragma warning(push)
#line 7008
#pragma warning(disable:4164)
#line 7009
#pragma function(_enable)
#line 7010
#pragma function(_disable)
#line 7011
#pragma warning(pop)
#line 7012
#pragma warning(disable:4103)
#line 7013
#pragma warning(disable:4103)
#line 7014
#pragma warning(disable:4103)
#line 7015
#pragma warning(disable:4103)
#line 7016
#pragma warning(disable:4103)
#line 7017
#pragma warning(disable:4103)
#line 7018
#pragma warning(disable:4200)
#line 7019
#pragma warning(default:4200)
#line 7020 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
IRP *pirp  ;
#line 7021 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void stub_driver_init(void) 
{ 

  {
#line 7025
  s = NP;
#line 7026
  pended = 0;
#line 7027
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 7028
  compRegistered = 0;
#line 7029
  lowerDriverReturn = 0;
#line 7030
  setEventCalled = 0;
#line 7031
  customIrp = 0;
#line 7032
  return;
}
}
#line 7035 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
int main(void) 
{ DRIVER_OBJECT d ;
  UNICODE_STRING u ;
  NTSTATUS status ;
  int we_should_unload ;
  IRP irp ;
  int __BLAST_NONDET ;
  int irp_choice ;
  DEVICE_OBJECT devobj ;

  {
  {
#line 7047
  status = 0L;
#line 7048
  pirp = & irp;
#line 7049
  _BLAST_init();
#line 7050
  status = DriverEntry(& d, & u);
  }
#line 7052
  if (status >= 0L) {
#line 7053
    s = NP;
#line 7054
    customIrp = 0;
#line 7055
    setEventCalled = customIrp;
#line 7056
    lowerDriverReturn = setEventCalled;
#line 7057
    compRegistered = lowerDriverReturn;
#line 7058
    compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 7059
    pended = (int )compFptr;
#line 7060
    pirp->IoStatus.__annonCompField4.Status = 0L;
#line 7061
    myStatus = 0L;
#line 7062
    if (irp_choice == 0) {
#line 7063
      pirp->IoStatus.__annonCompField4.Status = -1073741637L;
#line 7064
      myStatus = -1073741637L;
    } else {

    }
    {
#line 7069
    stub_driver_init();
    }
#line 7071
    if (! (status >= 0L)) {
#line 7072
      return (-1);
    } else {

    }
#line 7076
    if (__BLAST_NONDET == 0) {
      goto switch_190_0;
    } else {
#line 7079
      if (__BLAST_NONDET == 1) {
        goto switch_190_1;
      } else {
#line 7082
        if (__BLAST_NONDET == 2) {
          goto switch_190_2;
        } else {
#line 7085
          if (__BLAST_NONDET == 3) {
            goto switch_190_3;
          } else {
#line 7088
            if (__BLAST_NONDET == 4) {
              goto switch_190_4;
            } else {
              goto switch_190_default;
#line 7093
              if (0) {
                switch_190_0: 
                {
#line 7096
                status = FloppyCreateClose(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_1: 
                {
#line 7101
                status = FloppyCreateClose(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_2: 
                {
#line 7106
                status = FloppyDeviceControl(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_3: 
                {
#line 7111
                status = FloppyPnp(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_4: 
                {
#line 7116
                status = FloppyPower(& devobj, pirp);
                }
                goto switch_190_break;
                switch_190_default: ;
#line 7120
                return (-1);
              } else {
                switch_190_break: ;
              }
            }
          }
        }
      }
    }
#line 7130
    if (we_should_unload) {
      {
#line 7132
      FloppyUnload(& d);
      }
    } else {

    }
  } else {

  }
#line 7140
  if (pended == 1) {
#line 7141
    if (s == NP) {
#line 7142
      s = NP;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
#line 7148
    if (pended == 1) {
#line 7149
      if (s == MPR3) {
#line 7150
        s = MPR3;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 7156
      if (s == UNLOADED) {

      } else {
#line 7159
        if (status == -1L) {

        } else {
#line 7162
          if (s != SKIP2) {
#line 7163
            if (s != IPC) {
#line 7164
              if (s != DC) {
                {
#line 7166
                errorFn();
                }
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
#line 7176
            if (pended == 1) {
#line 7177
              if (status != 259L) {
#line 7178
                status = 0L;
              } else {

              }
            } else {
#line 7183
              if (s == DC) {
#line 7184
                if (status == 259L) {
                  {
#line 7186
                  errorFn();
                  }
                } else {

                }
              } else {
#line 7192
                if (status != (long )lowerDriverReturn) {
                  {
#line 7194
                  errorFn();
                  }
                } else {

                }
              }
            }
          }
        }
      }
    }
  }
#line 7206
  status = 0L;
#line 7207
  return ((int )status);
}
}
#line 7210 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
char _SLAM_alloc_dummy  ;
#line 7211 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
char *qdpt_malloc(int i ) 
{ 

  {
#line 7215
  return (& _SLAM_alloc_dummy);
}
}
#line 7219 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 7223
  return;
}
}
#line 7227 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 7231
  return;
}
}
#line 7237 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) 
{ PVOID x ;
  char *tmp ;

  {
#line 7244
  tmp = & _SLAM_alloc_dummy;
#line 7245
  x = (void *)tmp;
#line 7247
  return (x);
}
}
#line 7251 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void ExFreePool(PVOID P ) 
{ 

  {
#line 7255
  return;
}
}
#line 7261 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 7267
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7273 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 7279
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7284 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) 
{ 

  {
#line 7289
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7295 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 7301
  if (__BLAST_NONDET == 0) {
    goto switch_191_0;
  } else {
    goto switch_191_default;
#line 7306
    if (0) {
      switch_191_0: 
#line 7309
      tmp = & _SLAM_alloc_dummy;
#line 7311
      return ((struct _MDL *)((void *)tmp));
      switch_191_default: ;
#line 7313
      return ((struct _MDL *)((void *)0));
    } else {

    }
  }
}
}
#line 7323 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) 
{ int __BLAST_NONDET ;

  {
#line 7327
  if (__BLAST_NONDET == 0) {
    goto switch_192_0;
  } else {
    goto switch_192_default;
#line 7332
    if (0) {
      switch_192_0: ;
#line 7334
      return (TargetDevice);
      switch_192_default: ;
#line 7336
      return ((struct _DEVICE_OBJECT *)((void *)0));
    } else {

    }
  }
}
}
#line 7350 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 7357
  customIrp = 1;
#line 7358
  if (__BLAST_NONDET == 0) {
    goto switch_193_0;
  } else {
    goto switch_193_default;
#line 7363
    if (0) {
      switch_193_0: 
#line 7366
      tmp = & _SLAM_alloc_dummy;
#line 7368
      return ((struct _IRP *)((void *)tmp));
      switch_193_default: ;
#line 7370
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 7387 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 7395
  customIrp = 1;
#line 7396
  if (__BLAST_NONDET == 0) {
    goto switch_194_0;
  } else {
    goto switch_194_default;
#line 7401
    if (0) {
      switch_194_0: 
#line 7404
      tmp = & _SLAM_alloc_dummy;
#line 7406
      return ((struct _IRP *)((void *)tmp));
      switch_194_default: ;
#line 7408
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 7421 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 7428
  if (__BLAST_NONDET == 0) {
    goto switch_195_0;
  } else {
    goto switch_195_default;
#line 7433
    if (0) {
      switch_195_0: 
#line 7436
      tmp = & _SLAM_alloc_dummy;
#line 7437
      *DeviceObject = (struct _DEVICE_OBJECT *)((void *)tmp);
#line 7439
      return (0L);
      switch_195_default: ;
#line 7441
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7451 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) 
{ int __BLAST_NONDET ;

  {
#line 7455
  if (__BLAST_NONDET == 0) {
    goto switch_196_0;
  } else {
    goto switch_196_default;
#line 7460
    if (0) {
      switch_196_0: ;
#line 7462
      return (0L);
      switch_196_default: ;
#line 7464
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7473 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 7477
  return;
}
}
#line 7481 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 7485
  if (__BLAST_NONDET == 0) {
    goto switch_197_0;
  } else {
    goto switch_197_default;
#line 7490
    if (0) {
      switch_197_0: ;
#line 7492
      return (0L);
      switch_197_default: ;
#line 7494
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7503 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) 
{ 

  {
#line 7507
  return;
}
}
#line 7511 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoFreeIrp(PIRP Irp ) 
{ 

  {
#line 7515
  return;
}
}
#line 7519 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoFreeMdl(PMDL Mdl ) 
{ 

  {
#line 7523
  return;
}
}
#line 7527 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) 
{ char *tmp ;

  {
#line 7532
  tmp = & _SLAM_alloc_dummy;
#line 7534
  return ((struct _CONFIGURATION_INFORMATION *)((void *)tmp));
}
}
#line 7555 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) 
{ int __BLAST_NONDET ;

  {
#line 7572
  if (__BLAST_NONDET == 0) {
    goto switch_198_0;
  } else {
    goto switch_198_default;
#line 7577
    if (0) {
      switch_198_0: ;
#line 7579
      return (0L);
      switch_198_default: ;
#line 7581
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7593 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET ;

  {
#line 7600
  if (__BLAST_NONDET == 0) {
    goto switch_199_0;
  } else {
    goto switch_199_default;
#line 7605
    if (0) {
      switch_199_0: ;
#line 7607
      return (0L);
      switch_199_default: ;
#line 7609
      return (-1073741808L);
    } else {

    }
  }
}
}
#line 7618 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoReleaseCancelSpinLock(KIRQL Irql ) 
{ 

  {
#line 7622
  return;
}
}
#line 7627 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) 
{ int __BLAST_NONDET ;

  {
#line 7631
  if (__BLAST_NONDET == 0) {
    goto switch_200_0;
  } else {
    goto switch_200_default;
#line 7636
    if (0) {
      switch_200_0: ;
#line 7638
      return (0L);
      switch_200_default: ;
#line 7640
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7649 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 7653
  return;
}
}
#line 7656 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void stubMoreProcessingRequired(void) 
{ 

  {
#line 7660
  if (s == NP) {
#line 7661
    s = MPR1;
  } else {
    {
#line 7664
    errorFn();
    }
  }
#line 7667
  return;
}
}
#line 7672 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  NTSTATUS returnVal2 ;
  int compRetStatus1 ;
  PVOID lcontext ;
  NTSTATUS tmp ;

  {
#line 7681
  if (compRegistered) {
    {
#line 7683
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
#line 7684
    compRetStatus1 = (int )tmp;
    }
#line 7686
    if ((long )compRetStatus1 == -1073741802L) {
      {
#line 7688
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 7696
  if (__BLAST_NONDET == 0) {
    goto switch_201_0;
  } else {
#line 7699
    if (__BLAST_NONDET == 1) {
      goto switch_201_1;
    } else {
      goto switch_201_default;
#line 7704
      if (0) {
        switch_201_0: 
#line 7706
        returnVal2 = 0L;
        goto switch_201_break;
        switch_201_1: 
#line 7709
        returnVal2 = -1073741823L;
        goto switch_201_break;
        switch_201_default: 
#line 7712
        returnVal2 = 259L;
        goto switch_201_break;
      } else {
        switch_201_break: ;
      }
    }
  }
#line 7720
  if (s == NP) {
#line 7721
    s = IPC;
#line 7722
    lowerDriverReturn = (int )returnVal2;
  } else {
#line 7724
    if (s == MPR1) {
#line 7725
      if (returnVal2 == 259L) {
#line 7726
        s = MPR3;
#line 7727
        lowerDriverReturn = (int )returnVal2;
      } else {
#line 7729
        s = NP;
#line 7730
        lowerDriverReturn = (int )returnVal2;
      }
    } else {
#line 7733
      if (s == SKIP1) {
#line 7734
        s = SKIP2;
#line 7735
        lowerDriverReturn = (int )returnVal2;
      } else {
        {
#line 7738
        errorFn();
        }
      }
    }
  }
#line 7743
  return (returnVal2);
}
}
#line 7748 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
#line 7752
  if (s == NP) {
#line 7753
    s = DC;
  } else {
    {
#line 7756
    errorFn();
    }
  }
#line 7759
  return;
}
}
#line 7762
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) ;
#line 7763 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 7767
  return ((unsigned char)0);
}
}
#line 7773 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) 
{ int __BLAST_NONDET ;

  {
#line 7777
  if (__BLAST_NONDET == 0) {
    goto switch_202_0;
  } else {
    goto switch_202_default;
#line 7782
    if (0) {
      switch_202_0: ;
#line 7784
      return (0L);
      switch_202_default: ;
#line 7786
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7796 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) 
{ 

  {
#line 7800
  return;
}
}
#line 7805 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) 
{ 

  {
#line 7809
  return;
}
}
#line 7813 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 7817
  return;
}
}
#line 7822 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) 
{ LONG r ;

  {
#line 7827
  return (r);
}
}
#line 7832 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) 
{ 

  {
#line 7836
  return;
}
}
#line 7841 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) 
{ LONG l ;

  {
#line 7845
  setEventCalled = 1;
#line 7846
  return (l);
}
}
#line 7853 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) 
{ int __BLAST_NONDET ;

  {
#line 7858
  if (s == MPR3) {
#line 7859
    if (setEventCalled == 1) {
#line 7860
      s = NP;
#line 7861
      setEventCalled = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 7867
    if (customIrp == 1) {
#line 7868
      s = NP;
#line 7869
      customIrp = 0;
    } else {
#line 7871
      if (s == MPR3) {
        {
#line 7873
        errorFn();
        }
      } else {

      }
    }
  }
#line 7880
  if (__BLAST_NONDET == 0) {
    goto switch_203_0;
  } else {
    goto switch_203_default;
#line 7885
    if (0) {
      switch_203_0: ;
#line 7887
      return (0L);
      switch_203_default: ;
#line 7889
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7899 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) 
{ int __BLAST_NONDET ;
  char *tmp ;

  {
#line 7904
  if (__BLAST_NONDET == 0) {
    goto switch_204_0;
  } else {
#line 7907
    if (__BLAST_NONDET == 1) {
      goto switch_204_1;
    } else {
#line 7910
      if (0) {
        switch_204_0: 
#line 7913
        tmp = & _SLAM_alloc_dummy;
#line 7915
        return ((void *)tmp);
        switch_204_1: ;
#line 7917
        return ((void *)0);
      } else {

      }
    }
  }
#line 7923
  return ((void *)0);
}
}
#line 7927 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void MmFreeContiguousMemory(PVOID BaseAddress ) 
{ 

  {
#line 7931
  return;
}
}
#line 7940 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) 
{ 

  {
#line 7946
  return ((void *)0);
}
}
#line 7950 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) 
{ 

  {
#line 7954
  return ((void *)0);
}
}
#line 7958 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void MmResetDriverPaging(PVOID AddressWithinSection ) 
{ 

  {
#line 7962
  return;
}
}
#line 7966 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void MmUnlockPages(PMDL MemoryDescriptorList ) 
{ 

  {
#line 7970
  return;
}
}
#line 7979 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) 
{ int __BLAST_NONDET ;

  {
#line 7984
  if (__BLAST_NONDET == 0) {
    goto switch_205_0;
  } else {
    goto switch_205_default;
#line 7989
    if (0) {
      switch_205_0: ;
#line 7991
      return (0L);
      switch_205_default: ;
#line 7993
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8002 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void ObfDereferenceObject(PVOID Object ) 
{ 

  {
#line 8006
  return;
}
}
#line 8011 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext ;
  NTSTATUS tmp ;

  {
#line 8019
  if (compRegistered) {
    {
#line 8021
    tmp = FloppyPnpComplete(DeviceObject, Irp, lcontext);
#line 8022
    compRetStatus = (int )tmp;
    }
#line 8024
    if ((long )compRetStatus == -1073741802L) {
      {
#line 8026
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 8034
  if (__BLAST_NONDET == 0) {
    goto switch_206_0;
  } else {
#line 8037
    if (__BLAST_NONDET == 1) {
      goto switch_206_1;
    } else {
      goto switch_206_default;
#line 8042
      if (0) {
        switch_206_0: 
#line 8044
        returnVal = 0L;
        goto switch_206_break;
        switch_206_1: 
#line 8047
        returnVal = -1073741823L;
        goto switch_206_break;
        switch_206_default: 
#line 8050
        returnVal = 259L;
        goto switch_206_break;
      } else {
        switch_206_break: ;
      }
    }
  }
#line 8058
  if (s == NP) {
#line 8059
    s = IPC;
#line 8060
    lowerDriverReturn = (int )returnVal;
  } else {
#line 8062
    if (s == MPR1) {
#line 8063
      if (returnVal == 259L) {
#line 8064
        s = MPR3;
#line 8065
        lowerDriverReturn = (int )returnVal;
      } else {
#line 8067
        s = NP;
#line 8068
        lowerDriverReturn = (int )returnVal;
      }
    } else {
#line 8071
      if (s == SKIP1) {
#line 8072
        s = SKIP2;
#line 8073
        lowerDriverReturn = (int )returnVal;
      } else {
        {
#line 8076
        errorFn();
        }
      }
    }
  }
#line 8081
  return (returnVal);
}
}
#line 8085 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void PoStartNextPowerIrp(PIRP Irp ) 
{ 

  {
#line 8089
  return;
}
}
#line 8099 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) 
{ int __BLAST_NONDET ;

  {
#line 8105
  if (__BLAST_NONDET == 0) {
    goto switch_207_0;
  } else {
    goto switch_207_default;
#line 8110
    if (0) {
      switch_207_0: ;
#line 8112
      return (0L);
      switch_207_default: ;
#line 8114
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8123 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) 
{ int __BLAST_NONDET ;

  {
#line 8127
  if (__BLAST_NONDET == 0) {
    goto switch_208_0;
  } else {
    goto switch_208_default;
#line 8132
    if (0) {
      switch_208_0: ;
#line 8134
      return (0L);
      switch_208_default: ;
#line 8136
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8147 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) 
{ int __BLAST_NONDET ;

  {
#line 8153
  if (__BLAST_NONDET == 0) {
    goto switch_209_0;
  } else {
    goto switch_209_default;
#line 8158
    if (0) {
      switch_209_0: ;
#line 8160
      return (0L);
      switch_209_default: ;
#line 8162
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8173 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) 
{ SIZE_T r ;

  {
#line 8178
  return (r);
}
}
#line 8183 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) 
{ 

  {
#line 8188
  return;
}
}
#line 8194 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) 
{ int __BLAST_NONDET ;

  {
#line 8199
  if (__BLAST_NONDET == 0) {
    goto switch_210_0;
  } else {
    goto switch_210_default;
#line 8204
    if (0) {
      switch_210_0: ;
#line 8206
      return (0L);
      switch_210_default: ;
#line 8208
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8217 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) 
{ 

  {
#line 8221
  return;
}
}
#line 8226 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) 
{ 

  {
#line 8230
  return;
}
}
#line 8235 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) 
{ 

  {
#line 8240
  return;
}
}
#line 8248 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) 
{ int __BLAST_NONDET ;

  {
#line 8254
  if (__BLAST_NONDET == 0) {
    goto switch_211_0;
  } else {
    goto switch_211_default;
#line 8259
    if (0) {
      switch_211_0: ;
#line 8261
      return (0L);
      switch_211_default: ;
#line 8263
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8272 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/floppy/floppy.i.cil.c"
NTSTATUS ZwClose(HANDLE Handle ) 
{ int __BLAST_NONDET ;

  {
#line 8276
  if (__BLAST_NONDET == 0) {
    goto switch_212_0;
  } else {
    goto switch_212_default;
#line 8281
    if (0) {
      switch_212_0: ;
#line 8283
      return (0L);
      switch_212_default: ;
#line 8285
      return (-1073741823L);
    } else {

    }
  }
}
}
