/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 4 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
#pragma pack(push,8)
#line 5
#pragma pack(pop)
#line 6 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned short wchar_t;
#line 7 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned long ULONG_PTR;
#line 8 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned long *PULONG_PTR;
#line 9 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG_PTR SIZE_T;
#line 10 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef void *PVOID;
#line 11 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef char CHAR;
#line 12 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef short SHORT;
#line 13 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef long LONG;
#line 14 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef wchar_t WCHAR;
#line 15 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef WCHAR *PWSTR;
#line 16 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef WCHAR const   *PCWSTR;
#line 17 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef CHAR *PCHAR;
#line 18 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef LONG *PLONG;
#line 19 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned char UCHAR;
#line 20 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned short USHORT;
#line 21 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned long ULONG;
#line 22 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef UCHAR *PUCHAR;
#line 23 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG *PULONG;
#line 24 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef void *HANDLE;
#line 25 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef HANDLE *PHANDLE;
#line 26 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef char CCHAR;
#line 27 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef short CSHORT;
#line 28 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG LCID;
#line 29 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef LONG NTSTATUS;
#line 30 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef long long LONGLONG;
#line 31 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned long long ULONGLONG;
#line 32 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct____missing_field_name_1 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 36 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_u_2 {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 40 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _LARGE_INTEGER {
   struct __anonstruct____missing_field_name_1 __annonCompField1 ;
   struct __anonstruct_u_2 u ;
   LONGLONG QuadPart ;
};
#line 45 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _LARGE_INTEGER LARGE_INTEGER;
#line 46 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef LARGE_INTEGER *PLARGE_INTEGER;
#line 47 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct____missing_field_name_3 {
   ULONG LowPart ;
   ULONG HighPart ;
};
#line 51 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_u_4 {
   ULONG LowPart ;
   ULONG HighPart ;
};
#line 55 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _ULARGE_INTEGER {
   struct __anonstruct____missing_field_name_3 __annonCompField2 ;
   struct __anonstruct_u_4 u ;
   ULONGLONG QuadPart ;
};
#line 60 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _ULARGE_INTEGER ULARGE_INTEGER;
#line 61 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LUID {
   ULONG LowPart ;
   LONG HighPart ;
};
#line 65 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _LUID LUID;
#line 66 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef LARGE_INTEGER PHYSICAL_ADDRESS;
#line 67
enum _EVENT_TYPE {
    NotificationEvent = 0,
    SynchronizationEvent = 1
} ;
#line 71 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _EVENT_TYPE EVENT_TYPE;
#line 72 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef char const   *PCSZ;
#line 73 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PCHAR Buffer ;
};
#line 78 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _STRING STRING;
#line 79 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef STRING *PSTRING;
#line 80 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef PSTRING PANSI_STRING;
#line 81 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _UNICODE_STRING {
   USHORT Length ;
   USHORT MaximumLength ;
   PWSTR Buffer ;
};
#line 86 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _UNICODE_STRING UNICODE_STRING;
#line 87 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef UNICODE_STRING *PUNICODE_STRING;
#line 88 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef UCHAR BOOLEAN;
#line 89 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink ;
   struct _LIST_ENTRY *Blink ;
};
#line 93 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _LIST_ENTRY LIST_ENTRY;
#line 94 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _LIST_ENTRY *PLIST_ENTRY;
#line 95 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _OBJECT_ATTRIBUTES {
   ULONG Length ;
   HANDLE RootDirectory ;
   PUNICODE_STRING ObjectName ;
   ULONG Attributes ;
   PVOID SecurityDescriptor ;
   PVOID SecurityQualityOfService ;
};
#line 103 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES;
#line 104 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#line 105 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _GUID {
   unsigned long Data1 ;
   unsigned short Data2 ;
   unsigned short Data3 ;
   unsigned char Data4[8] ;
};
#line 111 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _GUID GUID;
#line 112 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef unsigned int size_t;
#line 113 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef UCHAR KIRQL;
#line 114
struct _KTHREAD;
#line 114
struct _KTHREAD;
#line 115 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KTHREAD *PKTHREAD;
#line 116
struct _ETHREAD;
#line 116
struct _ETHREAD;
#line 117 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _ETHREAD *PETHREAD;
#line 118
struct _EPROCESS;
#line 118
struct _EPROCESS;
#line 119 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _EPROCESS *PEPROCESS;
#line 120
struct _IO_TIMER;
#line 120
struct _IO_TIMER;
#line 121 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_TIMER *PIO_TIMER;
#line 122
struct _OBJECT_TYPE;
#line 122
struct _OBJECT_TYPE;
#line 123 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
#line 124 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef CCHAR KPROCESSOR_MODE;
#line 125
struct _KAPC;
#line 125
struct _KAPC;
#line 126
struct _KAPC;
#line 127 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef void (*PKNORMAL_ROUTINE)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 );
#line 128 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KAPC {
   CSHORT Type ;
   CSHORT Size ;
   ULONG Spare0 ;
   struct _KTHREAD *Thread ;
   LIST_ENTRY ApcListEntry ;
   void (*KernelRoutine)(struct _KAPC *Apc , PKNORMAL_ROUTINE *NormalRoutine , PVOID *NormalContext ,
                         PVOID *SystemArgument1 , PVOID *SystemArgument2 ) ;
   void (*RundownRoutine)(struct _KAPC *Apc ) ;
   void (*NormalRoutine)(PVOID NormalContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;
   PVOID NormalContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   CCHAR ApcStateIndex ;
   KPROCESSOR_MODE ApcMode ;
   BOOLEAN Inserted ;
};
#line 145 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KAPC KAPC;
#line 146
struct _KDPC;
#line 146
struct _KDPC;
#line 147
struct _KDPC;
#line 148 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KDPC {
   CSHORT Type ;
   UCHAR Number ;
   UCHAR Importance ;
   LIST_ENTRY DpcListEntry ;
   void (*DeferredRoutine)(struct _KDPC *Dpc , PVOID DeferredContext , PVOID SystemArgument1 ,
                           PVOID SystemArgument2 ) ;
   PVOID DeferredContext ;
   PVOID SystemArgument1 ;
   PVOID SystemArgument2 ;
   PULONG_PTR Lock ;
};
#line 160 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KDPC KDPC;
#line 161 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KDPC *PKDPC;
#line 162 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KDPC *PRKDPC;
#line 163 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MDL {
   struct _MDL *Next ;
   CSHORT Size ;
   CSHORT MdlFlags ;
   struct _EPROCESS *Process ;
   PVOID MappedSystemVa ;
   PVOID StartVa ;
   ULONG ByteCount ;
   ULONG ByteOffset ;
};
#line 173 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _MDL MDL;
#line 174 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _MDL *PMDL;
#line 175 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef PVOID PACCESS_TOKEN;
#line 176 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef PVOID PSECURITY_DESCRIPTOR;
#line 177 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG ACCESS_MASK;
#line 178
#pragma pack(push,4)
#line 179 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LUID_AND_ATTRIBUTES {
   LUID Luid ;
   ULONG Attributes ;
};
#line 183 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;
#line 184
#pragma pack(pop)
#line 185 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[1] ;
};
#line 190 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _PRIVILEGE_SET PRIVILEGE_SET;
#line 191
enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous = 0,
    SecurityIdentification = 1,
    SecurityImpersonation = 2,
    SecurityDelegation = 3
} ;
#line 197 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _SECURITY_IMPERSONATION_LEVEL SECURITY_IMPERSONATION_LEVEL;
#line 198 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
#line 199 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SECURITY_QUALITY_OF_SERVICE {
   ULONG Length ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
   BOOLEAN EffectiveOnly ;
};
#line 205 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;
#line 206 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG SECURITY_INFORMATION;
#line 207 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef LONG KPRIORITY;
#line 208 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG_PTR KSPIN_LOCK;
#line 209 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef KSPIN_LOCK *PKSPIN_LOCK;
#line 210 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _RTL_QUERY_REGISTRY_TABLE {
   NTSTATUS (*QueryRoutine)(PWSTR ValueName , ULONG ValueType , PVOID ValueData ,
                            ULONG ValueLength , PVOID Context , PVOID EntryContext ) ;
   ULONG Flags ;
   PWSTR Name ;
   PVOID EntryContext ;
   ULONG DefaultType ;
   PVOID DefaultData ;
   ULONG DefaultLength ;
};
#line 221 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE RTL_QUERY_REGISTRY_TABLE;
#line 222 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _RTL_QUERY_REGISTRY_TABLE *PRTL_QUERY_REGISTRY_TABLE;
#line 223 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_6 {
   NTSTATUS Status ;
   PVOID Pointer ;
};
#line 227 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_STATUS_BLOCK {
   union __anonunion____missing_field_name_6 __annonCompField4 ;
   ULONG_PTR Information ;
};
#line 231 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_STATUS_BLOCK IO_STATUS_BLOCK;
#line 232 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_STATUS_BLOCK *PIO_STATUS_BLOCK;
#line 233
enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation = 2,
    FileBothDirectoryInformation = 3,
    FileBasicInformation = 4,
    FileStandardInformation = 5,
    FileInternalInformation = 6,
    FileEaInformation = 7,
    FileAccessInformation = 8,
    FileNameInformation = 9,
    FileRenameInformation = 10,
    FileLinkInformation = 11,
    FileNamesInformation = 12,
    FileDispositionInformation = 13,
    FilePositionInformation = 14,
    FileFullEaInformation = 15,
    FileModeInformation = 16,
    FileAlignmentInformation = 17,
    FileAllInformation = 18,
    FileAllocationInformation = 19,
    FileEndOfFileInformation = 20,
    FileAlternateNameInformation = 21,
    FileStreamInformation = 22,
    FilePipeInformation = 23,
    FilePipeLocalInformation = 24,
    FilePipeRemoteInformation = 25,
    FileMailslotQueryInformation = 26,
    FileMailslotSetInformation = 27,
    FileCompressionInformation = 28,
    FileObjectIdInformation = 29,
    FileCompletionInformation = 30,
    FileMoveClusterInformation = 31,
    FileQuotaInformation = 32,
    FileReparsePointInformation = 33,
    FileNetworkOpenInformation = 34,
    FileAttributeTagInformation = 35,
    FileTrackingInformation = 36,
    FileMaximumInformation = 37
} ;
#line 272 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _FILE_INFORMATION_CLASS FILE_INFORMATION_CLASS;
#line 273 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   ULONG FileAttributes ;
};
#line 280 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FILE_BASIC_INFORMATION *PFILE_BASIC_INFORMATION;
#line 281 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FILE_STANDARD_INFORMATION {
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG NumberOfLinks ;
   BOOLEAN DeletePending ;
   BOOLEAN Directory ;
};
#line 288 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FILE_STANDARD_INFORMATION *PFILE_STANDARD_INFORMATION;
#line 289 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime ;
   LARGE_INTEGER LastAccessTime ;
   LARGE_INTEGER LastWriteTime ;
   LARGE_INTEGER ChangeTime ;
   LARGE_INTEGER AllocationSize ;
   LARGE_INTEGER EndOfFile ;
   ULONG FileAttributes ;
};
#line 298 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FILE_NETWORK_OPEN_INFORMATION *PFILE_NETWORK_OPEN_INFORMATION;
#line 299
enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation = 2,
    FileFsSizeInformation = 3,
    FileFsDeviceInformation = 4,
    FileFsAttributeInformation = 5,
    FileFsControlInformation = 6,
    FileFsFullSizeInformation = 7,
    FileFsObjectIdInformation = 8,
    FileFsMaximumInformation = 9
} ;
#line 310 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _FSINFOCLASS FS_INFORMATION_CLASS;
#line 311
enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal = 0,
    Isa = 1,
    Eisa = 2,
    MicroChannel = 3,
    TurboChannel = 4,
    PCIBus = 5,
    VMEBus = 6,
    NuBus = 7,
    PCMCIABus = 8,
    CBus = 9,
    MPIBus = 10,
    MPSABus = 11,
    ProcessorInternal = 12,
    InternalPowerBus = 13,
    PNPISABus = 14,
    PNPBus = 15,
    MaximumInterfaceType = 16
} ;
#line 331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _INTERFACE_TYPE INTERFACE_TYPE;
#line 332 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _INTERFACE_TYPE *PINTERFACE_TYPE;
#line 333 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KEY_VALUE_FULL_INFORMATION {
   ULONG TitleIndex ;
   ULONG Type ;
   ULONG DataOffset ;
   ULONG DataLength ;
   ULONG NameLength ;
   WCHAR Name[1] ;
};
#line 341 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KEY_VALUE_FULL_INFORMATION *PKEY_VALUE_FULL_INFORMATION;
#line 342 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CLIENT_ID {
   HANDLE UniqueProcess ;
   HANDLE UniqueThread ;
};
#line 346 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CLIENT_ID CLIENT_ID;
#line 347 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef CLIENT_ID *PCLIENT_ID;
#line 348
enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} ;
#line 358 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _SYSTEM_POWER_STATE SYSTEM_POWER_STATE;
#line 359
enum __anonenum_POWER_ACTION_11 {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7
} ;
#line 369 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum __anonenum_POWER_ACTION_11 POWER_ACTION;
#line 370
enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5
} ;
#line 378 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _DEVICE_POWER_STATE DEVICE_POWER_STATE;
#line 379 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _POWER_STATE {
   SYSTEM_POWER_STATE SystemState ;
   DEVICE_POWER_STATE DeviceState ;
};
#line 383 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _POWER_STATE POWER_STATE;
#line 384
enum _POWER_STATE_TYPE {
    SystemPowerState = 0,
    DevicePowerState = 1
} ;
#line 388 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _POWER_STATE_TYPE POWER_STATE_TYPE;
#line 389 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef PVOID PASSIGNED_RESOURCE;
#line 390
#pragma pack(push,4)
#line 391 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Generic_16 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 395 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Port_17 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 399 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Interrupt_18 {
   ULONG Level ;
   ULONG Vector ;
   ULONG Affinity ;
};
#line 404 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Memory_19 {
   PHYSICAL_ADDRESS Start ;
   ULONG Length ;
};
#line 408 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Dma_20 {
   ULONG Channel ;
   ULONG Port ;
   ULONG Reserved1 ;
};
#line 413 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_DevicePrivate_21 {
   ULONG Data[3] ;
};
#line 416 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_BusNumber_22 {
   ULONG Start ;
   ULONG Length ;
   ULONG Reserved ;
};
#line 421 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_DeviceSpecificData_23 {
   ULONG DataSize ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 426 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_u_15 {
   struct __anonstruct_Generic_16 Generic ;
   struct __anonstruct_Port_17 Port ;
   struct __anonstruct_Interrupt_18 Interrupt ;
   struct __anonstruct_Memory_19 Memory ;
   struct __anonstruct_Dma_20 Dma ;
   struct __anonstruct_DevicePrivate_21 DevicePrivate ;
   struct __anonstruct_BusNumber_22 BusNumber ;
   struct __anonstruct_DeviceSpecificData_23 DeviceSpecificData ;
};
#line 436 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
   UCHAR Type ;
   UCHAR ShareDisposition ;
   USHORT Flags ;
   union __anonunion_u_15 u ;
};
#line 442 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR CM_PARTIAL_RESOURCE_DESCRIPTOR;
#line 443
#pragma pack(pop)
#line 444 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CM_PARTIAL_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
};
#line 450 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CM_PARTIAL_RESOURCE_LIST CM_PARTIAL_RESOURCE_LIST;
#line 451 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CM_FULL_RESOURCE_DESCRIPTOR {
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
};
#line 456 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR CM_FULL_RESOURCE_DESCRIPTOR;
#line 457 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CM_RESOURCE_LIST {
   ULONG Count ;
   CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
};
#line 461 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CM_RESOURCE_LIST *PCM_RESOURCE_LIST;
#line 462
#pragma pack(push,1)
#line 463
#pragma pack(pop)
#line 464 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Port_25 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 470 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Memory_26 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 476 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Interrupt_27 {
   ULONG MinimumVector ;
   ULONG MaximumVector ;
};
#line 480 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Dma_28 {
   ULONG MinimumChannel ;
   ULONG MaximumChannel ;
};
#line 484 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Generic_29 {
   ULONG Length ;
   ULONG Alignment ;
   PHYSICAL_ADDRESS MinimumAddress ;
   PHYSICAL_ADDRESS MaximumAddress ;
};
#line 490 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_DevicePrivate_30 {
   ULONG Data[3] ;
};
#line 493 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_BusNumber_31 {
   ULONG Length ;
   ULONG MinBusNumber ;
   ULONG MaxBusNumber ;
   ULONG Reserved ;
};
#line 499 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_AssignedResource_32 {
   PASSIGNED_RESOURCE AssignedResource ;
};
#line 502 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_SubAllocateFrom_33 {
   UCHAR Type ;
   UCHAR Reserved[3] ;
   PASSIGNED_RESOURCE AssignedResource ;
   PHYSICAL_ADDRESS Transformation ;
};
#line 508 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_ConfigData_34 {
   ULONG Priority ;
   ULONG Reserved1 ;
   ULONG Reserved2 ;
};
#line 513 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_u_24 {
   struct __anonstruct_Port_25 Port ;
   struct __anonstruct_Memory_26 Memory ;
   struct __anonstruct_Interrupt_27 Interrupt ;
   struct __anonstruct_Dma_28 Dma ;
   struct __anonstruct_Generic_29 Generic ;
   struct __anonstruct_DevicePrivate_30 DevicePrivate ;
   struct __anonstruct_BusNumber_31 BusNumber ;
   struct __anonstruct_AssignedResource_32 AssignedResource ;
   struct __anonstruct_SubAllocateFrom_33 SubAllocateFrom ;
   struct __anonstruct_ConfigData_34 ConfigData ;
};
#line 525 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_RESOURCE_DESCRIPTOR {
   UCHAR Option ;
   UCHAR Type ;
   UCHAR ShareDisposition ;
   UCHAR Spare1 ;
   USHORT Flags ;
   USHORT Spare2 ;
   union __anonunion_u_24 u ;
};
#line 534 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_RESOURCE_DESCRIPTOR IO_RESOURCE_DESCRIPTOR;
#line 535 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_RESOURCE_LIST {
   USHORT Version ;
   USHORT Revision ;
   ULONG Count ;
   IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
};
#line 541 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_RESOURCE_LIST IO_RESOURCE_LIST;
#line 542 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_RESOURCE_REQUIREMENTS_LIST {
   ULONG ListSize ;
   INTERFACE_TYPE InterfaceType ;
   ULONG BusNumber ;
   ULONG SlotNumber ;
   ULONG Reserved[3] ;
   ULONG AlternativeLists ;
   IO_RESOURCE_LIST List[1] ;
};
#line 551 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST *PIO_RESOURCE_REQUIREMENTS_LIST;
#line 552
enum _CONFIGURATION_TYPE {
    ArcSystem = 0,
    CentralProcessor = 1,
    FloatingPointProcessor = 2,
    PrimaryIcache = 3,
    PrimaryDcache = 4,
    SecondaryIcache = 5,
    SecondaryDcache = 6,
    SecondaryCache = 7,
    EisaAdapter = 8,
    TcAdapter = 9,
    ScsiAdapter = 10,
    DtiAdapter = 11,
    MultiFunctionAdapter = 12,
    DiskController = 13,
    TapeController = 14,
    CdromController = 15,
    WormController = 16,
    SerialController = 17,
    NetworkController = 18,
    DisplayController = 19,
    ParallelController = 20,
    PointerController = 21,
    KeyboardController = 22,
    AudioController = 23,
    OtherController = 24,
    DiskPeripheral = 25,
    FloppyDiskPeripheral = 26,
    TapePeripheral = 27,
    ModemPeripheral = 28,
    MonitorPeripheral = 29,
    PrinterPeripheral = 30,
    PointerPeripheral = 31,
    KeyboardPeripheral = 32,
    TerminalPeripheral = 33,
    OtherPeripheral = 34,
    LinePeripheral = 35,
    NetworkPeripheral = 36,
    SystemMemory = 37,
    DockingInformation = 38,
    RealModeIrqRoutingTable = 39,
    MaximumType = 40
} ;
#line 595 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _CONFIGURATION_TYPE CONFIGURATION_TYPE;
#line 596 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _CONFIGURATION_TYPE *PCONFIGURATION_TYPE;
#line 597
enum _KWAIT_REASON {
    Executive = 0,
    FreePage = 1,
    PageIn = 2,
    PoolAllocation = 3,
    DelayExecution = 4,
    Suspended = 5,
    UserRequest = 6,
    WrExecutive = 7,
    WrFreePage = 8,
    WrPageIn = 9,
    WrPoolAllocation = 10,
    WrDelayExecution = 11,
    WrSuspended = 12,
    WrUserRequest = 13,
    WrEventPair = 14,
    WrQueue = 15,
    WrLpcReceive = 16,
    WrLpcReply = 17,
    WrVirtualMemory = 18,
    WrPageOut = 19,
    WrRendezvous = 20,
    Spare2 = 21,
    Spare3 = 22,
    Spare4 = 23,
    Spare5 = 24,
    Spare6 = 25,
    WrKernel = 26,
    MaximumWaitReason = 27
} ;
#line 627 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _KWAIT_REASON KWAIT_REASON;
#line 628 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DISPATCHER_HEADER {
   UCHAR Type ;
   UCHAR Absolute ;
   UCHAR Size ;
   UCHAR Inserted ;
   LONG SignalState ;
   LIST_ENTRY WaitListHead ;
};
#line 636 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DISPATCHER_HEADER DISPATCHER_HEADER;
#line 637 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KDEVICE_QUEUE {
   CSHORT Type ;
   CSHORT Size ;
   LIST_ENTRY DeviceListHead ;
   KSPIN_LOCK Lock ;
   BOOLEAN Busy ;
};
#line 644 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KDEVICE_QUEUE KDEVICE_QUEUE;
#line 645 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KDEVICE_QUEUE_ENTRY {
   LIST_ENTRY DeviceListEntry ;
   ULONG SortKey ;
   BOOLEAN Inserted ;
};
#line 650 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KDEVICE_QUEUE_ENTRY KDEVICE_QUEUE_ENTRY;
#line 651 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KEVENT {
   DISPATCHER_HEADER Header ;
};
#line 654 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KEVENT KEVENT;
#line 655 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KEVENT *PKEVENT;
#line 656 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KEVENT *PRKEVENT;
#line 657 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KSEMAPHORE {
   DISPATCHER_HEADER Header ;
   LONG Limit ;
};
#line 661 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KSEMAPHORE *PKSEMAPHORE;
#line 662 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KSEMAPHORE *PRKSEMAPHORE;
#line 663 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _KTIMER {
   DISPATCHER_HEADER Header ;
   ULARGE_INTEGER DueTime ;
   LIST_ENTRY TimerListEntry ;
   struct _KDPC *Dpc ;
   LONG Period ;
};
#line 670 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _KTIMER *PKTIMER;
#line 671
enum _MEMORY_CACHING_TYPE {
    MmNonCached = 0,
    MmCached = 1,
    MmWriteCombined = 2,
    MmHardwareCoherentCached = 3,
    MmNonCachedUnordered = 4,
    MmUSWCCached = 5,
    MmMaximumCacheType = 6
} ;
#line 680 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _MEMORY_CACHING_TYPE MEMORY_CACHING_TYPE;
#line 681
enum _POOL_TYPE {
    NonPagedPool = 0,
    PagedPool = 1,
    NonPagedPoolMustSucceed = 2,
    DontUseThisType = 3,
    NonPagedPoolCacheAligned = 4,
    PagedPoolCacheAligned = 5,
    NonPagedPoolCacheAlignedMustS = 6,
    MaxPoolType = 7,
    NonPagedPoolSession = 32,
    PagedPoolSession = 33,
    NonPagedPoolMustSucceedSession = 34,
    DontUseThisTypeSession = 35,
    NonPagedPoolCacheAlignedSession = 36,
    PagedPoolCacheAlignedSession = 37,
    NonPagedPoolCacheAlignedMustSSession = 38
} ;
#line 698 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _POOL_TYPE POOL_TYPE;
#line 699 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FAST_MUTEX {
   LONG Count ;
   PKTHREAD Owner ;
   ULONG Contention ;
   KEVENT Event ;
   ULONG OldIrql ;
};
#line 706 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FAST_MUTEX *PFAST_MUTEX;
#line 707 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef ULONG_PTR ERESOURCE_THREAD;
#line 708 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_38 {
   LONG OwnerCount ;
   ULONG TableSize ;
};
#line 712 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _OWNER_ENTRY {
   ERESOURCE_THREAD OwnerThread ;
   union __anonunion____missing_field_name_38 __annonCompField10 ;
};
#line 716 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _OWNER_ENTRY OWNER_ENTRY;
#line 717 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _OWNER_ENTRY *POWNER_ENTRY;
#line 718 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_39 {
   PVOID Address ;
   ULONG_PTR CreatorBackTraceIndex ;
};
#line 722 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _ERESOURCE {
   LIST_ENTRY SystemResourcesList ;
   POWNER_ENTRY OwnerTable ;
   SHORT ActiveCount ;
   USHORT Flag ;
   PKSEMAPHORE SharedWaiters ;
   PKEVENT ExclusiveWaiters ;
   OWNER_ENTRY OwnerThreads[2] ;
   ULONG ContentionCount ;
   USHORT NumberOfSharedWaiters ;
   USHORT NumberOfExclusiveWaiters ;
   union __anonunion____missing_field_name_39 __annonCompField11 ;
   KSPIN_LOCK SpinLock ;
};
#line 736
enum _MM_PAGE_PRIORITY {
    LowPagePriority = 0,
    NormalPagePriority = 16,
    HighPagePriority = 32
} ;
#line 741 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _MM_PAGE_PRIORITY MM_PAGE_PRIORITY;
#line 742
struct _DRIVER_OBJECT;
#line 742
struct _DRIVER_OBJECT;
#line 743
struct _DRIVER_OBJECT;
#line 744 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SECURITY_SUBJECT_CONTEXT {
   PACCESS_TOKEN ClientToken ;
   SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
   PACCESS_TOKEN PrimaryToken ;
   PVOID ProcessAuditId ;
};
#line 750 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SECURITY_SUBJECT_CONTEXT SECURITY_SUBJECT_CONTEXT;
#line 751 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _INITIAL_PRIVILEGE_SET {
   ULONG PrivilegeCount ;
   ULONG Control ;
   LUID_AND_ATTRIBUTES Privilege[3] ;
};
#line 756 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _INITIAL_PRIVILEGE_SET INITIAL_PRIVILEGE_SET;
#line 757 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Privileges_40 {
   INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
   PRIVILEGE_SET PrivilegeSet ;
};
#line 761 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _ACCESS_STATE {
   LUID OperationID ;
   BOOLEAN SecurityEvaluated ;
   BOOLEAN GenerateAudit ;
   BOOLEAN GenerateOnClose ;
   BOOLEAN PrivilegesAllocated ;
   ULONG Flags ;
   ACCESS_MASK RemainingDesiredAccess ;
   ACCESS_MASK PreviouslyGrantedAccess ;
   ACCESS_MASK OriginalDesiredAccess ;
   SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   PVOID AuxData ;
   union __anonunion_Privileges_40 Privileges ;
   BOOLEAN AuditPrivileges ;
   UNICODE_STRING ObjectName ;
   UNICODE_STRING ObjectTypeName ;
};
#line 779 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _ACCESS_STATE *PACCESS_STATE;
#line 780
struct _DEVICE_OBJECT;
#line 780
struct _DEVICE_OBJECT;
#line 781
struct _DEVICE_OBJECT;
#line 782
struct _DRIVER_OBJECT;
#line 783
struct _FILE_OBJECT;
#line 783
struct _FILE_OBJECT;
#line 784
struct _FILE_OBJECT;
#line 785
struct _IRP;
#line 785
struct _IRP;
#line 786
struct _IRP;
#line 787
struct _SCSI_REQUEST_BLOCK;
#line 787
struct _SCSI_REQUEST_BLOCK;
#line 788
struct _SCSI_REQUEST_BLOCK;
#line 789 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef NTSTATUS (*PDRIVER_DISPATCH)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp );
#line 790
struct _COMPRESSED_DATA_INFO;
#line 790
struct _COMPRESSED_DATA_INFO;
#line 791 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FAST_IO_DISPATCH {
   ULONG SizeOfFastIoDispatch ;
   BOOLEAN (*FastIoCheckIfPossible)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , BOOLEAN Wait , ULONG LockKey ,
                                    BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK IoStatus ,
                                    struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                         PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                          ULONG Length , BOOLEAN Wait , ULONG LockKey , PVOID Buffer ,
                          PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryBasicInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                   PFILE_BASIC_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                   struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryStandardInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                      PFILE_STANDARD_INFORMATION Buffer , PIO_STATUS_BLOCK IoStatus ,
                                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoLock)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                         PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                         BOOLEAN FailImmediately , BOOLEAN ExclusiveLock , PIO_STATUS_BLOCK IoStatus ,
                         struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockSingle)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                 PLARGE_INTEGER Length , PEPROCESS ProcessId , ULONG Key ,
                                 PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAll)(struct _FILE_OBJECT *FileObject , PEPROCESS ProcessId ,
                              PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoUnlockAllByKey)(struct _FILE_OBJECT *FileObject , PVOID ProcessId ,
                                   ULONG Key , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoDeviceControl)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                  PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                  ULONG OutputBufferLength , ULONG IoControlCode ,
                                  PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   void (*AcquireFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*ReleaseFileForNtCreateSection)(struct _FILE_OBJECT *FileObject ) ;
   void (*FastIoDetachDevice)(struct _DEVICE_OBJECT *SourceDevice , struct _DEVICE_OBJECT *TargetDevice ) ;
   BOOLEAN (*FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT *FileObject , BOOLEAN Wait ,
                                         struct _FILE_NETWORK_OPEN_INFORMATION *Buffer ,
                                         struct _IO_STATUS_BLOCK *IoStatus , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForModWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER EndingOffset ,
                                  struct _ERESOURCE **ResourceToRelease , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlRead)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                      ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                      struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadComplete)(struct _FILE_OBJECT *FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*PrepareMdlWrite)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                              ULONG Length , ULONG LockKey , PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteComplete)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                               PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoReadCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                   ULONG Length , ULONG LockKey , PVOID Buffer , PMDL *MdlChain ,
                                   PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                   ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoWriteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                    ULONG Length , ULONG LockKey , PVOID Buffer ,
                                    PMDL *MdlChain , PIO_STATUS_BLOCK IoStatus , struct _COMPRESSED_DATA_INFO *CompressedDataInfo ,
                                    ULONG CompressedDataInfoLength , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlReadCompleteCompressed)(struct _FILE_OBJECT *FileObject , PMDL MdlChain ,
                                        struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*MdlWriteCompleteCompressed)(struct _FILE_OBJECT *FileObject , PLARGE_INTEGER FileOffset ,
                                         PMDL MdlChain , struct _DEVICE_OBJECT *DeviceObject ) ;
   BOOLEAN (*FastIoQueryOpen)(struct _IRP *Irp , PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
                              struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForModWrite)(struct _FILE_OBJECT *FileObject , struct _ERESOURCE *ResourceToRelease ,
                                  struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*AcquireForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
   NTSTATUS (*ReleaseForCcFlush)(struct _FILE_OBJECT *FileObject , struct _DEVICE_OBJECT *DeviceObject ) ;
};
#line 860 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FAST_IO_DISPATCH *PFAST_IO_DISPATCH;
#line 861
enum _IO_ALLOCATION_ACTION {
    KeepObject = 1,
    DeallocateObject = 2,
    DeallocateObjectKeepRegisters = 3
} ;
#line 866 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _IO_ALLOCATION_ACTION IO_ALLOCATION_ACTION;
#line 867 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_SECURITY_CONTEXT {
   PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
   PACCESS_STATE AccessState ;
   ACCESS_MASK DesiredAccess ;
   ULONG FullCreateOptions ;
};
#line 873 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_SECURITY_CONTEXT *PIO_SECURITY_CONTEXT;
#line 874 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _VPB {
   CSHORT Type ;
   CSHORT Size ;
   USHORT Flags ;
   USHORT VolumeLabelLength ;
   struct _DEVICE_OBJECT *DeviceObject ;
   struct _DEVICE_OBJECT *RealDevice ;
   ULONG SerialNumber ;
   ULONG ReferenceCount ;
   WCHAR VolumeLabel[(32U * sizeof(WCHAR )) / sizeof(WCHAR )] ;
};
#line 885 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _VPB *PVPB;
#line 886 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _WAIT_CONTEXT_BLOCK {
   KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
   IO_ALLOCATION_ACTION (*DeviceRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ,
                                         PVOID MapRegisterBase , PVOID Context ) ;
   PVOID DeviceContext ;
   ULONG NumberOfMapRegisters ;
   PVOID DeviceObject ;
   PVOID CurrentIrp ;
   PKDPC BufferChainingDpc ;
};
#line 896 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _WAIT_CONTEXT_BLOCK WAIT_CONTEXT_BLOCK;
#line 897 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Queue_43 {
   LIST_ENTRY ListEntry ;
   WAIT_CONTEXT_BLOCK Wcb ;
};
#line 901
struct _DEVOBJ_EXTENSION;
#line 901
struct _DEVOBJ_EXTENSION;
#line 902 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DEVICE_OBJECT {
   CSHORT Type ;
   USHORT Size ;
   LONG ReferenceCount ;
   struct _DRIVER_OBJECT *DriverObject ;
   struct _DEVICE_OBJECT *NextDevice ;
   struct _DEVICE_OBJECT *AttachedDevice ;
   struct _IRP *CurrentIrp ;
   PIO_TIMER Timer ;
   ULONG Flags ;
   ULONG Characteristics ;
   PVPB Vpb ;
   PVOID DeviceExtension ;
   ULONG DeviceType ;
   CCHAR StackSize ;
   union __anonunion_Queue_43 Queue ;
   ULONG AlignmentRequirement ;
   KDEVICE_QUEUE DeviceQueue ;
   KDPC Dpc ;
   ULONG ActiveThreadCount ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
   KEVENT DeviceLock ;
   USHORT SectorSize ;
   USHORT Spare1 ;
   struct _DEVOBJ_EXTENSION *DeviceObjectExtension ;
   PVOID Reserved ;
};
#line 929 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DEVICE_OBJECT DEVICE_OBJECT;
#line 930 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT;
#line 931 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DEVOBJ_EXTENSION {
   CSHORT Type ;
   USHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 936 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DRIVER_EXTENSION {
   struct _DRIVER_OBJECT *DriverObject ;
   NTSTATUS (*AddDevice)(struct _DRIVER_OBJECT *DriverObject , struct _DEVICE_OBJECT *PhysicalDeviceObject ) ;
   ULONG Count ;
   UNICODE_STRING ServiceKeyName ;
};
#line 942 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DRIVER_EXTENSION *PDRIVER_EXTENSION;
#line 943 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DRIVER_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG Flags ;
   PVOID DriverStart ;
   ULONG DriverSize ;
   PVOID DriverSection ;
   PDRIVER_EXTENSION DriverExtension ;
   UNICODE_STRING DriverName ;
   PUNICODE_STRING HardwareDatabase ;
   PFAST_IO_DISPATCH FastIoDispatch ;
   NTSTATUS (*DriverInit)(struct _DRIVER_OBJECT *DriverObject , PUNICODE_STRING RegistryPath ) ;
   void (*DriverStartIo)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   void (*DriverUnload)(struct _DRIVER_OBJECT *DriverObject ) ;
   PDRIVER_DISPATCH MajorFunction[28] ;
};
#line 960 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DRIVER_OBJECT DRIVER_OBJECT;
#line 961 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;
#line 962 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SECTION_OBJECT_POINTERS {
   PVOID DataSectionObject ;
   PVOID SharedCacheMap ;
   PVOID ImageSectionObject ;
};
#line 967 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SECTION_OBJECT_POINTERS SECTION_OBJECT_POINTERS;
#line 968 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef SECTION_OBJECT_POINTERS *PSECTION_OBJECT_POINTERS;
#line 969 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_COMPLETION_CONTEXT {
   PVOID Port ;
   PVOID Key ;
};
#line 973 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_COMPLETION_CONTEXT *PIO_COMPLETION_CONTEXT;
#line 974 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _FILE_OBJECT {
   CSHORT Type ;
   CSHORT Size ;
   PDEVICE_OBJECT DeviceObject ;
   PVPB Vpb ;
   PVOID FsContext ;
   PVOID FsContext2 ;
   PSECTION_OBJECT_POINTERS SectionObjectPointer ;
   PVOID PrivateCacheMap ;
   NTSTATUS FinalStatus ;
   struct _FILE_OBJECT *RelatedFileObject ;
   BOOLEAN LockOperation ;
   BOOLEAN DeletePending ;
   BOOLEAN ReadAccess ;
   BOOLEAN WriteAccess ;
   BOOLEAN DeleteAccess ;
   BOOLEAN SharedRead ;
   BOOLEAN SharedWrite ;
   BOOLEAN SharedDelete ;
   ULONG Flags ;
   UNICODE_STRING FileName ;
   LARGE_INTEGER CurrentByteOffset ;
   ULONG Waiters ;
   ULONG Busy ;
   PVOID LastLock ;
   KEVENT Lock ;
   KEVENT Event ;
   PIO_COMPLETION_CONTEXT CompletionContext ;
};
#line 1003 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _FILE_OBJECT *PFILE_OBJECT;
#line 1004 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_AssociatedIrp_44 {
   struct _IRP *MasterIrp ;
   LONG IrpCount ;
   PVOID SystemBuffer ;
};
#line 1009 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_AsynchronousParameters_46 {
   void (*UserApcRoutine)(PVOID ApcContext , PIO_STATUS_BLOCK IoStatusBlock , ULONG Reserved ) ;
   PVOID UserApcContext ;
};
#line 1014 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Overlay_45 {
   struct __anonstruct_AsynchronousParameters_46 AsynchronousParameters ;
   LARGE_INTEGER AllocationSize ;
};
#line 1018 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct____missing_field_name_50 {
   PVOID DriverContext[4] ;
};
#line 1021 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_49 {
   KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
   struct __anonstruct____missing_field_name_50 __annonCompField14 ;
};
#line 1025
struct _IO_STACK_LOCATION;
#line 1025
struct _IO_STACK_LOCATION;
#line 1026 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_52 {
   struct _IO_STACK_LOCATION *CurrentStackLocation ;
   ULONG PacketType ;
};
#line 1030 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct____missing_field_name_51 {
   LIST_ENTRY ListEntry ;
   union __anonunion____missing_field_name_52 __annonCompField16 ;
};
#line 1034 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Overlay_48 {
   union __anonunion____missing_field_name_49 __annonCompField15 ;
   PETHREAD Thread ;
   PCHAR AuxiliaryBuffer ;
   struct __anonstruct____missing_field_name_51 __annonCompField17 ;
   PFILE_OBJECT OriginalFileObject ;
};
#line 1041 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Tail_47 {
   struct __anonstruct_Overlay_48 Overlay ;
   KAPC Apc ;
   PVOID CompletionKey ;
};
#line 1046 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IRP {
   CSHORT Type ;
   USHORT Size ;
   PMDL MdlAddress ;
   ULONG Flags ;
   union __anonunion_AssociatedIrp_44 AssociatedIrp ;
   LIST_ENTRY ThreadListEntry ;
   IO_STATUS_BLOCK IoStatus ;
   KPROCESSOR_MODE RequestorMode ;
   BOOLEAN PendingReturned ;
   CHAR StackCount ;
   CHAR CurrentLocation ;
   BOOLEAN Cancel ;
   KIRQL CancelIrql ;
   CCHAR ApcEnvironment ;
   UCHAR AllocationFlags ;
   PIO_STATUS_BLOCK UserIosb ;
   PKEVENT UserEvent ;
   union __anonunion_Overlay_45 Overlay ;
   void (*CancelRoutine)(struct _DEVICE_OBJECT *DeviceObject , struct _IRP *Irp ) ;
   PVOID UserBuffer ;
   union __anonunion_Tail_47 Tail ;
};
#line 1069 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IRP IRP;
#line 1070 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IRP *PIRP;
#line 1071
enum _DEVICE_RELATION_TYPE {
    BusRelations = 0,
    EjectionRelations = 1,
    PowerRelations = 2,
    RemovalRelations = 3,
    TargetDeviceRelation = 4
} ;
#line 1078 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _DEVICE_RELATION_TYPE DEVICE_RELATION_TYPE;
#line 1079
enum _DEVICE_USAGE_NOTIFICATION_TYPE {
    DeviceUsageTypeUndefined = 0,
    DeviceUsageTypePaging = 1,
    DeviceUsageTypeHibernation = 2,
    DeviceUsageTypeDumpFile = 3
} ;
#line 1085 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE DEVICE_USAGE_NOTIFICATION_TYPE;
#line 1086 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _INTERFACE {
   USHORT Size ;
   USHORT Version ;
   PVOID Context ;
   void (*InterfaceReference)(PVOID Context ) ;
   void (*InterfaceDereference)(PVOID Context ) ;
};
#line 1093 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _INTERFACE *PINTERFACE;
#line 1094 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _DEVICE_CAPABILITIES {
   USHORT Size ;
   USHORT Version ;
   ULONG DeviceD1 : 1 ;
   ULONG DeviceD2 : 1 ;
   ULONG LockSupported : 1 ;
   ULONG EjectSupported : 1 ;
   ULONG Removable : 1 ;
   ULONG DockDevice : 1 ;
   ULONG UniqueID : 1 ;
   ULONG SilentInstall : 1 ;
   ULONG RawDeviceOK : 1 ;
   ULONG SurpriseRemovalOK : 1 ;
   ULONG WakeFromD0 : 1 ;
   ULONG WakeFromD1 : 1 ;
   ULONG WakeFromD2 : 1 ;
   ULONG WakeFromD3 : 1 ;
   ULONG HardwareDisabled : 1 ;
   ULONG NonDynamic : 1 ;
   ULONG WarmEjectSupported : 1 ;
   ULONG Reserved : 15 ;
   ULONG Address ;
   ULONG UINumber ;
   DEVICE_POWER_STATE DeviceState[7] ;
   SYSTEM_POWER_STATE SystemWake ;
   DEVICE_POWER_STATE DeviceWake ;
   ULONG D1Latency ;
   ULONG D2Latency ;
   ULONG D3Latency ;
};
#line 1124 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _DEVICE_CAPABILITIES *PDEVICE_CAPABILITIES;
#line 1125 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _POWER_SEQUENCE {
   ULONG SequenceD1 ;
   ULONG SequenceD2 ;
   ULONG SequenceD3 ;
};
#line 1130 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _POWER_SEQUENCE *PPOWER_SEQUENCE;
#line 1131
enum __anonenum_BUS_QUERY_ID_TYPE_53 {
    BusQueryDeviceID = 0,
    BusQueryHardwareIDs = 1,
    BusQueryCompatibleIDs = 2,
    BusQueryInstanceID = 3,
    BusQueryDeviceSerialNumber = 4
} ;
#line 1138 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum __anonenum_BUS_QUERY_ID_TYPE_53 BUS_QUERY_ID_TYPE;
#line 1139
enum __anonenum_DEVICE_TEXT_TYPE_54 {
    DeviceTextDescription = 0,
    DeviceTextLocationInformation = 1
} ;
#line 1143 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef enum __anonenum_DEVICE_TEXT_TYPE_54 DEVICE_TEXT_TYPE;
#line 1144
#pragma pack(push,4)
#line 1145 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Create_56 {
   PIO_SECURITY_CONTEXT SecurityContext ;
   ULONG Options ;
   USHORT FileAttributes ;
   USHORT ShareAccess ;
   ULONG EaLength ;
};
#line 1152 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Read_57 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1157 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Write_58 {
   ULONG Length ;
   ULONG Key ;
   LARGE_INTEGER ByteOffset ;
};
#line 1162 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryFile_59 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
};
#line 1166 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct____missing_field_name_62 {
   BOOLEAN ReplaceIfExists ;
   BOOLEAN AdvanceOnly ;
};
#line 1170 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_61 {
   struct __anonstruct____missing_field_name_62 __annonCompField18 ;
   ULONG ClusterCount ;
   HANDLE DeleteHandle ;
};
#line 1175 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_SetFile_60 {
   ULONG Length ;
   FILE_INFORMATION_CLASS FileInformationClass ;
   PFILE_OBJECT FileObject ;
   union __anonunion____missing_field_name_61 __annonCompField19 ;
};
#line 1181 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryVolume_63 {
   ULONG Length ;
   FS_INFORMATION_CLASS FsInformationClass ;
};
#line 1185 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_DeviceIoControl_64 {
   ULONG OutputBufferLength ;
   ULONG InputBufferLength ;
   ULONG IoControlCode ;
   PVOID Type3InputBuffer ;
};
#line 1191 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QuerySecurity_65 {
   SECURITY_INFORMATION SecurityInformation ;
   ULONG Length ;
};
#line 1195 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_SetSecurity_66 {
   SECURITY_INFORMATION SecurityInformation ;
   PSECURITY_DESCRIPTOR SecurityDescriptor ;
};
#line 1199 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_MountVolume_67 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1203 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_VerifyVolume_68 {
   PVPB Vpb ;
   PDEVICE_OBJECT DeviceObject ;
};
#line 1207 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Scsi_69 {
   struct _SCSI_REQUEST_BLOCK *Srb ;
};
#line 1210 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryDeviceRelations_70 {
   DEVICE_RELATION_TYPE Type ;
};
#line 1213 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryInterface_71 {
   GUID const   *InterfaceType ;
   USHORT Size ;
   USHORT Version ;
   PINTERFACE Interface ;
   PVOID InterfaceSpecificData ;
};
#line 1220 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_DeviceCapabilities_72 {
   PDEVICE_CAPABILITIES Capabilities ;
};
#line 1223 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_FilterResourceRequirements_73 {
   PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList ;
};
#line 1226 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_ReadWriteConfig_74 {
   ULONG WhichSpace ;
   PVOID Buffer ;
   ULONG Offset ;
   ULONG Length ;
};
#line 1232 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_SetLock_75 {
   BOOLEAN Lock ;
};
#line 1235 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryId_76 {
   BUS_QUERY_ID_TYPE IdType ;
};
#line 1238 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_QueryDeviceText_77 {
   DEVICE_TEXT_TYPE DeviceTextType ;
   LCID LocaleId ;
};
#line 1242 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_UsageNotification_78 {
   BOOLEAN InPath ;
   BOOLEAN Reserved[3] ;
   DEVICE_USAGE_NOTIFICATION_TYPE Type ;
};
#line 1247 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_WaitWake_79 {
   SYSTEM_POWER_STATE PowerState ;
};
#line 1250 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_PowerSequence_80 {
   PPOWER_SEQUENCE PowerSequence ;
};
#line 1253 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Power_81 {
   ULONG SystemContext ;
   POWER_STATE_TYPE Type ;
   POWER_STATE State ;
   POWER_ACTION ShutdownType ;
};
#line 1259 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_StartDevice_82 {
   PCM_RESOURCE_LIST AllocatedResources ;
   PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
};
#line 1263 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_WMI_83 {
   ULONG_PTR ProviderId ;
   PVOID DataPath ;
   ULONG BufferSize ;
   PVOID Buffer ;
};
#line 1269 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Others_84 {
   PVOID Argument1 ;
   PVOID Argument2 ;
   PVOID Argument3 ;
   PVOID Argument4 ;
};
#line 1275 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Parameters_55 {
   struct __anonstruct_Create_56 Create ;
   struct __anonstruct_Read_57 Read ;
   struct __anonstruct_Write_58 Write ;
   struct __anonstruct_QueryFile_59 QueryFile ;
   struct __anonstruct_SetFile_60 SetFile ;
   struct __anonstruct_QueryVolume_63 QueryVolume ;
   struct __anonstruct_DeviceIoControl_64 DeviceIoControl ;
   struct __anonstruct_QuerySecurity_65 QuerySecurity ;
   struct __anonstruct_SetSecurity_66 SetSecurity ;
   struct __anonstruct_MountVolume_67 MountVolume ;
   struct __anonstruct_VerifyVolume_68 VerifyVolume ;
   struct __anonstruct_Scsi_69 Scsi ;
   struct __anonstruct_QueryDeviceRelations_70 QueryDeviceRelations ;
   struct __anonstruct_QueryInterface_71 QueryInterface ;
   struct __anonstruct_DeviceCapabilities_72 DeviceCapabilities ;
   struct __anonstruct_FilterResourceRequirements_73 FilterResourceRequirements ;
   struct __anonstruct_ReadWriteConfig_74 ReadWriteConfig ;
   struct __anonstruct_SetLock_75 SetLock ;
   struct __anonstruct_QueryId_76 QueryId ;
   struct __anonstruct_QueryDeviceText_77 QueryDeviceText ;
   struct __anonstruct_UsageNotification_78 UsageNotification ;
   struct __anonstruct_WaitWake_79 WaitWake ;
   struct __anonstruct_PowerSequence_80 PowerSequence ;
   struct __anonstruct_Power_81 Power ;
   struct __anonstruct_StartDevice_82 StartDevice ;
   struct __anonstruct_WMI_83 WMI ;
   struct __anonstruct_Others_84 Others ;
};
#line 1304 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _IO_STACK_LOCATION {
   UCHAR MajorFunction ;
   UCHAR MinorFunction ;
   UCHAR Flags ;
   UCHAR Control ;
   union __anonunion_Parameters_55 Parameters ;
   PDEVICE_OBJECT DeviceObject ;
   PFILE_OBJECT FileObject ;
   NTSTATUS (*CompletionRoutine)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
   PVOID Context ;
};
#line 1315 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION;
#line 1316 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
#line 1317
#pragma pack(pop)
#line 1318 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CONFIGURATION_INFORMATION {
   ULONG DiskCount ;
   ULONG FloppyCount ;
   ULONG CdRomCount ;
   ULONG TapeCount ;
   ULONG ScsiPortCount ;
   ULONG SerialCount ;
   ULONG ParallelCount ;
   BOOLEAN AtDiskPrimaryAddressClaimed ;
   BOOLEAN AtDiskSecondaryAddressClaimed ;
   ULONG Version ;
   ULONG MediumChangerCount ;
};
#line 1331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CONFIGURATION_INFORMATION CONFIGURATION_INFORMATION;
#line 1332 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CONFIGURATION_INFORMATION *PCONFIGURATION_INFORMATION;
#line 1333 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _OBJECT_HANDLE_INFORMATION {
   ULONG HandleAttributes ;
   ACCESS_MASK GrantedAccess ;
};
#line 1337 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _OBJECT_HANDLE_INFORMATION *POBJECT_HANDLE_INFORMATION;
#line 1338 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SCSI_PASS_THROUGH {
   USHORT Length ;
   UCHAR ScsiStatus ;
   UCHAR PathId ;
   UCHAR TargetId ;
   UCHAR Lun ;
   UCHAR CdbLength ;
   UCHAR SenseInfoLength ;
   UCHAR DataIn ;
   ULONG DataTransferLength ;
   ULONG TimeOutValue ;
   ULONG_PTR DataBufferOffset ;
   ULONG SenseInfoOffset ;
   UCHAR Cdb[16] ;
};
#line 1353 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SCSI_PASS_THROUGH SCSI_PASS_THROUGH;
#line 1354 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SCSI_PASS_THROUGH *PSCSI_PASS_THROUGH;
#line 1355 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _TRACK_DATA {
   UCHAR Reserved ;
   UCHAR Control : 4 ;
   UCHAR Adr : 4 ;
   UCHAR TrackNumber ;
   UCHAR Reserved1 ;
   UCHAR Address[4] ;
};
#line 1363 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _TRACK_DATA TRACK_DATA;
#line 1364 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDROM_TOC {
   UCHAR Length[2] ;
   UCHAR FirstTrack ;
   UCHAR LastTrack ;
   TRACK_DATA TrackData[100] ;
};
#line 1370 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_TOC CDROM_TOC;
#line 1371 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_TOC *PCDROM_TOC;
#line 1372 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDROM_PLAY_AUDIO_MSF {
   UCHAR StartingM ;
   UCHAR StartingS ;
   UCHAR StartingF ;
   UCHAR EndingM ;
   UCHAR EndingS ;
   UCHAR EndingF ;
};
#line 1380 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_PLAY_AUDIO_MSF CDROM_PLAY_AUDIO_MSF;
#line 1381 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_PLAY_AUDIO_MSF *PCDROM_PLAY_AUDIO_MSF;
#line 1382 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDROM_SEEK_AUDIO_MSF {
   UCHAR M ;
   UCHAR S ;
   UCHAR F ;
};
#line 1387 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_SEEK_AUDIO_MSF CDROM_SEEK_AUDIO_MSF;
#line 1388 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CDROM_SEEK_AUDIO_MSF *PCDROM_SEEK_AUDIO_MSF;
#line 1389 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDROM_SUB_Q_DATA_FORMAT {
   UCHAR Format ;
   UCHAR Track ;
};
#line 1393 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SUB_Q_HEADER {
   UCHAR Reserved ;
   UCHAR AudioStatus ;
   UCHAR DataLength[2] ;
};
#line 1398 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SUB_Q_HEADER SUB_Q_HEADER;
#line 1399 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SUB_Q_CURRENT_POSITION {
   SUB_Q_HEADER Header ;
   UCHAR FormatCode ;
   UCHAR Control : 4 ;
   UCHAR ADR : 4 ;
   UCHAR TrackNumber ;
   UCHAR IndexNumber ;
   UCHAR AbsoluteAddress[4] ;
   UCHAR TrackRelativeAddress[4] ;
};
#line 1409 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SUB_Q_CURRENT_POSITION SUB_Q_CURRENT_POSITION;
#line 1410 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SUB_Q_CURRENT_POSITION *PSUB_Q_CURRENT_POSITION;
#line 1411 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SUB_Q_MEDIA_CATALOG_NUMBER {
   SUB_Q_HEADER Header ;
   UCHAR FormatCode ;
   UCHAR Reserved[3] ;
   UCHAR Reserved1 : 7 ;
   UCHAR Mcval : 1 ;
   UCHAR MediaCatalog[15] ;
};
#line 1419 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER SUB_Q_MEDIA_CATALOG_NUMBER;
#line 1420 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SUB_Q_TRACK_ISRC {
   SUB_Q_HEADER Header ;
   UCHAR FormatCode ;
   UCHAR Reserved0 ;
   UCHAR Track ;
   UCHAR Reserved1 ;
   UCHAR Reserved2 : 7 ;
   UCHAR Tcval : 1 ;
   UCHAR TrackIsrc[15] ;
};
#line 1430 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _SUB_Q_TRACK_ISRC SUB_Q_TRACK_ISRC;
#line 1431 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _SUB_Q_CHANNEL_DATA {
   SUB_Q_CURRENT_POSITION CurrentPosition ;
   SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog ;
   SUB_Q_TRACK_ISRC TrackIsrc ;
};
#line 1436 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _SUB_Q_CHANNEL_DATA SUB_Q_CHANNEL_DATA;
#line 1437
#pragma pack(push,8)
#line 1438
#pragma pack(pop)
#line 1439 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_116 {
   ULONG InternalStatus ;
   ULONG QueueSortKey ;
};
#line 1443 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SCSI_REQUEST_BLOCK {
   USHORT Length ;
   UCHAR Function ;
   UCHAR SrbStatus ;
   UCHAR ScsiStatus ;
   UCHAR PathId ;
   UCHAR TargetId ;
   UCHAR Lun ;
   UCHAR QueueTag ;
   UCHAR QueueAction ;
   UCHAR CdbLength ;
   UCHAR SenseInfoBufferLength ;
   ULONG SrbFlags ;
   ULONG DataTransferLength ;
   ULONG TimeOutValue ;
   PVOID DataBuffer ;
   PVOID SenseInfoBuffer ;
   struct _SCSI_REQUEST_BLOCK *NextSrb ;
   PVOID OriginalRequest ;
   PVOID SrbExtension ;
   union __anonunion____missing_field_name_116 __annonCompField21 ;
   UCHAR Cdb[16] ;
};
#line 1466 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6GENERIC {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR CommandUniqueBits : 4 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR CommandUniqueBytes[3] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved : 4 ;
   UCHAR VendorUnique : 2 ;
};
#line 1477 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6READWRITE {
   UCHAR OperationCode ;
   UCHAR LogicalBlockMsb1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR LogicalBlockMsb0 ;
   UCHAR LogicalBlockLsb ;
   UCHAR TransferBlocks ;
   UCHAR Control ;
};
#line 1486 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6INQUIRY {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR PageCode ;
   UCHAR IReserved ;
   UCHAR AllocationLength ;
   UCHAR Control ;
};
#line 1495 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6VERIFY {
   UCHAR OperationCode ;
   UCHAR Fixed : 1 ;
   UCHAR ByteCompare : 1 ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved : 2 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR VerificationLength[3] ;
   UCHAR Control ;
};
#line 1505 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6FORMAT {
   UCHAR OperationCode ;
   UCHAR FormatControl : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR FReserved1 ;
   UCHAR InterleaveMsb ;
   UCHAR InterleaveLsb ;
   UCHAR FReserved2 ;
};
#line 1514 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB10 {
   UCHAR OperationCode ;
   UCHAR RelativeAddress : 1 ;
   UCHAR Reserved1 : 2 ;
   UCHAR ForceUnitAccess : 1 ;
   UCHAR DisablePageOut : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR LogicalBlockByte0 ;
   UCHAR LogicalBlockByte1 ;
   UCHAR LogicalBlockByte2 ;
   UCHAR LogicalBlockByte3 ;
   UCHAR Reserved2 ;
   UCHAR TransferBlocksMsb ;
   UCHAR TransferBlocksLsb ;
   UCHAR Control ;
};
#line 1530 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB12 {
   UCHAR OperationCode ;
   UCHAR RelativeAddress : 1 ;
   UCHAR Reserved1 : 2 ;
   UCHAR ForceUnitAccess : 1 ;
   UCHAR DisablePageOut : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR LogicalBlock[4] ;
   UCHAR TransferLength[4] ;
   UCHAR Reserved2 ;
   UCHAR Control ;
};
#line 1542 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PAUSE_RESUME {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[6] ;
   UCHAR Action ;
   UCHAR Control ;
};
#line 1550 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_TOC {
   UCHAR OperationCode ;
   UCHAR Reserved0 : 1 ;
   UCHAR Msf : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Format2 : 4 ;
   UCHAR Reserved2 : 4 ;
   UCHAR Reserved3[3] ;
   UCHAR StartingTrack ;
   UCHAR AllocationLength[2] ;
   UCHAR Control : 6 ;
   UCHAR Format : 2 ;
};
#line 1564 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_DISK_INFORMATION {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[5] ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1572 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_TRACK_INFORMATION {
   UCHAR OperationCode ;
   UCHAR Track : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR Reserved2 : 1 ;
   UCHAR Lun : 3 ;
   UCHAR BlockAddress[4] ;
   UCHAR Reserved3 ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1583 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_HEADER {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 1 ;
   UCHAR Msf : 1 ;
   UCHAR Reserved2 : 3 ;
   UCHAR Lun : 3 ;
   UCHAR LogicalBlockAddress[4] ;
   UCHAR Reserved3 ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1594 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PLAY_AUDIO {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR StartingBlockAddress[4] ;
   UCHAR Reserved2 ;
   UCHAR PlayLength[2] ;
   UCHAR Control ;
};
#line 1603 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PLAY_AUDIO_MSF {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2 ;
   UCHAR StartingM ;
   UCHAR StartingS ;
   UCHAR StartingF ;
   UCHAR EndingM ;
   UCHAR EndingS ;
   UCHAR EndingF ;
   UCHAR Control ;
};
#line 1616 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LBA {
   UCHAR StartingBlockAddress[4] ;
   UCHAR PlayLength[4] ;
};
#line 1620 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MSF {
   UCHAR Reserved1 ;
   UCHAR StartingM ;
   UCHAR StartingS ;
   UCHAR StartingF ;
   UCHAR EndingM ;
   UCHAR EndingS ;
   UCHAR EndingF ;
   UCHAR Reserved2 ;
};
#line 1630 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion____missing_field_name_117 {
   struct _LBA LBA ;
   struct _MSF MSF ;
};
#line 1634 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PLAY_CD {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 1 ;
   UCHAR CMSF : 1 ;
   UCHAR ExpectedSectorType : 3 ;
   UCHAR Lun : 3 ;
   union __anonunion____missing_field_name_117 __annonCompField22 ;
   UCHAR Audio : 1 ;
   UCHAR Composite : 1 ;
   UCHAR Port1 : 1 ;
   UCHAR Port2 : 1 ;
   UCHAR Reserved2 : 3 ;
   UCHAR Speed : 1 ;
   UCHAR Control ;
};
#line 1649 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SCAN_CD {
   UCHAR OperationCode ;
   UCHAR RelativeAddress : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR Direct : 1 ;
   UCHAR Lun : 3 ;
   UCHAR StartingAddress[4] ;
   UCHAR Reserved2[3] ;
   UCHAR Reserved3 : 6 ;
   UCHAR Type : 2 ;
   UCHAR Reserved4 ;
   UCHAR Control ;
};
#line 1662 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _STOP_PLAY_SCAN {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[7] ;
   UCHAR Control ;
};
#line 1669 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SUBCHANNEL {
   UCHAR OperationCode ;
   UCHAR Reserved0 : 1 ;
   UCHAR Msf : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2 : 6 ;
   UCHAR SubQ : 1 ;
   UCHAR Reserved3 : 1 ;
   UCHAR Format ;
   UCHAR Reserved4[2] ;
   UCHAR TrackNumber ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1684 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_CD {
   UCHAR OperationCode ;
   UCHAR RelativeAddress : 1 ;
   UCHAR Reserved0 : 1 ;
   UCHAR ExpectedSectorType : 3 ;
   UCHAR Lun : 3 ;
   UCHAR StartingLBA[4] ;
   UCHAR TransferBlocks[3] ;
   UCHAR Reserved2 : 1 ;
   UCHAR ErrorFlags : 2 ;
   UCHAR IncludeEDC : 1 ;
   UCHAR IncludeUserData : 1 ;
   UCHAR HeaderCode : 2 ;
   UCHAR IncludeSyncData : 1 ;
   UCHAR SubChannelSelection : 3 ;
   UCHAR Reserved3 : 5 ;
   UCHAR Control ;
};
#line 1702 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_CD_MSF {
   UCHAR OperationCode ;
   UCHAR RelativeAddress : 1 ;
   UCHAR Reserved1 : 1 ;
   UCHAR ExpectedSectorType : 3 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2 ;
   UCHAR StartingM ;
   UCHAR StartingS ;
   UCHAR StartingF ;
   UCHAR EndingM ;
   UCHAR EndingS ;
   UCHAR EndingF ;
   UCHAR Reserved3 ;
   UCHAR Reserved4 : 1 ;
   UCHAR ErrorFlags : 2 ;
   UCHAR IncludeEDC : 1 ;
   UCHAR IncludeUserData : 1 ;
   UCHAR HeaderCode : 2 ;
   UCHAR IncludeSyncData : 1 ;
   UCHAR SubChannelSelection : 3 ;
   UCHAR Reserved5 : 5 ;
   UCHAR Control ;
};
#line 1726 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PLXTR_READ_CDDA {
   UCHAR OperationCode ;
   UCHAR Reserved0 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR LogicalBlockByte0 ;
   UCHAR LogicalBlockByte1 ;
   UCHAR LogicalBlockByte2 ;
   UCHAR LogicalBlockByte3 ;
   UCHAR TransferBlockByte0 ;
   UCHAR TransferBlockByte1 ;
   UCHAR TransferBlockByte2 ;
   UCHAR TransferBlockByte3 ;
   UCHAR SubCode ;
   UCHAR Control ;
};
#line 1741 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_READ_CDDA {
   UCHAR OperationCode ;
   UCHAR Reserved0 ;
   UCHAR LogicalBlockByte0 ;
   UCHAR LogicalBlockByte1 ;
   UCHAR LogicalBlockByte2 ;
   UCHAR LogicalBlockByte3 ;
   UCHAR Reserved1 ;
   UCHAR TransferBlockByte0 ;
   UCHAR TransferBlockByte1 ;
   UCHAR Control ;
};
#line 1753 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MODE_SENSE {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 3 ;
   UCHAR Dbd : 1 ;
   UCHAR Reserved2 : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR PageCode : 6 ;
   UCHAR Pc : 2 ;
   UCHAR Reserved3 ;
   UCHAR AllocationLength ;
   UCHAR Control ;
};
#line 1765 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MODE_SENSE10 {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 3 ;
   UCHAR Dbd : 1 ;
   UCHAR Reserved2 : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR PageCode : 6 ;
   UCHAR Pc : 2 ;
   UCHAR Reserved3[4] ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1777 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MODE_SELECT {
   UCHAR OperationCode ;
   UCHAR SPBit : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR PFBit : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[2] ;
   UCHAR ParameterListLength ;
   UCHAR Control ;
};
#line 1787 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MODE_SELECT10 {
   UCHAR OperationCode ;
   UCHAR SPBit : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR PFBit : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[5] ;
   UCHAR ParameterListLength[2] ;
   UCHAR Control ;
};
#line 1797 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LOCATE {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR CPBit : 1 ;
   UCHAR BTBit : 1 ;
   UCHAR Reserved1 : 2 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved3 ;
   UCHAR LogicalBlockAddress[4] ;
   UCHAR Reserved4 ;
   UCHAR Partition ;
   UCHAR Control ;
};
#line 1810 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LOGSENSE {
   UCHAR OperationCode ;
   UCHAR SPBit : 1 ;
   UCHAR PPCBit : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR PageCode : 6 ;
   UCHAR PCBit : 2 ;
   UCHAR Reserved2 ;
   UCHAR Reserved3 ;
   UCHAR ParameterPointer[2] ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 1824 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LOGSELECT {
   UCHAR OperationCode ;
   UCHAR SPBit : 1 ;
   UCHAR PCRBit : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved : 6 ;
   UCHAR PCBit : 2 ;
   UCHAR Reserved2[4] ;
   UCHAR ParameterListLength[2] ;
   UCHAR Control ;
};
#line 1836 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PRINT {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR TransferLength[3] ;
   UCHAR Control ;
};
#line 1843 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SEEK {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR LogicalBlockAddress[4] ;
   UCHAR Reserved2[3] ;
   UCHAR Control ;
};
#line 1851 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _ERASE {
   UCHAR OperationCode ;
   UCHAR Long : 1 ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[3] ;
   UCHAR Control ;
};
#line 1860 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _START_STOP {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[2] ;
   UCHAR Start : 1 ;
   UCHAR LoadEject : 1 ;
   UCHAR Reserved3 : 6 ;
   UCHAR Control ;
};
#line 1871 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MEDIA_REMOVAL {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved2[2] ;
   UCHAR Prevent : 1 ;
   UCHAR Persistant : 1 ;
   UCHAR Reserved3 : 6 ;
   UCHAR Control ;
};
#line 1881 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SEEK_BLOCK {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 7 ;
   UCHAR BlockAddress[3] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved2 : 4 ;
   UCHAR VendorUnique : 2 ;
};
#line 1891 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _REQUEST_BLOCK_ADDRESS {
   UCHAR OperationCode ;
   UCHAR Reserved1[3] ;
   UCHAR AllocationLength ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved2 : 4 ;
   UCHAR VendorUnique : 2 ;
};
#line 1900 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PARTITION {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Sel : 1 ;
   UCHAR PartitionSelect : 6 ;
   UCHAR Reserved1[3] ;
   UCHAR Control ;
};
#line 1908 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _WRITE_TAPE_MARKS {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR WriteSetMarks : 1 ;
   UCHAR Reserved : 3 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR TransferLength[3] ;
   UCHAR Control ;
};
#line 1917 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_Fields_119 {
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved : 4 ;
   UCHAR VendorUnique : 2 ;
};
#line 1923 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union __anonunion_Byte6_118 {
   UCHAR value ;
   struct __anonstruct_Fields_119 Fields ;
};
#line 1927 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SPACE_TAPE_MARKS {
   UCHAR OperationCode ;
   UCHAR Code : 3 ;
   UCHAR Reserved : 2 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR NumMarksMSB ;
   UCHAR NumMarks ;
   UCHAR NumMarksLSB ;
   union __anonunion_Byte6_118 Byte6 ;
};
#line 1937 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_POSITION {
   UCHAR Operation ;
   UCHAR BlockType : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[7] ;
   UCHAR Control ;
};
#line 1945 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CDB6READWRITETAPE {
   UCHAR OperationCode ;
   UCHAR VendorSpecific : 5 ;
   UCHAR Reserved : 3 ;
   UCHAR TransferLenMSB ;
   UCHAR TransferLen ;
   UCHAR TransferLenLSB ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR VendorUnique : 2 ;
};
#line 1957 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _INIT_ELEMENT_STATUS {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNubmer : 3 ;
   UCHAR Reserved2[3] ;
   UCHAR Reserved3 : 7 ;
   UCHAR NoBarCode : 1 ;
};
#line 1965 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _INITIALIZE_ELEMENT_RANGE {
   UCHAR OperationCode ;
   UCHAR Range : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR LogicalUnitNubmer : 3 ;
   UCHAR FirstElementAddress[2] ;
   UCHAR Reserved2[2] ;
   UCHAR NumberOfElements[2] ;
   UCHAR Reserved3 ;
   UCHAR Reserved4 : 7 ;
   UCHAR NoBarCode : 1 ;
};
#line 1977 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _POSITION_TO_ELEMENT {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR TransportElementAddress[2] ;
   UCHAR DestinationElementAddress[2] ;
   UCHAR Reserved2[2] ;
   UCHAR Flip : 1 ;
   UCHAR Reserved3 : 7 ;
   UCHAR Control ;
};
#line 1988 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MOVE_MEDIUM {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR TransportElementAddress[2] ;
   UCHAR SourceElementAddress[2] ;
   UCHAR DestinationElementAddress[2] ;
   UCHAR Reserved2[2] ;
   UCHAR Flip : 1 ;
   UCHAR Reserved3 : 7 ;
   UCHAR Control ;
};
#line 2000 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _EXCHANGE_MEDIUM {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR TransportElementAddress[2] ;
   UCHAR SourceElementAddress[2] ;
   UCHAR Destination1ElementAddress[2] ;
   UCHAR Destination2ElementAddress[2] ;
   UCHAR Flip1 : 1 ;
   UCHAR Flip2 : 1 ;
   UCHAR Reserved3 : 6 ;
   UCHAR Control ;
};
#line 2013 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_ELEMENT_STATUS {
   UCHAR OperationCode ;
   UCHAR ElementType : 4 ;
   UCHAR VolTag : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR StartingElementAddress[2] ;
   UCHAR NumberOfElements[2] ;
   UCHAR Reserved1 ;
   UCHAR AllocationLength[3] ;
   UCHAR Reserved2 ;
   UCHAR Control ;
};
#line 2025 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SEND_VOLUME_TAG {
   UCHAR OperationCode ;
   UCHAR ElementType : 4 ;
   UCHAR Reserved1 : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR StartingElementAddress[2] ;
   UCHAR Reserved2 ;
   UCHAR ActionCode : 5 ;
   UCHAR Reserved3 : 3 ;
   UCHAR Reserved4[2] ;
   UCHAR ParameterListLength[2] ;
   UCHAR Reserved5 ;
   UCHAR Control ;
};
#line 2039 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
   UCHAR OperationCode ;
   UCHAR ElementType : 4 ;
   UCHAR VolTag : 1 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR StartingElementAddress[2] ;
   UCHAR NumberElements[2] ;
   UCHAR Reserved1 ;
   UCHAR AllocationLength[3] ;
   UCHAR Reserved2 ;
   UCHAR Control ;
};
#line 2051 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _LOAD_UNLOAD {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[2] ;
   UCHAR Start : 1 ;
   UCHAR LoadEject : 1 ;
   UCHAR Reserved3 : 6 ;
   UCHAR Reserved4[3] ;
   UCHAR Slot ;
   UCHAR Reserved5[3] ;
};
#line 2064 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _MECH_STATUS {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1[6] ;
   UCHAR AllocationLength[2] ;
   UCHAR Reserved2[1] ;
   UCHAR Control ;
};
#line 2073 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SYNCHRONIZE_CACHE10 {
   UCHAR OperationCode ;
   UCHAR RelAddr : 1 ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved : 3 ;
   UCHAR Lun : 3 ;
   UCHAR LogicalBlockAddress[4] ;
   UCHAR Reserved2 ;
   UCHAR BlockCount[2] ;
   UCHAR Control ;
};
#line 2084 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _GET_EVENT_STATUS_NOTIFICATION {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved : 4 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[2] ;
   UCHAR NotificationClassRequest ;
   UCHAR Reserved3[2] ;
   UCHAR EventListLength[2] ;
   UCHAR Control ;
};
#line 2095 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_DVD_STRUCTURE {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR RMDBlockNumber[4] ;
   UCHAR LayerNumber ;
   UCHAR Format ;
   UCHAR AllocationLength[2] ;
   UCHAR Reserved3 : 6 ;
   UCHAR AGID : 2 ;
   UCHAR Control ;
};
#line 2107 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SEND_KEY {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[6] ;
   UCHAR ParameterListLength[2] ;
   UCHAR KeyFormat : 6 ;
   UCHAR AGID : 2 ;
   UCHAR Control ;
};
#line 2117 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _REPORT_KEY {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR LogicalBlockAddress[4] ;
   UCHAR Reserved2[2] ;
   UCHAR AllocationLength[2] ;
   UCHAR KeyFormat : 6 ;
   UCHAR AGID : 2 ;
   UCHAR Control ;
};
#line 2128 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _SET_READ_AHEAD {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR TriggerLBA[4] ;
   UCHAR ReadAheadLBA[4] ;
   UCHAR Reserved2 ;
   UCHAR Control ;
};
#line 2137 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_FORMATTED_CAPACITIES {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[5] ;
   UCHAR AllocationLength[2] ;
   UCHAR Control ;
};
#line 2145 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _REPORT_LUNS {
   UCHAR OperationCode ;
   UCHAR Reserved1[5] ;
   UCHAR AllocationLength[4] ;
   UCHAR Reserved2[1] ;
   UCHAR Control ;
};
#line 2152 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _CDB {
   struct _CDB6GENERIC CDB6GENERIC ;
   struct _CDB6GENERIC *PCDB6GENERIC ;
   struct _CDB6READWRITE CDB6READWRITE ;
   struct _CDB6READWRITE *PCDB6READWRITE ;
   struct _CDB6INQUIRY CDB6INQUIRY ;
   struct _CDB6INQUIRY *PCDB6INQUIRY ;
   struct _CDB6VERIFY CDB6VERIFY ;
   struct _CDB6VERIFY *PCDB6VERIFY ;
   struct _CDB6FORMAT CDB6FORMAT ;
   struct _CDB6FORMAT *PCDB6FORMAT ;
   struct _CDB10 CDB10 ;
   struct _CDB10 *PCDB10 ;
   struct _CDB12 CDB12 ;
   struct _CDB12 *PCDB12 ;
   struct _PAUSE_RESUME PAUSE_RESUME ;
   struct _PAUSE_RESUME *PPAUSE_RESUME ;
   struct _READ_TOC READ_TOC ;
   struct _READ_TOC *PREAD_TOC ;
   struct _READ_DISK_INFORMATION READ_DISK_INFORMATION ;
   struct _READ_DISK_INFORMATION *PREAD_DISK_INFORMATION ;
   struct _READ_TRACK_INFORMATION READ_TRACK_INFORMATION ;
   struct _READ_TRACK_INFORMATION *PREAD_TRACK_INFORMATION ;
   struct _READ_HEADER READ_HEADER ;
   struct _READ_HEADER *PREAD_HEADER ;
   struct _PLAY_AUDIO PLAY_AUDIO ;
   struct _PLAY_AUDIO *PPLAY_AUDIO ;
   struct _PLAY_AUDIO_MSF PLAY_AUDIO_MSF ;
   struct _PLAY_AUDIO_MSF *PPLAY_AUDIO_MSF ;
   struct _PLAY_CD PLAY_CD ;
   struct _PLAY_CD *PPLAY_CD ;
   struct _SCAN_CD SCAN_CD ;
   struct _SCAN_CD *PSCAN_CD ;
   struct _STOP_PLAY_SCAN STOP_PLAY_SCAN ;
   struct _STOP_PLAY_SCAN *PSTOP_PLAY_SCAN ;
   struct _SUBCHANNEL SUBCHANNEL ;
   struct _SUBCHANNEL *PSUBCHANNEL ;
   struct _READ_CD READ_CD ;
   struct _READ_CD *PREAD_CD ;
   struct _READ_CD_MSF READ_CD_MSF ;
   struct _READ_CD_MSF *PREAD_CD_MSF ;
   struct _PLXTR_READ_CDDA PLXTR_READ_CDDA ;
   struct _PLXTR_READ_CDDA *PPLXTR_READ_CDDA ;
   struct _NEC_READ_CDDA NEC_READ_CDDA ;
   struct _NEC_READ_CDDA *PNEC_READ_CDDA ;
   struct _MODE_SENSE MODE_SENSE ;
   struct _MODE_SENSE *PMODE_SENSE ;
   struct _MODE_SENSE10 MODE_SENSE10 ;
   struct _MODE_SENSE10 *PMODE_SENSE10 ;
   struct _MODE_SELECT MODE_SELECT ;
   struct _MODE_SELECT *PMODE_SELECT ;
   struct _MODE_SELECT10 MODE_SELECT10 ;
   struct _MODE_SELECT10 *PMODE_SELECT10 ;
   struct _LOCATE LOCATE ;
   struct _LOCATE *PLOCATE ;
   struct _LOGSENSE LOGSENSE ;
   struct _LOGSENSE *PLOGSENSE ;
   struct _LOGSELECT LOGSELECT ;
   struct _LOGSELECT *PLOGSELECT ;
   struct _PRINT PRINT ;
   struct _PRINT *PPRINT ;
   struct _SEEK SEEK ;
   struct _SEEK *PSEEK ;
   struct _ERASE ERASE ;
   struct _ERASE *PERASE ;
   struct _START_STOP START_STOP ;
   struct _START_STOP *PSTART_STOP ;
   struct _MEDIA_REMOVAL MEDIA_REMOVAL ;
   struct _MEDIA_REMOVAL *PMEDIA_REMOVAL ;
   struct _SEEK_BLOCK SEEK_BLOCK ;
   struct _SEEK_BLOCK *PSEEK_BLOCK ;
   struct _REQUEST_BLOCK_ADDRESS REQUEST_BLOCK_ADDRESS ;
   struct _REQUEST_BLOCK_ADDRESS *PREQUEST_BLOCK_ADDRESS ;
   struct _PARTITION PARTITION ;
   struct _PARTITION *PPARTITION ;
   struct _WRITE_TAPE_MARKS WRITE_TAPE_MARKS ;
   struct _WRITE_TAPE_MARKS *PWRITE_TAPE_MARKS ;
   struct _SPACE_TAPE_MARKS SPACE_TAPE_MARKS ;
   struct _SPACE_TAPE_MARKS *PSPACE_TAPE_MARKS ;
   struct _READ_POSITION READ_POSITION ;
   struct _READ_POSITION *PREAD_POSITION ;
   struct _CDB6READWRITETAPE CDB6READWRITETAPE ;
   struct _CDB6READWRITETAPE *PCDB6READWRITETAPE ;
   struct _INIT_ELEMENT_STATUS INIT_ELEMENT_STATUS ;
   struct _INIT_ELEMENT_STATUS *PINIT_ELEMENT_STATUS ;
   struct _INITIALIZE_ELEMENT_RANGE INITIALIZE_ELEMENT_RANGE ;
   struct _INITIALIZE_ELEMENT_RANGE *PINITIALIZE_ELEMENT_RANGE ;
   struct _POSITION_TO_ELEMENT POSITION_TO_ELEMENT ;
   struct _POSITION_TO_ELEMENT *PPOSITION_TO_ELEMENT ;
   struct _MOVE_MEDIUM MOVE_MEDIUM ;
   struct _MOVE_MEDIUM *PMOVE_MEDIUM ;
   struct _EXCHANGE_MEDIUM EXCHANGE_MEDIUM ;
   struct _EXCHANGE_MEDIUM *PEXCHANGE_MEDIUM ;
   struct _READ_ELEMENT_STATUS READ_ELEMENT_STATUS ;
   struct _READ_ELEMENT_STATUS *PREAD_ELEMENT_STATUS ;
   struct _SEND_VOLUME_TAG SEND_VOLUME_TAG ;
   struct _SEND_VOLUME_TAG *PSEND_VOLUME_TAG ;
   struct _REQUEST_VOLUME_ELEMENT_ADDRESS REQUEST_VOLUME_ELEMENT_ADDRESS ;
   struct _REQUEST_VOLUME_ELEMENT_ADDRESS *PREQUEST_VOLUME_ELEMENT_ADDRESS ;
   struct _LOAD_UNLOAD LOAD_UNLOAD ;
   struct _LOAD_UNLOAD *PLOAD_UNLOAD ;
   struct _MECH_STATUS MECH_STATUS ;
   struct _MECH_STATUS *PMECH_STATUS ;
   struct _SYNCHRONIZE_CACHE10 SYNCHRONIZE_CACHE10 ;
   struct _SYNCHRONIZE_CACHE10 *PSYNCHRONIZE_CACHE10 ;
   struct _GET_EVENT_STATUS_NOTIFICATION GET_EVENT_STATUS_NOTIFICATION ;
   struct _GET_EVENT_STATUS_NOTIFICATION *PGET_EVENT_STATUS_NOTIFICATION ;
   struct _READ_DVD_STRUCTURE READ_DVD_STRUCTURE ;
   struct _READ_DVD_STRUCTURE *PREAD_DVD_STRUCTURE ;
   struct _SEND_KEY SEND_KEY ;
   struct _SEND_KEY *PSEND_KEY ;
   struct _REPORT_KEY REPORT_KEY ;
   struct _REPORT_KEY *PREPORT_KEY ;
   struct _SET_READ_AHEAD SET_READ_AHEAD ;
   struct _SET_READ_AHEAD *PSET_READ_AHEAD ;
   struct _READ_FORMATTED_CAPACITIES READ_FORMATTED_CAPACITIES ;
   struct _READ_FORMATTED_CAPACITIES *PREAD_FORMATTED_CAPACITIES ;
   struct _REPORT_LUNS REPORT_LUNS ;
   struct _REPORT_LUNS *PREPORT_LUNS ;
   ULONG AsUlong[4] ;
   UCHAR AsByte[16] ;
};
#line 2274 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _CDB *PCDB;
#line 2275
#pragma pack(1)
#line 2276
#pragma pack()
#line 2277 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _INQUIRYDATA {
   UCHAR DeviceType : 5 ;
   UCHAR DeviceTypeQualifier : 3 ;
   UCHAR DeviceTypeModifier : 7 ;
   UCHAR RemovableMedia : 1 ;
   UCHAR Versions ;
   UCHAR ResponseDataFormat : 4 ;
   UCHAR HiSupport : 1 ;
   UCHAR NormACA : 1 ;
   UCHAR ReservedBit : 1 ;
   UCHAR AERC : 1 ;
   UCHAR AdditionalLength ;
   UCHAR Reserved[2] ;
   UCHAR SoftReset : 1 ;
   UCHAR CommandQueue : 1 ;
   UCHAR Reserved2 : 1 ;
   UCHAR LinkedCommands : 1 ;
   UCHAR Synchronous : 1 ;
   UCHAR Wide16Bit : 1 ;
   UCHAR Wide32Bit : 1 ;
   UCHAR RelativeAddressing : 1 ;
   UCHAR VendorId[8] ;
   UCHAR ProductId[16] ;
   UCHAR ProductRevisionLevel[4] ;
   UCHAR VendorSpecific[20] ;
   UCHAR Reserved3[40] ;
};
#line 2304 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _INQUIRYDATA *PINQUIRYDATA;
#line 2305 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_CAPACITY_DATA {
   ULONG LogicalBlockAddress ;
   ULONG BytesPerBlock ;
};
#line 2309 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _READ_CAPACITY_DATA READ_CAPACITY_DATA;
#line 2310 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _READ_CAPACITY_DATA *PREAD_CAPACITY_DATA;
#line 2311 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _CD_DEVICE_EXTENSION {
   PDEVICE_OBJECT TargetDeviceObject ;
   PDEVICE_OBJECT TargetPdo ;
   PDEVICE_OBJECT DeviceObject ;
   ULONG PagingPathCount ;
   KEVENT PagingPathCountEvent ;
   PRKDPC Dpc ;
   PKTIMER Timer ;
   LONG Sync ;
   UCHAR Active ;
   UCHAR Paused ;
   UCHAR PausedM ;
   UCHAR PausedS ;
   UCHAR PausedF ;
   UCHAR LastEndM ;
   UCHAR LastEndS ;
   UCHAR LastEndF ;
   BOOLEAN PlayActive ;
};
#line 2330 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CD_DEVICE_EXTENSION CD_DEVICE_EXTENSION;
#line 2331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef struct _CD_DEVICE_EXTENSION *PCD_DEVICE_EXTENSION;
#line 2332 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_READ_TOC {
   UCHAR OperationCode ;
   UCHAR Type : 2 ;
   UCHAR Reserved1 : 6 ;
   UCHAR TrackNumber ;
   UCHAR Reserved2[6] ;
   UCHAR Control ;
};
#line 2340 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_PLAY_AUDIO {
   UCHAR OperationCode ;
   UCHAR PlayMode : 3 ;
   UCHAR Reserved1 : 5 ;
   UCHAR Minute ;
   UCHAR Second ;
   UCHAR Frame ;
   UCHAR Reserved2[4] ;
   UCHAR Control ;
};
#line 2350 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_SEEK_AUDIO {
   UCHAR OperationCode ;
   UCHAR Play : 1 ;
   UCHAR Reserved1 : 7 ;
   UCHAR Minute ;
   UCHAR Second ;
   UCHAR Frame ;
   UCHAR Reserved2[4] ;
   UCHAR Control ;
};
#line 2360 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_PAUSE_AUDIO {
   UCHAR OperationCode ;
   UCHAR Reserved1[8] ;
   UCHAR Control ;
};
#line 2365 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_READ_Q_CHANNEL {
   UCHAR OperationCode ;
   UCHAR TransferSize : 5 ;
   UCHAR Reserved1 : 3 ;
   UCHAR Reserved2[7] ;
   UCHAR Control ;
};
#line 2372 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _NEC_EJECT {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 7 ;
   UCHAR Reserved2[7] ;
   UCHAR Control ;
};
#line 2379 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _NEC_CDB {
   struct _NEC_READ_TOC NEC_READ_TOC ;
   struct _NEC_READ_TOC *PNEC_READ_TOC ;
   struct _NEC_PLAY_AUDIO NEC_PLAY_AUDIO ;
   struct _NEC_PLAY_AUDIO *PNEC_PLAY_AUDIO ;
   struct _NEC_SEEK_AUDIO NEC_SEEK_AUDIO ;
   struct _NEC_SEEK_AUDIO *PNEC_SEEK_AUDIO ;
   struct _NEC_PAUSE_AUDIO NEC_PAUSE_AUDIO ;
   struct _NEC_PAUSE_AUDIO *PNEC_PAUSE_AUDIO ;
   struct _NEC_READ_Q_CHANNEL NEC_READ_Q_CHANNEL ;
   struct _NEC_READ_Q_CHANNEL *PNEC_READ_Q_CHANNEL ;
   struct _NEC_EJECT NEC_EJECT ;
   struct _NEC_EJECT *PNEC_EJECT ;
};
#line 2393 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _NEC_CDB *PNEC_CDB;
#line 2394 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_START_STOP {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2 : 7 ;
   UCHAR PCF : 1 ;
   UCHAR Reserved3 ;
   UCHAR Start : 1 ;
   UCHAR Eject : 1 ;
   UCHAR Reserved4 : 6 ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved5 : 4 ;
   UCHAR Vendor : 2 ;
};
#line 2410 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_READ_TOC {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[3] ;
   UCHAR TrackNumber ;
   UCHAR Reserved3 ;
   UCHAR AssignedLength[2] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved4 : 4 ;
   UCHAR Type : 2 ;
};
#line 2423 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_PLAY_AUDIO {
   UCHAR OperationCode ;
   UCHAR PlayMode : 4 ;
   UCHAR StopAddr : 1 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1 ;
   UCHAR Minute ;
   UCHAR Second ;
   UCHAR Frame ;
   UCHAR Reserved2[3] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR Type : 2 ;
};
#line 2438 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_SEEK_AUDIO {
   UCHAR OperationCode ;
   UCHAR PlayMode : 4 ;
   UCHAR PlayBack : 1 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1 ;
   UCHAR Minute ;
   UCHAR Second ;
   UCHAR Frame ;
   UCHAR Reserved2[3] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR Type : 2 ;
};
#line 2453 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_PAUSE_AUDIO {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 4 ;
   UCHAR Pause : 1 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[7] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR Reserved4 : 2 ;
};
#line 2464 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_AUDIO_STATUS {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 4 ;
   UCHAR Reserved2 : 1 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved3[6] ;
   UCHAR AssignedLength ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved4 : 4 ;
   UCHAR Reserved5 : 2 ;
};
#line 2476 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_READ_Q_CHANNEL {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 4 ;
   UCHAR Reserved2 : 1 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved3[6] ;
   UCHAR AssignedLength ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved4 : 4 ;
   UCHAR Reserved5 : 2 ;
};
#line 2488 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_EJECT {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Reserved1 : 4 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved2[7] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved4 : 4 ;
   UCHAR Reserved5 : 2 ;
};
#line 2499 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PNR_READ_STATUS {
   UCHAR OperationCode ;
   UCHAR Reserved1 : 4 ;
   UCHAR Lun : 3 ;
   UCHAR PageCode : 5 ;
   UCHAR PCField : 1 ;
   UCHAR Reserved2[5] ;
   UCHAR AllocationLengthMsb ;
   UCHAR AllocationLengthLsb ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR Reserved4 : 2 ;
};
#line 2513 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _PIONEER_CDB {
   struct _PNR_START_STOP PNR_START_STOP ;
   struct _PNR_START_STOP *PPNR_START_STOP ;
   struct _PNR_READ_TOC PNR_READ_TOC ;
   struct _PNR_READ_TOC *PPNR_READ_TOC ;
   struct _PNR_PLAY_AUDIO PNR_PLAY_AUDIO ;
   struct _PNR_PLAY_AUDIO *PPNR_PLAY_AUDIO ;
   struct _PNR_SEEK_AUDIO PNR_SEEK_AUDIO ;
   struct _PNR_SEEK_AUDIO *PPNR_SEEK_AUDIO ;
   struct _PNR_PAUSE_AUDIO PNR_PAUSE_AUDIO ;
   struct _PNR_PAUSE_AUDIO *PPNR_PAUSE_AUDIO ;
   struct _PNR_AUDIO_STATUS PNR_AUDIO_STATUS ;
   struct _PNR_AUDIO_STATUS *PPNR_AUDIO_STATUS ;
   struct _PNR_READ_Q_CHANNEL PNR_READ_Q_CHANNEL ;
   struct _PNR_READ_Q_CHANNEL *PPNR_READ_Q_CHANNEL ;
   struct _PNR_EJECT PNR_EJECT ;
   struct _PNR_EJECT *PPNR_EJECT ;
   struct _PNR_READ_STATUS PNR_READ_STATUS ;
   struct _PNR_READ_STATUS *PPNR_READ_STATUS ;
};
#line 2533 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _PIONEER_CDB *PPNR_CDB;
#line 2534 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _READ_DISC_INFO {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR LogicalUnitNumber : 3 ;
   UCHAR Reserved1[7] ;
   UCHAR AllocationLength[2] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved2 : 4 ;
   UCHAR VendorUniqueBits : 2 ;
};
#line 2545 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct __anonstruct_PLAY_AUDIO_127 {
   UCHAR OperationCode ;
   UCHAR Immediate : 1 ;
   UCHAR Right : 1 ;
   UCHAR Left : 1 ;
   UCHAR Reserved : 2 ;
   UCHAR Lun : 3 ;
   UCHAR StartingM ;
   UCHAR StartingS ;
   UCHAR StartingF ;
   UCHAR Reserved1[2] ;
   UCHAR EndingM ;
   UCHAR EndingS ;
   UCHAR EndingF ;
   UCHAR Reserved2 ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR VendorUniqueBits : 2 ;
};
#line 2565 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _PAUSE {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1[9] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved2 : 4 ;
   UCHAR VendorUnqiueBits : 2 ;
};
#line 2575 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _EJECT {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1[8] ;
   UCHAR Eject : 1 ;
   UCHAR Mode : 1 ;
   UCHAR Reserved2 : 6 ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved3 : 4 ;
   UCHAR VendorUnqiueBits : 2 ;
};
#line 2588 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _AUDIO_STATUS {
   UCHAR OperationCode ;
   UCHAR Reserved : 5 ;
   UCHAR Lun : 3 ;
   UCHAR Reserved1[9] ;
   UCHAR Link : 1 ;
   UCHAR Flag : 1 ;
   UCHAR Reserved2 : 4 ;
   UCHAR VendorUnqiueBits : 2 ;
};
#line 2598 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
struct _STOP_PLAY {
   UCHAR OperationCode ;
   UCHAR Reserved[11] ;
};
#line 2602 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
union _HITACHICDB {
   struct _READ_DISC_INFO READ_DISC_INFO ;
   struct _READ_DISC_INFO *PREAD_DISC_INFO ;
   struct __anonstruct_PLAY_AUDIO_127 PLAY_AUDIO ;
   struct __anonstruct_PLAY_AUDIO_127 *PPLAY_AUDIO ;
   struct _PAUSE PAUSE_AUDIO ;
   struct _PAUSE *PPAUSE_AUDIO ;
   struct _EJECT EJECT ;
   struct _EJECT *PEJECT ;
   struct _AUDIO_STATUS AUDIO_STATUS ;
   struct _AUDIO_STATUS *PAUDIO_STATUS ;
   struct _STOP_PLAY STOP_PLAY ;
   struct _STOP_PLAY *PSTOP_PLAY ;
};
#line 2616 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
typedef union _HITACHICDB *PHITACHICDB;
#line 2617
#pragma pack(push,8)
#line 2618
#pragma pack(pop)
#line 2619
struct _KAPC;
#line 2620
struct _KDPC;
#line 2621
#pragma pack(push,4)
#line 2622
#pragma pack(pop)
#line 2623
#pragma pack(push,4)
#line 2624
#pragma pack(pop)
#line 2625
#pragma pack(push,1)
#line 2626
#pragma pack(pop)
#line 2627
struct _DRIVER_OBJECT;
#line 2628
struct _DEVICE_OBJECT;
#line 2629
struct _DRIVER_OBJECT;
#line 2630
struct _FILE_OBJECT;
#line 2631
struct _IRP;
#line 2632
struct _SCSI_REQUEST_BLOCK;
#line 2633
#pragma pack(push,4)
#line 2634
#pragma pack(pop)
#line 2639
#pragma warning(push)
#line 2640
#pragma warning(disable:4035)
#line 2641
#pragma warning(pop)
#line 2643
extern void *memcpy(void * , void const   * , size_t  ) ;
#line 2644
extern int memcmp(void const   * , void const   * , size_t  ) ;
#line 2646
extern void *memset(void * , int  , size_t  ) ;
#line 2647
#pragma warning(disable:4103)
#line 2648
#pragma warning(disable:4103)
#line 2649
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) ;
#line 2654
extern NTSTATUS RtlWriteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ,
                                      ULONG ValueType , PVOID ValueData , ULONG ValueLength ) ;
#line 2660
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) ;
#line 2663
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) ;
#line 2665
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) ;
#line 2667
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) ;
#line 2670
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) ;
#line 2672
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) ;
#line 2673
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) ;
#line 2676
#pragma warning(push)
#line 2677
#pragma warning(disable:4035)
#line 2678
#pragma warning(pop)
#line 2679
extern LONG InterlockedIncrement(PLONG Addend ) ;
#line 2680
extern LONG InterlockedDecrement(PLONG Addend ) ;
#line 2681
#pragma warning(disable:4035)
#line 2682
#pragma warning(push)
#line 2683
#pragma warning(disable:4164)
#line 2684
#pragma function(_enable)
#line 2685
#pragma function(_disable)
#line 2686
#pragma warning(pop)
#line 2687
#pragma warning(disable:4103)
#line 2688
#pragma warning(disable:4103)
#line 2689
#pragma warning(disable:4103)
#line 2690
#pragma warning(disable:4103)
#line 2691
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) ;
#line 2693
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) ;
#line 2695
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) ;
#line 2697
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) ;
#line 2699
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) ;
#line 2702
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) ;
#line 2706
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 2707
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) ;
#line 2709
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
#line 2712
void ExFreePool(PVOID P ) ;
#line 2713
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) ;
#line 2714
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) ;
#line 2715
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 2718
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) ;
#line 2721
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) ;
#line 2723
void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 2724
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) ;
#line 2730
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 2732
void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 2733
extern PVOID MmLockPagableDataSection(PVOID AddressWithinSection ) ;
#line 2734
void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 2735
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 2736
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) ;
#line 2743
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;
#line 2744
#pragma warning(disable:4103)
#line 2745
#pragma warning(disable:4103)
#line 2746
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) ;
#line 2749
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 2751
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 2757
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 2766
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2768
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) ;
#line 2770
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) ;
#line 2775
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 2777
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 2778
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
#line 2779
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 2780
void IoFreeIrp(PIRP Irp ) ;
#line 2781
void IoFreeMdl(PMDL Mdl ) ;
#line 2782
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) ;
#line 2783
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) ;
#line 2801
void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 2802
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) ;
#line 2803
extern NTSTATUS IoOpenDeviceRegistryKey(PDEVICE_OBJECT DeviceObject , ULONG DevInstKeyType ,
                                        ACCESS_MASK DesiredAccess , PHANDLE DevInstRegKey ) ;
#line 2807
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) ;
#line 2811
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) ;
#line 2813
#pragma warning(disable:4200)
#line 2814
#pragma warning(default:4200)
#line 2815
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2817
void PoStartNextPowerIrp(PIRP Irp ) ;
#line 2818
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) ;
#line 2824
void ObfDereferenceObject(PVOID Object ) ;
#line 2825
NTSTATUS ZwClose(HANDLE Handle ) ;
#line 2828
#pragma warning(disable:4200)
#line 2829
#pragma warning(default:4200)
#line 2830 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int __BLAST_NONDET  ;
#line 2831 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void errorFn(void) 
{ 

  {
  ERROR: 
  goto ERROR;
}
}
#line 2839 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int s  ;
#line 2840 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int UNLOADED  ;
#line 2841 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int NP  ;
#line 2842 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int DC  ;
#line 2843 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int SKIP1  ;
#line 2844 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int SKIP2  ;
#line 2845 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int MPR1  ;
#line 2846 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int MPR3  ;
#line 2847 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int IPC  ;
#line 2848 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int pended  ;
#line 2849 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS (*compFptr)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context )  ;
#line 2850 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int compRegistered  ;
#line 2851 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int lowerDriverReturn  ;
#line 2852 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int setEventCalled  ;
#line 2853 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int customIrp  ;
#line 2854 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int routine  ;
#line 2855 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int myStatus  ;
#line 2856 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int myIrp_PendingReturned  ;
#line 2857 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void _BLAST_init(void) 
{ 

  {
#line 2861
  UNLOADED = 0;
#line 2862
  NP = 1;
#line 2863
  DC = 2;
#line 2864
  SKIP1 = 3;
#line 2865
  SKIP2 = 4;
#line 2866
  MPR1 = 5;
#line 2867
  MPR3 = 6;
#line 2868
  IPC = 7;
#line 2869
  s = UNLOADED;
#line 2870
  pended = 0;
#line 2871
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))0;
#line 2872
  compRegistered = 0;
#line 2873
  lowerDriverReturn = 0;
#line 2874
  setEventCalled = 0;
#line 2875
  customIrp = 0;
#line 2876
  return;
}
}
#line 2879
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) ;
#line 2880
NTSTATUS CdAudioReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2881
NTSTATUS CdAudioDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2882
NTSTATUS CdAudioSendToNextDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2883
BOOLEAN CdAudioIsPlayActive(PDEVICE_OBJECT DeviceObject ) ;
#line 2884
BOOLEAN NecSupportNeeded(PUCHAR InquiryData ) ;
#line 2885
NTSTATUS CdAudioNECDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2886
NTSTATUS CdAudioPioneerDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2887
NTSTATUS CdAudioDenonDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2888
NTSTATUS CdAudioHitachiSendPauseCommand(PDEVICE_OBJECT DeviceObject ) ;
#line 2889
NTSTATUS CdAudioHitachiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2890
NTSTATUS CdAudio535DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2891
NTSTATUS CdAudio435DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2892
NTSTATUS CdAudioAtapiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2893
NTSTATUS CdAudioHPCdrDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2894
void HpCdrProcessLastSession(PCDROM_TOC Toc ) ;
#line 2895
NTSTATUS HPCdrCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) ;
#line 2896
NTSTATUS CdAudioPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2897
NTSTATUS CdAudioForwardIrpSynchronous(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 2898
void CdAudioUnload(PDRIVER_OBJECT DriverObject ) ;
#line 2899
#pragma alloc_text(INIT,DriverEntry)
#line 2900
#pragma alloc_text(PAGECDNC,CdAudioNECDeviceControl)
#line 2901
#pragma alloc_text(PAGECDOT,CdAudioHitachiSendPauseCommand)
#line 2902
#pragma alloc_text(PAGECDOT,CdAudioHitachiDeviceControl)
#line 2903
#pragma alloc_text(PAGECDOT,CdAudioDenonDeviceControl)
#line 2904
#pragma alloc_text(PAGECDNC,CdAudio435DeviceControl)
#line 2905
#pragma alloc_text(PAGECDNC,CdAudio535DeviceControl)
#line 2906
#pragma alloc_text(PAGECDOT,CdAudioPioneerDeviceControl)
#line 2907
#pragma alloc_text(PAGECDNC,CdAudioPan533DeviceControl)
#line 2908
#pragma alloc_text(PAGECDOT,CdAudioAtapiDeviceControl)
#line 2909
#pragma alloc_text(PAGECDOT,CdAudioLionOpticsDeviceControl)
#line 2910
#pragma alloc_text(PAGECDOT,CdAudioHPCdrDeviceControl)
#line 2911
#pragma alloc_text(PAGECDOT,HpCdrProcessLastSession)
#line 2912
#pragma alloc_text(PAGECDOT,HPCdrCompletion)
#line 2913 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS SendSrbSynchronous(PCD_DEVICE_EXTENSION Extension , PSCSI_PASS_THROUGH Srb ,
                            PVOID Buffer , ULONG BufferLength ) 
{ ULONG ioctl ;
  KEVENT event ;
  PIRP irp ;
  IO_STATUS_BLOCK ioStatus ;
  NTSTATUS status ;

  {
#line 2922
  irp = (struct _IRP *)((void *)0);
#line 2923
  Srb->Length = (unsigned short )sizeof(SCSI_PASS_THROUGH );
#line 2924
  Srb->SenseInfoLength = (unsigned char)0;
#line 2925
  Srb->SenseInfoOffset = 0UL;
#line 2926
  if (Buffer) {
#line 2927
    Srb->DataIn = (unsigned char)1;
#line 2928
    Srb->DataTransferLength = BufferLength;
#line 2929
    Srb->DataBufferOffset = (unsigned long )Buffer;
#line 2930
    ioctl = (unsigned long )(((4 << 16) | (3 << 14)) | (1029 << 2));
  } else {
#line 2932
    Srb->DataIn = (unsigned char)0;
#line 2933
    Srb->DataTransferLength = 0UL;
#line 2934
    Srb->DataBufferOffset = 0UL;
#line 2935
    ioctl = (unsigned long )(((4 << 16) | (3 << 14)) | (1025 << 2));
  }
#line 2940
  if (! irp) {
#line 2941
    return (-1073741670L);
  } else {

  }
#line 2945
  if (status == 259L) {
    {
#line 2947
    KeWaitForSingleObject((void *)(& event), (enum _KWAIT_REASON )0, (char)0, (unsigned char)0,
                          (LARGE_INTEGER *)((void *)0));
#line 2948
    status = ioStatus.__annonCompField4.Status;
    }
  } else {

  }
#line 2953
  return (status);
}
}
#line 2956 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject ) 
{ NTSTATUS status ;
  PDEVICE_OBJECT deviceObject ;
  PCD_DEVICE_EXTENSION extension ;
  ULONG regActive ;
  HANDLE deviceParameterHandle ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;

  {
  {
#line 2966
  regActive = 255UL;
#line 2967
  status = IoOpenDeviceRegistryKey(PhysicalDeviceObject, 2UL, 131097UL, & deviceParameterHandle);
  }
#line 2969
  if (! (status >= 0L)) {
#line 2970
    regActive = 255UL;
    goto AddDeviceEndRegistry;
  } else {

  }
  {
#line 2976
  memset((void *)(& queryTable), 0, sizeof(queryTable));
#line 2977
  queryTable[0].Flags = 36UL;
#line 2978
  queryTable[0].Name = (WCHAR *)"M\000a\000p\000T\000y\000p\000e\000";
#line 2979
  queryTable[0].EntryContext = (void *)(& regActive);
#line 2980
  queryTable[0].DefaultType = 4UL;
#line 2981
  queryTable[0].DefaultData = (void *)0;
#line 2982
  queryTable[0].DefaultLength = 0UL;
#line 2983
  status = RtlQueryRegistryValues(1073741824UL, (WCHAR const   *)((WCHAR *)deviceParameterHandle),
                                  queryTable, (void *)0, (void *)0);
  }
#line 2986
  if (! (status >= 0L)) {
#line 2987
    regActive = 255UL;
  } else {
#line 2989
    if (regActive > 10UL) {
#line 2990
      regActive = 255UL;
    } else {

    }
  }
  {
#line 2996
  ZwClose(deviceParameterHandle);
  }
  AddDeviceEndRegistry: 
#line 2999
  if (regActive > 10UL) {
#line 3000
    if (regActive != 255UL) {
#line 3001
      regActive = 255UL;
    } else {

    }
  } else {

  }
#line 3008
  if (regActive == 0UL) {
#line 3009
    return (0L);
  } else {

  }
#line 3013
  if (regActive == 8UL) {
    goto switch_0_8;
  } else {
#line 3016
    if (regActive == 9UL) {
      goto switch_0_9;
    } else {
#line 3019
      if (regActive == 10UL) {
        goto switch_0_10;
      } else {
#line 3022
        if (regActive == 4UL) {
          goto switch_0_4;
        } else {
#line 3025
          if (regActive == 6UL) {
            goto switch_0_6;
          } else {
#line 3028
            if (regActive == 5UL) {
              goto switch_0_5;
            } else {
#line 3031
              if (regActive == 2UL) {
                goto switch_0_2;
              } else {
#line 3034
                if (regActive == 3UL) {
                  goto switch_0_3;
                } else {
#line 3037
                  if (regActive == 1UL) {
                    goto switch_0_1;
                  } else {
#line 3040
                    if (regActive == 7UL) {
                      goto switch_0_7;
                    } else {
#line 3043
                      if (regActive == 255UL) {
                        goto switch_0_255;
                      } else {
                        goto switch_0_default;
#line 3048
                        if (0) {
                          switch_0_8: 
                          {
#line 3051
                          MmLockPagableDataSection((void *)(& CdAudioNECDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_9: ;
                          switch_0_10: 
                          {
#line 3057
                          MmLockPagableDataSection((void *)(& CdAudioPioneerDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_4: 
                          {
#line 3062
                          MmLockPagableDataSection((void *)(& CdAudioDenonDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_6: ;
                          switch_0_5: 
                          {
#line 3068
                          MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_2: 
                          {
#line 3073
                          MmLockPagableDataSection((void *)(& CdAudio535DeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_3: 
                          {
#line 3078
                          MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_1: 
                          {
#line 3083
                          MmLockPagableDataSection((void *)(& CdAudioAtapiDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_7: 
                          {
#line 3088
                          MmLockPagableDataSection((void *)(& CdAudioHPCdrDeviceControl));
                          }
                          goto switch_0_break;
                          switch_0_255: ;
                          switch_0_default: ;
                          goto switch_0_break;
                        } else {
                          switch_0_break: ;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 3110
  status = IoCreateDevice(DriverObject, (unsigned long )sizeof(CD_DEVICE_EXTENSION ),
                          (UNICODE_STRING *)((void *)0), 2UL, 0UL, (unsigned char)0,
                          & deviceObject);
  }
#line 3113
  if (! (status >= 0L)) {
#line 3114
    return (status);
  } else {

  }
#line 3118
  deviceObject->Flags |= 16UL;
#line 3119
  if (deviceObject->Flags & 16384UL) {

  } else {
#line 3122
    deviceObject->Flags |= 8192UL;
  }
  {
#line 3125
  extension = (struct _CD_DEVICE_EXTENSION *)deviceObject->DeviceExtension;
#line 3126
  memset((void *)extension, 0, sizeof(CD_DEVICE_EXTENSION ));
#line 3127
  extension->TargetDeviceObject = IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
  }
#line 3129
  if (! extension->TargetDeviceObject) {
#line 3133
    return (-1073741810L);
  } else {

  }
#line 3139
  extension->Active = (unsigned char )regActive;
#line 3140
  extension->DeviceObject = deviceObject;
#line 3141
  extension->TargetPdo = PhysicalDeviceObject;
#line 3142
  deviceObject->Flags &= 4294967167UL;
#line 3144
  return (0L);
}
}
#line 3147 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioSignalCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT Event ) 
{ 

  {
  {
#line 3152
  KeSetEvent(Event, 0L, (unsigned char)0);
  }
#line 3154
  return (-1073741802L);
}
}
#line 3157 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS status ;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb ;
  PUCHAR inquiryDataPtr ;
  UCHAR attempt ;
  PVOID tmp ;
  UCHAR tmp___0 ;
  BOOLEAN tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  HANDLE deviceParameterHandle ;
  ULONG keyValue ;

  {
  {
#line 3186
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3187
  status = CdAudioForwardIrpSynchronous(DeviceObject, Irp);
  }
#line 3189
  if (! (status >= 0L)) {
#line 3190
    return (status);
  } else {

  }
#line 3194
  deviceExtension->Paused = (unsigned char)0;
#line 3195
  deviceExtension->PausedM = (unsigned char)0;
#line 3196
  deviceExtension->PausedS = (unsigned char)0;
#line 3197
  deviceExtension->PausedF = (unsigned char)0;
#line 3198
  deviceExtension->LastEndM = (unsigned char)0;
#line 3199
  deviceExtension->LastEndS = (unsigned char)0;
#line 3200
  deviceExtension->LastEndF = (unsigned char)0;
#line 3201
  if ((int )deviceExtension->Active == 255) {
    {
#line 3203
    cdb = (union _CDB *)(srb.Cdb);
#line 3204
    inquiryDataPtr = (UCHAR *)((void *)0);
#line 3205
    attempt = (unsigned char)0;
#line 3206
    tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )4, 36UL, 541156419UL);
#line 3207
    inquiryDataPtr = (UCHAR *)tmp;
    }
#line 3209
    if (! inquiryDataPtr) {
#line 3210
      deviceExtension->Active = (unsigned char)0;
#line 3211
      return (0L);
    } else {

    }
#line 3215
    status = -1073741823L;
    {
#line 3217
    while (1) {
      while_0_continue: /* CIL Label */ ;

#line 3219
      if (! (status >= 0L)) {
#line 3220
        tmp___0 = attempt;
#line 3221
        attempt = (unsigned char )((int )attempt + 1);
#line 3222
        if ((int )tmp___0 < 4) {

        } else {
          goto while_1_break;
        }
      } else {
        goto while_1_break;
      }
      {
#line 3231
      memset((void *)(& srb), 0, sizeof(SCSI_PASS_THROUGH ));
#line 3232
      memset((void *)inquiryDataPtr, 0, 36U);
#line 3233
      cdb->CDB6INQUIRY.OperationCode = (unsigned char)18;
#line 3234
      cdb->CDB6INQUIRY.AllocationLength = (unsigned char)36;
#line 3235
      srb.CdbLength = (unsigned char)6;
#line 3236
      srb.TimeOutValue = 10UL;
#line 3237
      status = SendSrbSynchronous(deviceExtension, & srb, (void *)inquiryDataPtr,
                                  36UL);
      }
    }
    while_0_break: /* CIL Label */ ;
    }
    while_1_break: ;
#line 3242
    if (! (status >= 0L)) {
#line 3245
      deviceExtension->Active = (unsigned char)0;
#line 3247
      return (0L);
    } else {

    }
    {
#line 3252
    deviceExtension->Active = (unsigned char)0;
#line 3253
    tmp___2 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"NEC     ",
                     8U);
    }
#line 3255
    if (tmp___2) {

    } else {
      {
#line 3259
      tmp___1 = NecSupportNeeded(inquiryDataPtr);
      }
#line 3261
      if (tmp___1) {
        {
#line 3263
        MmLockPagableDataSection((void *)(& CdAudioNECDeviceControl));
#line 3264
        deviceExtension->Active = (unsigned char)8;
        }
      } else {

      }
    }
    {
#line 3271
    tmp___3 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"PIONEER ",
                     8U);
    }
#line 3273
    if (tmp___3) {

    } else {
      {
#line 3277
      tmp___4 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"CD-ROM DRM-600",
                       15U);
      }
#line 3279
      if (tmp___4) {

      } else {
        {
#line 3283
        MmLockPagableDataSection((void *)(& CdAudioPioneerDeviceControl));
#line 3284
        deviceExtension->Active = (unsigned char)9;
        }
      }
    }
#line 3288
    if ((int )*(inquiryDataPtr + 8) == 68) {
#line 3289
      if ((int )*(inquiryDataPtr + 9) == 69) {
#line 3290
        if ((int )*(inquiryDataPtr + 10) == 78) {
#line 3291
          if ((int )*(inquiryDataPtr + 16) == 68) {
#line 3292
            if ((int )*(inquiryDataPtr + 17) == 82) {
#line 3293
              if ((int )*(inquiryDataPtr + 18) == 68) {
#line 3294
                if ((int )*(inquiryDataPtr + 20) == 50) {
#line 3295
                  if ((int )*(inquiryDataPtr + 21) == 53) {
#line 3296
                    if ((int )*(inquiryDataPtr + 22) == 88) {
                      {
#line 3298
                      MmLockPagableDataSection((void *)(& CdAudioDenonDeviceControl));
#line 3299
                      deviceExtension->Active = (unsigned char)4;
                      }
                    } else {

                    }
                  } else {

                  }
                } else {

                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
    } else {

    }
    {
#line 3329
    tmp___5 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"CHINON",
                     6U);
    }
#line 3331
    if (tmp___5) {

    } else {
#line 3334
      if ((int )*(inquiryDataPtr + 27) == 53) {
#line 3335
        if ((int )*(inquiryDataPtr + 28) == 51) {
#line 3336
          if ((int )*(inquiryDataPtr + 29) == 53) {
#line 3337
            if ((int )*(inquiryDataPtr + 32) == 81) {
              {
#line 3339
              MmLockPagableDataSection((void *)(& CdAudio535DeviceControl));
#line 3340
              deviceExtension->Active = (unsigned char)2;
              }
            } else {

            }
          } else {

          }
        } else {

        }
      } else {

      }
#line 3354
      if ((int )*(inquiryDataPtr + 27) == 52) {
#line 3355
        if ((int )*(inquiryDataPtr + 28) == 51) {
#line 3356
          if ((int )*(inquiryDataPtr + 29) == 53) {
            goto _L;
          } else {
#line 3359
            if ((int )*(inquiryDataPtr + 29) == 49) {
              _L: 
#line 3361
              if ((int )*(inquiryDataPtr + 32) == 77) {
                {
#line 3363
                MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
#line 3364
                deviceExtension->Active = (unsigned char)3;
                }
              } else {
#line 3367
                if ((int )*(inquiryDataPtr + 32) == 78) {
                  {
#line 3369
                  MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
#line 3370
                  deviceExtension->Active = (unsigned char)3;
                  }
                } else {
#line 3373
                  if ((int )*(inquiryDataPtr + 32) == 83) {
                    {
#line 3375
                    MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
#line 3376
                    deviceExtension->Active = (unsigned char)3;
                    }
                  } else {
#line 3379
                    if ((int )*(inquiryDataPtr + 32) == 85) {
                      {
#line 3381
                      MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
#line 3382
                      deviceExtension->Active = (unsigned char)3;
                      }
                    } else {
#line 3385
                      if ((int )*(inquiryDataPtr + 32) == 72) {
                        {
#line 3387
                        MmLockPagableDataSection((void *)(& CdAudio435DeviceControl));
#line 3388
                        deviceExtension->Active = (unsigned char)3;
                        }
                      } else {

                      }
                    }
                  }
                }
              }
            } else {

            }
          }
        } else {

        }
      } else {

      }
    }
    {
#line 3409
    tmp___6 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"HITACHI ",
                     8U);
    }
#line 3411
    if (tmp___6) {

    } else {
      {
#line 3415
      tmp___7 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"CDR-3650/1650S  ",
                       16U);
      }
#line 3417
      if (tmp___7) {
        {
#line 3419
        tmp___8 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"CDR-1750S       ",
                         16U);
        }
#line 3421
        if (tmp___8) {

        } else {
          {
#line 3425
          MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
#line 3426
          deviceExtension->Active = (unsigned char)6;
          }
        }
      } else {
        {
#line 3431
        MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
#line 3432
        deviceExtension->Active = (unsigned char)6;
        }
      }
    }
    {
#line 3437
    tmp___9 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"WEARNES ",
                     8U);
    }
#line 3439
    if (tmp___9) {
      _L___0: 
      {
#line 3442
      tmp___11 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"OTI     ",
                        8U);
      }
#line 3444
      if (tmp___11) {

      } else {
        {
#line 3448
        tmp___12 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"DOLPHIN ",
                          8U);
        }
#line 3450
        if (tmp___12) {

        } else {
          {
#line 3454
          MmLockPagableDataSection((void *)(& CdAudioAtapiDeviceControl));
#line 3455
          deviceExtension->Active = (unsigned char)1;
#line 3456
          *(inquiryDataPtr + 25) = (unsigned char)0;
          }
        }
      }
    } else {
      {
#line 3462
      tmp___10 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"RUB",
                        3U);
      }
#line 3464
      if (tmp___10) {
        goto _L___0;
      } else {
        {
#line 3468
        MmLockPagableDataSection((void *)(& CdAudioAtapiDeviceControl));
#line 3469
        deviceExtension->Active = (unsigned char)1;
#line 3470
        *(inquiryDataPtr + 25) = (unsigned char)0;
        }
      }
    }
    {
#line 3475
    tmp___13 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"FUJITSU ",
                      8U);
    }
#line 3477
    if (tmp___13) {

    } else {
#line 3480
      if ((int )*(inquiryDataPtr + 16) == 67) {
#line 3481
        if ((int )*(inquiryDataPtr + 17) == 68) {
#line 3482
          if ((int )*(inquiryDataPtr + 18) == 82) {
#line 3483
            if ((int )*(inquiryDataPtr + 20) == 51) {
#line 3484
              if ((int )*(inquiryDataPtr + 21) == 54) {
#line 3485
                if ((int )*(inquiryDataPtr + 22) == 53) {
#line 3486
                  if ((int )*(inquiryDataPtr + 23) == 48) {
                    {
#line 3488
                    MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
#line 3489
                    deviceExtension->Active = (unsigned char)6;
#line 3490
                    *(inquiryDataPtr + 25) = (unsigned char)0;
                    }
                  } else {
                    goto _L___6;
                  }
                } else {
                  goto _L___6;
                }
              } else {
                goto _L___6;
              }
            } else {
              goto _L___6;
            }
          } else {
            goto _L___6;
          }
        } else {
          goto _L___6;
        }
      } else {
        _L___6: 
#line 3512
        if ((int )*(inquiryDataPtr + 16) == 70) {
#line 3513
          if ((int )*(inquiryDataPtr + 17) == 77) {
#line 3514
            if ((int )*(inquiryDataPtr + 18) == 67) {
#line 3515
              if ((int )*(inquiryDataPtr + 21) == 49) {
#line 3516
                if ((int )*(inquiryDataPtr + 22) == 48) {
#line 3517
                  if ((int )*(inquiryDataPtr + 23) == 49) {
                    {
#line 3519
                    MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
#line 3520
                    deviceExtension->Active = (unsigned char)5;
#line 3521
                    *(inquiryDataPtr + 25) = (unsigned char)0;
                    }
                  } else {
#line 3524
                    if ((int )*(inquiryDataPtr + 23) == 50) {
                      {
#line 3526
                      MmLockPagableDataSection((void *)(& CdAudioHitachiDeviceControl));
#line 3527
                      deviceExtension->Active = (unsigned char)5;
#line 3528
                      *(inquiryDataPtr + 25) = (unsigned char)0;
                      }
                    } else {

                    }
                  }
                } else {

                }
              } else {

              }
            } else {

            }
          } else {

          }
        } else {

        }
      }
    }
    {
#line 3552
    tmp___14 = memcmp((void const   *)(inquiryDataPtr + 8), (void const   *)"HP      ",
                      8U);
    }
#line 3554
    if (tmp___14) {

    } else {
      {
#line 3558
      tmp___15 = memcmp((void const   *)(inquiryDataPtr + 16), (void const   *)"C4324/C4325",
                        11U);
      }
#line 3560
      if (tmp___15) {

      } else {
        {
#line 3564
        MmLockPagableDataSection((void *)(& CdAudioHPCdrDeviceControl));
#line 3565
        deviceExtension->Active = (unsigned char)7;
        }
      }
    }
  } else {

  }
  {
#line 3576
  keyValue = (unsigned long )deviceExtension->Active;
#line 3577
  status = IoOpenDeviceRegistryKey(deviceExtension->TargetPdo, 2UL, 131078UL, & deviceParameterHandle);
  }
#line 3579
  if (! (status >= 0L)) {
#line 3580
    return (0L);
  } else {

  }
  {
#line 3585
  status = RtlWriteRegistryValue(1073741824UL, (WCHAR const   *)((WCHAR *)deviceParameterHandle),
                                 (WCHAR const   *)"M\000a\000p\000T\000y\000p\000e\000",
                                 4UL, (void *)(& keyValue), (unsigned long )sizeof(keyValue));
  }
#line 3588
  if (! (status >= 0L)) {

  } else {

  }
  {
#line 3594
  ZwClose(deviceParameterHandle);
  }
#line 3596
  return (0L);
}
}
#line 3599 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION irpSp ;
  NTSTATUS status ;
  BOOLEAN setPagable ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 3608
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3609
  status = -1073741637L;
#line 3610
  if ((int )irpSp->MinorFunction == 0) {
    goto switch_2_0;
  } else {
#line 3613
    if ((int )irpSp->MinorFunction == 22) {
      goto switch_2_22;
    } else {
      goto switch_2_default;
#line 3618
      if (0) {
        switch_2_0: 
        {
#line 3621
        status = CdAudioStartDevice(DeviceObject, Irp);
#line 3622
        Irp->IoStatus.__annonCompField4.Status = status;
#line 3623
        myStatus = (int )status;
#line 3624
        IofCompleteRequest(Irp, (char)0);
        }
#line 3626
        return (status);
        switch_2_22: ;
#line 3628
        if ((int )irpSp->Parameters.UsageNotification.Type != 1) {
          {
#line 3630
          tmp = CdAudioSendToNextDriver(DeviceObject, Irp);
          }
#line 3632
          return (tmp);
        } else {

        }
        {
#line 3637
        deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3638
        status = KeWaitForSingleObject((void *)(& deviceExtension->PagingPathCountEvent),
                                       (enum _KWAIT_REASON )0, (char)0, (unsigned char)0,
                                       (LARGE_INTEGER *)((void *)0));
#line 3640
        setPagable = (unsigned char)0;
        }
#line 3642
        if (! irpSp->Parameters.UsageNotification.InPath) {
#line 3643
          if (deviceExtension->PagingPathCount == 1UL) {
#line 3644
            if (DeviceObject->Flags & 16384UL) {

            } else {
#line 3647
              DeviceObject->Flags |= 8192UL;
#line 3648
              setPagable = (unsigned char)1;
            }
          } else {

          }
        } else {

        }
        {
#line 3657
        status = CdAudioForwardIrpSynchronous(DeviceObject, Irp);
        }
#line 3659
        if (status >= 0L) {
#line 3660
          if (irpSp->Parameters.UsageNotification.InPath) {
            {
#line 3662
            InterlockedIncrement((LONG *)(& deviceExtension->PagingPathCount));
            }
          } else {
            {
#line 3666
            InterlockedDecrement((LONG *)(& deviceExtension->PagingPathCount));
            }
          }
#line 3669
          if (irpSp->Parameters.UsageNotification.InPath) {
#line 3670
            if (deviceExtension->PagingPathCount == 1UL) {
#line 3671
              DeviceObject->Flags &= 4294959103UL;
            } else {

            }
          } else {

          }
        } else {
#line 3679
          if ((int )setPagable == 1) {
#line 3680
            DeviceObject->Flags &= 4294959103UL;
#line 3681
            setPagable = (unsigned char)0;
          } else {

          }
        }
        {
#line 3687
        KeSetEvent(& deviceExtension->PagingPathCountEvent, 0L, (unsigned char)0);
#line 3688
        IofCompleteRequest(Irp, (char)0);
        }
#line 3690
        return (status);
        goto switch_2_break;
        switch_2_default: 
        {
#line 3694
        tmp___0 = CdAudioSendToNextDriver(DeviceObject, Irp);
        }
#line 3696
        return (tmp___0);
      } else {
        switch_2_break: ;
      }
    }
  }
#line 3703
  return (0L);
}
}
#line 3706 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) 
{ ULONG i ;

  {
#line 3710
  DriverObject->MajorFunction[i] = & CdAudioSendToNextDriver;
#line 3711
  DriverObject->MajorFunction[3] = & CdAudioReadWrite;
#line 3712
  DriverObject->MajorFunction[4] = & CdAudioReadWrite;
#line 3713
  DriverObject->MajorFunction[14] = & CdAudioDeviceControl;
#line 3714
  DriverObject->MajorFunction[27] = & CdAudioPnp;
#line 3715
  DriverObject->MajorFunction[22] = & CdAudioPower;
#line 3716
  (DriverObject->DriverExtension)->AddDevice = & CdAudioAddDevice;
#line 3717
  DriverObject->DriverUnload = & CdAudioUnload;
#line 3718
  return (0L);
}
}
#line 3721 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
BOOLEAN NecSupportNeeded(PUCHAR InquiryData ) 
{ PINQUIRYDATA inquiryData ;
  ULONG i ;
  PUCHAR badDriveList[12] ;
  SIZE_T tmp ;

  {
  {
#line 3729
  inquiryData = (struct _INQUIRYDATA *)InquiryData;
#line 3730
  badDriveList[0] = (UCHAR *)"CD-ROM DRIVE:80 ";
#line 3731
  badDriveList[1] = (UCHAR *)"CD-ROM DRIVE:82 ";
#line 3732
  badDriveList[2] = (UCHAR *)"CD-ROM DRIVE:83 ";
#line 3733
  badDriveList[3] = (UCHAR *)"CD-ROM DRIVE:84 ";
#line 3734
  badDriveList[4] = (UCHAR *)"CD-ROM DRIVE:841";
#line 3735
  badDriveList[5] = (UCHAR *)"CD-ROM DRIVE:38 ";
#line 3736
  badDriveList[6] = (UCHAR *)"CD-ROM DRIVE 4 M";
#line 3737
  badDriveList[7] = (UCHAR *)"CD-ROM DRIVE:500";
#line 3738
  badDriveList[8] = (UCHAR *)"CD-ROM DRIVE:400";
#line 3739
  badDriveList[9] = (UCHAR *)"CD-ROM DRIVE:401";
#line 3740
  badDriveList[10] = (UCHAR *)"CD-ROM DRIVE:501";
#line 3741
  badDriveList[11] = (UCHAR *)"CD-ROM DRIVE:900";
#line 3742
  tmp = RtlCompareMemory((void const   *)(inquiryData->ProductId), (void const   *)badDriveList[i],
                         16UL);
  }
#line 3744
  if (tmp == 16UL) {
#line 3745
    return ((unsigned char)1);
  } else {

  }
#line 3749
  return ((unsigned char)0);
}
}
#line 3752 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS tmp ;

  {
#line 3757
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3758
  if (deviceExtension->PlayActive) {
    {
#line 3760
    Irp->IoStatus.__annonCompField4.Status = -2147483631L;
#line 3761
    myStatus = -2147483631;
#line 3762
    IofCompleteRequest(Irp, (char)0);
    }
#line 3764
    return (-2147483631L);
  } else {

  }
  {
#line 3769
  tmp = CdAudioSendToNextDriver(DeviceObject, Irp);
  }
#line 3771
  return (tmp);
}
}
#line 3774 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS status ;

  {
#line 3779
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3780
  if ((int )deviceExtension->Active == 2) {
    goto switch_3_2;
  } else {
#line 3783
    if ((int )deviceExtension->Active == 3) {
      goto switch_3_3;
    } else {
#line 3786
      if ((int )deviceExtension->Active == 1) {
        goto switch_3_1;
      } else {
#line 3789
        if ((int )deviceExtension->Active == 7) {
          goto switch_3_7;
        } else {
          goto switch_3_default;
#line 3794
          if (0) {
            switch_3_2: 
            {
#line 3797
            status = CdAudio535DeviceControl(DeviceObject, Irp);
            }
            goto switch_3_break;
            switch_3_3: 
            {
#line 3802
            status = CdAudio435DeviceControl(DeviceObject, Irp);
            }
            goto switch_3_break;
            switch_3_1: 
            {
#line 3807
            status = CdAudioAtapiDeviceControl(DeviceObject, Irp);
            }
            goto switch_3_break;
            switch_3_7: 
            {
#line 3812
            status = CdAudioHPCdrDeviceControl(DeviceObject, Irp);
            }
            goto switch_3_break;
            switch_3_default: 
            {
#line 3817
            deviceExtension->Active = (unsigned char)0;
#line 3818
            status = CdAudioSendToNextDriver(DeviceObject, Irp);
            }
          } else {
            switch_3_break: ;
          }
        }
      }
    }
  }
#line 3828
  return (status);
}
}
#line 3831 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioSendToNextDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS tmp ;

  {
#line 3836
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3837
  if (s == NP) {
#line 3838
    s = SKIP1;
  } else {
    {
#line 3841
    errorFn();
    }
  }
  {
#line 3845
  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 3846
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 3847
  tmp = IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
  }
#line 3849
  return (tmp);
}
}
#line 3852 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
BOOLEAN CdAudioIsPlayActive(PDEVICE_OBJECT DeviceObject ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  PIRP irp_CdAudioIsPlayActive ;
  IO_STATUS_BLOCK ioStatus ;
  KEVENT event ;
  NTSTATUS status ;
  PSUB_Q_CURRENT_POSITION currentBuffer ;
  BOOLEAN returnValue ;
  PVOID tmp ;

  {
#line 3863
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3864
  if (! deviceExtension->PlayActive) {
#line 3865
    return ((unsigned char)0);
  } else {

  }
  {
#line 3870
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(SUB_Q_CURRENT_POSITION ),
                              541156419UL);
#line 3871
  currentBuffer = (struct _SUB_Q_CURRENT_POSITION *)tmp;
  }
#line 3873
  if ((unsigned int )currentBuffer == (unsigned int )((void *)0)) {
#line 3874
    return ((unsigned char)0);
  } else {

  }
#line 3879
  ((struct _CDROM_SUB_Q_DATA_FORMAT *)currentBuffer)->Format = (unsigned char)1;
#line 3880
  ((struct _CDROM_SUB_Q_DATA_FORMAT *)currentBuffer)->Track = (unsigned char)0;
#line 3883
  if ((unsigned int )irp_CdAudioIsPlayActive == (unsigned int )((void *)0)) {
#line 3887
    return ((unsigned char)0);
  } else {

  }
#line 3891
  if (status == 259L) {
    {
#line 3893
    KeWaitForSingleObject((void *)(& event), (enum _KWAIT_REASON )5, (char)0, (unsigned char)0,
                          (LARGE_INTEGER *)((void *)0));
#line 3894
    status = ioStatus.__annonCompField4.Status;
    }
  } else {

  }
#line 3899
  if (! (status >= 0L)) {
#line 3903
    return ((unsigned char)0);
  } else {

  }
#line 3907
  if ((int )currentBuffer->Header.AudioStatus == 17) {
#line 3908
    returnValue = (unsigned char)1;
  } else {
#line 3910
    returnValue = (unsigned char)0;
#line 3911
    deviceExtension->PlayActive = (unsigned char)0;
  }
#line 3916
  return (returnValue);
}
}
#line 3919 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioNECDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PNEC_CDB cdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG bytesTransfered ;
  PUCHAR Toc ;
  ULONG retryCount ;
  ULONG address ;
  LARGE_INTEGER delay ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  BOOLEAN tmp___1 ;
  PVOID tmp___2 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  NTSTATUS tmp___3 ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr ;
  PVOID tmp___4 ;
  ULONG tmp___5 ;
  NTSTATUS tmp___6 ;

  {
#line 3950
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 3951
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 3952
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 3953
  cdb = (union _NEC_CDB *)(srb.Cdb);
#line 3954
  retryCount = 0UL;
  NECRestart: 
  {
#line 3957
  memset((void *)cdb, 0, 12U);
  }
#line 3959
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (14 << 2))) {
    goto switch_4_exp_0;
  } else {
#line 3962
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
      goto switch_4_exp_1;
    } else {
#line 3965
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (2 << 2))) {
        goto switch_4_exp_2;
      } else {
#line 3968
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
          goto switch_4_exp_3;
        } else {
#line 3971
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
            goto switch_4_exp_4;
          } else {
#line 3974
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (3 << 2))) {
              goto switch_4_exp_5;
            } else {
#line 3977
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (4 << 2))) {
                goto switch_4_exp_6;
              } else {
#line 3980
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
                  goto switch_4_exp_7;
                } else {
#line 3983
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
                    goto switch_4_exp_8;
                  } else {
#line 3986
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                      goto switch_4_exp_9;
                    } else {
#line 3989
                      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                        goto switch_4_exp_10;
                      } else {
#line 3992
                        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                          goto switch_4_exp_11;
                        } else {
#line 3995
                          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                            goto switch_4_exp_12;
                          } else {
                            goto switch_4_default;
#line 4000
                            if (0) {
                              switch_4_exp_0: ;
#line 4002
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[1]))) {
#line 4003
                                status = -1073741789L;
#line 4004
                                Irp->IoStatus.Information = 0UL;
                                goto switch_4_break;
                              } else {

                              }
                              {
#line 4010
                              tmp = CdAudioIsPlayActive(DeviceObject);
                              }
#line 4012
                              if (tmp) {
#line 4013
                                Irp->IoStatus.Information = 0UL;
#line 4014
                                status = -2147483631L;
                                goto switch_4_break;
                              } else {

                              }
                              {
#line 4020
                              tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              1022UL, 541156419UL);
#line 4021
                              Toc = (UCHAR *)tmp___0;
                              }
#line 4023
                              if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 4024
                                status = -1073741670L;
#line 4025
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 4031
                              memset((void *)Toc, 0, 1022U);
#line 4032
                              srb.CdbLength = (unsigned char)10;
#line 4033
                              cdb->NEC_READ_TOC.OperationCode = (unsigned char)222;
#line 4034
                              cdb->NEC_READ_TOC.Type = (unsigned char)3;
#line 4035
                              cdb->NEC_READ_TOC.TrackNumber = (unsigned char)176;
#line 4036
                              srb.TimeOutValue = 10UL;
#line 4037
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)Toc, 1022UL);
                              }
#line 4040
                              if (! (status >= 0L)) {
#line 4041
                                if (status != -1073741764L) {
#line 4044
                                  Irp->IoStatus.Information = 0UL;
                                  goto SetStatusAndReturn;
                                } else {
#line 4048
                                  status = 0L;
                                }
                              } else {
#line 4051
                                status = 0L;
                              }
                              {
#line 4054
                              bytesTransfered = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[1]));
#line 4055
                              Irp->IoStatus.Information = bytesTransfered;
#line 4056
                              memset((void *)cdaudioDataOut, 0, (unsigned int )bytesTransfered);
#line 4057
                              cdaudioDataOut->Length[0] = (unsigned char )((bytesTransfered - 2UL) >> 8);
#line 4058
                              cdaudioDataOut->Length[1] = (unsigned char )((bytesTransfered - 2UL) & 255UL);
                              }
#line 4060
                              if (*((ULONG *)(Toc + 14)) == 0UL) {
                                goto switch_4_break;
                              } else {

                              }
#line 4069
                              cdaudioDataOut->FirstTrack = (unsigned char)1;
#line 4070
                              cdaudioDataOut->LastTrack = (unsigned char)2;
#line 4071
                              cdaudioDataOut->TrackData[0].Reserved = (unsigned char)0;
#line 4072
                              cdaudioDataOut->TrackData[0].Control = (unsigned char )((((int )*(Toc + 2) & 15) << 4) | ((int )*(Toc + 2) >> 4));
#line 4073
                              cdaudioDataOut->TrackData[0].TrackNumber = (unsigned char)1;
#line 4074
                              cdaudioDataOut->TrackData[0].Reserved1 = (unsigned char)0;
#line 4075
                              address = (unsigned long )((((((int )*(Toc + 15) & 240) >> 4) * 10 + ((int )*(Toc + 15) & 15)) * 60 + ((((int )*(Toc + 16) & 240) >> 4) * 10 + ((int )*(Toc + 16) & 15))) * 75 + ((((int )*(Toc + 17) & 240) >> 4) * 10 + ((int )*(Toc + 17) & 15)));
#line 4076
                              cdaudioDataOut->TrackData[0].Address[0] = (unsigned char )(address >> 24);
#line 4077
                              cdaudioDataOut->TrackData[0].Address[1] = (unsigned char )(address >> 16);
#line 4078
                              cdaudioDataOut->TrackData[0].Address[2] = (unsigned char )(address >> 8);
#line 4079
                              cdaudioDataOut->TrackData[0].Address[3] = (unsigned char )address;
                              goto switch_4_break;
                              switch_4_exp_1: 
                              {
#line 4085
                              tmp___1 = CdAudioIsPlayActive(DeviceObject);
                              }
#line 4087
                              if (tmp___1) {
#line 4088
                                status = -2147483631L;
#line 4089
                                Irp->IoStatus.Information = 0UL;
                                goto switch_4_break;
                              } else {

                              }
#line 4094
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 4095
                                status = -1073741789L;
#line 4096
                                Irp->IoStatus.Information = 0UL;
                                goto switch_4_break;
                              } else {

                              }
                              {
#line 4102
                              tmp___2 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              1022UL, 541156419UL);
#line 4103
                              Toc = (UCHAR *)tmp___2;
                              }
#line 4105
                              if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 4106
                                status = -1073741670L;
#line 4107
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 4113
                              memset((void *)Toc, 0, 1022U);
#line 4114
                              srb.CdbLength = (unsigned char)10;
#line 4115
                              cdb->NEC_READ_TOC.OperationCode = (unsigned char)222;
#line 4116
                              cdb->NEC_READ_TOC.Type = (unsigned char)3;
#line 4117
                              srb.TimeOutValue = 10UL;
#line 4118
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)Toc, 1022UL);
                              }
#line 4121
                              if (! (status >= 0L)) {
#line 4122
                                if (status != -1073741764L) {
#line 4123
                                  if (status != -1073741764L) {
#line 4125
                                    Irp->IoStatus.Information = 0UL;
                                    goto SetStatusAndReturn;
                                  } else {

                                  }
                                } else {
#line 4133
                                  status = 0L;
                                }
                              } else {
#line 4136
                                status = 0L;
                              }
#line 4138
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > (unsigned long )sizeof(CDROM_TOC )) {
#line 4139
                                bytesTransfered = (unsigned long )sizeof(CDROM_TOC );
                              } else {
#line 4141
                                bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                              }
#line 4143
                              cdaudioDataOut->FirstTrack = (unsigned char )((((int )*(Toc + 9) & 240) >> 4) * 10 + ((int )*(Toc + 9) & 15));
#line 4144
                              cdaudioDataOut->LastTrack = (unsigned char )((((int )*(Toc + 19) & 240) >> 4) * 10 + ((int )*(Toc + 19) & 15));
#line 4145
                              tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 4146
                              dataLength = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[tracksOnCd])) - 2UL;
#line 4147
                              cdaudioDataOut->Length[0] = (unsigned char )(dataLength >> 8);
#line 4148
                              cdaudioDataOut->Length[1] = (unsigned char )(dataLength & 255UL);
#line 4149
                              tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 4150
                              tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 4151
                              if (tracksInBuffer < tracksOnCd) {
#line 4152
                                tracksToReturn = tracksInBuffer;
                              } else {
#line 4154
                                tracksToReturn = tracksOnCd;
                              }
#line 4156
                              i = 0UL;
                              {
#line 4158
                              while (1) {
                                while_1_continue: /* CIL Label */ ;

#line 4160
                                if (i < tracksToReturn) {

                                } else {
                                  goto while_5_break;
                                }
#line 4165
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 4166
                                cdaudioDataOut->TrackData[i].Control = (unsigned char )((((int )*(Toc + (i * 10UL + 32UL)) & 15) << 4) | ((int )*(Toc + (i * 10UL + 32UL)) >> 4));
#line 4167
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )(i + (unsigned long )cdaudioDataOut->FirstTrack);
#line 4168
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 4169
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 4170
                                cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + (i * 10UL + 39UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 10UL + 39UL)) & 15));
#line 4171
                                cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + (i * 10UL + 40UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 10UL + 40UL)) & 15));
#line 4172
                                cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + (i * 10UL + 41UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 10UL + 41UL)) & 15));
#line 4173
                                i += 1UL;
                              }
                              while_1_break: /* CIL Label */ ;
                              }
                              while_5_break: ;
#line 4177
                              if (tracksInBuffer > tracksOnCd) {
#line 4178
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 4179
                                cdaudioDataOut->TrackData[i].Control = (unsigned char)16;
#line 4180
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char)170;
#line 4181
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 4182
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 4183
                                cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + 29) & 240) >> 4) * 10 + ((int )*(Toc + 29) & 15));
#line 4184
                                cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + 30) & 240) >> 4) * 10 + ((int )*(Toc + 30) & 15));
#line 4185
                                cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + 31) & 240) >> 4) * 10 + ((int )*(Toc + 31) & 15));
#line 4186
                                i += 1UL;
                              } else {

                              }
#line 4191
                              Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
                              goto switch_4_break;
                              switch_4_exp_2: 
                              {
#line 4197
                              deviceExtension->PlayActive = (unsigned char)0;
#line 4198
                              tmp___3 = CdAudioSendToNextDriver(DeviceObject, Irp);
                              }
#line 4200
                              return (tmp___3);
                              goto switch_4_break;
                              switch_4_exp_3: 
#line 4203
                              inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 4204
                              if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 4205
                                status = -1073741820L;
#line 4206
                                Irp->IoStatus.Information = 0UL;
                                goto switch_4_break;
                              } else {

                              }
                              {
#line 4212
                              srb.CdbLength = (unsigned char)10;
#line 4213
                              srb.TimeOutValue = 10UL;
#line 4214
                              cdb->NEC_PLAY_AUDIO.OperationCode = (unsigned char)216;
#line 4215
                              cdb->NEC_PLAY_AUDIO.PlayMode = (unsigned char)1;
#line 4216
                              cdb->NEC_PLAY_AUDIO.Minute = (unsigned char )(((int )inputBuffer->StartingM / 10 << 4) + (int )inputBuffer->StartingM % 10);
#line 4217
                              cdb->NEC_PLAY_AUDIO.Second = (unsigned char )(((int )inputBuffer->StartingS / 10 << 4) + (int )inputBuffer->StartingS % 10);
#line 4218
                              cdb->NEC_PLAY_AUDIO.Frame = (unsigned char )(((int )inputBuffer->StartingF / 10 << 4) + (int )inputBuffer->StartingF % 10);
#line 4219
                              cdb->NEC_PLAY_AUDIO.Control = (unsigned char)64;
#line 4220
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 4223
                              if (status >= 0L) {
                                {
#line 4225
                                deviceExtension->PlayActive = (unsigned char)1;
#line 4226
                                memset((void *)cdb, 0, 12U);
#line 4227
                                cdb->NEC_PLAY_AUDIO.OperationCode = (unsigned char)217;
#line 4228
                                cdb->NEC_PLAY_AUDIO.PlayMode = (unsigned char)3;
#line 4229
                                cdb->NEC_PLAY_AUDIO.Minute = (unsigned char )(((int )inputBuffer->EndingM / 10 << 4) + (int )inputBuffer->EndingM % 10);
#line 4230
                                cdb->NEC_PLAY_AUDIO.Second = (unsigned char )(((int )inputBuffer->EndingS / 10 << 4) + (int )inputBuffer->EndingS % 10);
#line 4231
                                cdb->NEC_PLAY_AUDIO.Frame = (unsigned char )(((int )inputBuffer->EndingF / 10 << 4) + (int )inputBuffer->EndingF % 10);
#line 4232
                                cdb->NEC_PLAY_AUDIO.Control = (unsigned char)64;
#line 4233
                                status = SendSrbSynchronous(deviceExtension, & srb,
                                                            (void *)0, 0UL);
                                }
                              } else {

                              }
                              goto switch_4_break;
                              switch_4_exp_4: 
#line 4241
                              inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 4242
                              if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 4243
                                status = -1073741820L;
#line 4244
                                Irp->IoStatus.Information = 0UL;
                                goto switch_4_break;
                              } else {

                              }
                              {
#line 4250
                              srb.CdbLength = (unsigned char)10;
#line 4251
                              srb.TimeOutValue = 10UL;
#line 4252
                              cdb->NEC_SEEK_AUDIO.OperationCode = (unsigned char)216;
#line 4253
                              cdb->NEC_SEEK_AUDIO.Minute = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 4254
                              cdb->NEC_SEEK_AUDIO.Second = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 4255
                              cdb->NEC_SEEK_AUDIO.Frame = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
#line 4256
                              cdb->NEC_SEEK_AUDIO.Control = (unsigned char)64;
#line 4257
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
                              goto switch_4_break;
                              switch_4_exp_5: 
                              {
#line 4263
                              deviceExtension->PlayActive = (unsigned char)0;
#line 4264
                              srb.CdbLength = (unsigned char)10;
#line 4265
                              srb.TimeOutValue = 10UL;
#line 4266
                              cdb->NEC_PAUSE_AUDIO.OperationCode = (unsigned char)218;
#line 4267
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
                              goto switch_4_break;
                              switch_4_exp_6: 
                              {
#line 4273
                              srb.CdbLength = (unsigned char)10;
#line 4274
                              srb.TimeOutValue = 10UL;
#line 4275
                              cdb->NEC_PLAY_AUDIO.OperationCode = (unsigned char)217;
#line 4276
                              cdb->NEC_PLAY_AUDIO.PlayMode = (unsigned char)3;
#line 4277
                              cdb->NEC_PLAY_AUDIO.Control = (unsigned char)192;
#line 4278
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
                              goto switch_4_break;
                              switch_4_exp_7: 
                              {
#line 4284
                              userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 4285
                              tmp___4 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              10UL, 541156419UL);
#line 4286
                              SubQPtr = (UCHAR *)tmp___4;
                              }
#line 4288
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 4289
                                status = -1073741789L;
#line 4290
                                Irp->IoStatus.Information = 0UL;
#line 4291
                                if (SubQPtr) {

                                } else {

                                }
                                goto switch_4_break;
                              } else {

                              }
#line 4302
                              if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
#line 4303
                                status = -1073741670L;
#line 4304
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 4310
                              memset((void *)SubQPtr, 0, 10U);
                              }
#line 4312
                              if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
#line 4315
                                status = -1073741823L;
#line 4316
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              NECSeek: 
                              {
#line 4324
                              srb.CdbLength = (unsigned char)10;
#line 4325
                              srb.TimeOutValue = 10UL;
#line 4326
                              cdb->NEC_READ_Q_CHANNEL.OperationCode = (unsigned char)221;
#line 4327
                              cdb->NEC_READ_Q_CHANNEL.TransferSize = (unsigned char)10;
#line 4328
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)SubQPtr, 10UL);
                              }
#line 4331
                              if (status >= 0L) {
                                goto _L;
                              } else {
#line 4334
                                if (status == -1073741764L) {
                                  _L: 
#line 4336
                                  userPtr->Header.Reserved = (unsigned char)0;
#line 4337
                                  if ((int )*(SubQPtr + 0) == 0) {
#line 4338
                                    userPtr->Header.AudioStatus = (unsigned char)17;
                                  } else {
#line 4340
                                    if ((int )*(SubQPtr + 0) == 1) {
#line 4341
                                      userPtr->Header.AudioStatus = (unsigned char)18;
#line 4342
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    } else {
#line 4344
                                      if ((int )*(SubQPtr + 0) == 2) {
#line 4345
                                        userPtr->Header.AudioStatus = (unsigned char)18;
#line 4346
                                        deviceExtension->PlayActive = (unsigned char)0;
                                      } else {
#line 4348
                                        if ((int )*(SubQPtr + 0) == 3) {
#line 4349
                                          userPtr->Header.AudioStatus = (unsigned char)19;
#line 4350
                                          deviceExtension->PlayActive = (unsigned char)0;
                                        } else {
#line 4352
                                          deviceExtension->PlayActive = (unsigned char)0;
                                        }
                                      }
                                    }
                                  }
#line 4357
                                  userPtr->Header.DataLength[0] = (unsigned char)0;
#line 4358
                                  userPtr->Header.DataLength[0] = (unsigned char)12;
#line 4359
                                  userPtr->FormatCode = (unsigned char)1;
#line 4360
                                  userPtr->Control = (unsigned char )((int )*(SubQPtr + 1) & 15);
#line 4361
                                  userPtr->ADR = (unsigned char)0;
#line 4362
                                  userPtr->TrackNumber = (unsigned char )((((int )*(SubQPtr + 2) & 240) >> 4) * 10 + ((int )*(SubQPtr + 2) & 15));
#line 4363
                                  userPtr->IndexNumber = (unsigned char )((((int )*(SubQPtr + 3) & 240) >> 4) * 10 + ((int )*(SubQPtr + 3) & 15));
#line 4364
                                  userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 4365
                                  userPtr->AbsoluteAddress[1] = (unsigned char )((((int )*(SubQPtr + 7) & 240) >> 4) * 10 + ((int )*(SubQPtr + 7) & 15));
#line 4366
                                  userPtr->AbsoluteAddress[2] = (unsigned char )((((int )*(SubQPtr + 8) & 240) >> 4) * 10 + ((int )*(SubQPtr + 8) & 15));
#line 4367
                                  userPtr->AbsoluteAddress[3] = (unsigned char )((((int )*(SubQPtr + 9) & 240) >> 4) * 10 + ((int )*(SubQPtr + 9) & 15));
#line 4368
                                  userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 4369
                                  userPtr->TrackRelativeAddress[1] = (unsigned char )((((int )*(SubQPtr + 4) & 240) >> 4) * 10 + ((int )*(SubQPtr + 4) & 15));
#line 4370
                                  userPtr->TrackRelativeAddress[2] = (unsigned char )((((int )*(SubQPtr + 5) & 240) >> 4) * 10 + ((int )*(SubQPtr + 5) & 15));
#line 4371
                                  userPtr->TrackRelativeAddress[3] = (unsigned char )((((int )*(SubQPtr + 6) & 240) >> 4) * 10 + ((int )*(SubQPtr + 6) & 15));
#line 4372
                                  Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
#line 4373
                                  if ((int )userPtr->TrackNumber > 100) {
                                    {
#line 4375
                                    delay.QuadPart = -5000000LL;
#line 4376
                                    KeDelayExecutionThread((char)0, (unsigned char)0,
                                                           & delay);
#line 4377
                                    tmp___5 = retryCount;
#line 4378
                                    retryCount += 1UL;
                                    }
#line 4380
                                    if (tmp___5 < 4UL) {
                                      goto NECSeek;
                                    } else {
#line 4383
                                      Irp->IoStatus.Information = 0UL;
#line 4384
                                      status = -1073741434L;
                                    }
                                  } else {
#line 4387
                                    status = 0L;
                                  }
                                } else {
                                  {
#line 4391
                                  memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 4392
                                  Irp->IoStatus.Information = 0UL;
                                  }
                                }
                              }
                              goto switch_4_break;
                              switch_4_exp_8: 
                              {
#line 4402
                              deviceExtension->PlayActive = (unsigned char)0;
#line 4403
                              srb.CdbLength = (unsigned char)10;
#line 4404
                              srb.TimeOutValue = 10UL;
#line 4405
                              cdb->NEC_EJECT.OperationCode = (unsigned char)220;
#line 4406
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
#line 4408
                              Irp->IoStatus.Information = 0UL;
                              }
                              goto switch_4_break;
                              switch_4_exp_9: ;
                              switch_4_exp_10: ;
                              switch_4_exp_11: 
#line 4414
                              Irp->IoStatus.Information = 0UL;
#line 4415
                              status = -1073741808L;
                              goto switch_4_break;
                              switch_4_exp_12: 
                              {
#line 4419
                              CdAudioIsPlayActive(DeviceObject);
                              }
                              switch_4_default: 
                              {
#line 4423
                              tmp___6 = CdAudioSendToNextDriver(DeviceObject, Irp);
                              }
#line 4425
                              return (tmp___6);
                              goto switch_4_break;
                            } else {
                              switch_4_break: ;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 4445
  if (status == -2147483626L) {
#line 4446
    if ((int )currentIrpStack->Flags & 2) {
#line 4447
      status = -1073741435L;
      goto NECRestart;
    } else {

    }
#line 4454
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 4460
  Irp->IoStatus.__annonCompField4.Status = status;
#line 4461
  myStatus = (int )status;
#line 4462
  IofCompleteRequest(Irp, (char)0);
  }
#line 4464
  return (status);
}
}
#line 4467 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioPioneerDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PPNR_CDB cdb ;
  PCDB scsiCdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG retry ;
  PUCHAR Toc ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  NTSTATUS tmp___1 ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  ULONG tmp___4 ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr ;
  PVOID tmp___5 ;
  ULONG tmp___6 ;
  ULONG tmp___7 ;
  NTSTATUS tmp___8 ;

  {
#line 4498
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 4499
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 4500
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 4501
  cdb = (union _PIONEER_CDB *)(srb.Cdb);
#line 4502
  scsiCdb = (union _CDB *)(srb.Cdb);
  PioneerRestart: 
  {
#line 4505
  memset((void *)cdb, 0, 12U);
  }
#line 4507
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
    goto switch_6_exp_13;
  } else {
#line 4510
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (2 << 2))) {
      goto switch_6_exp_14;
    } else {
#line 4513
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
        goto switch_6_exp_15;
      } else {
#line 4516
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
          goto switch_6_exp_16;
        } else {
#line 4519
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (3 << 2))) {
            goto switch_6_exp_17;
          } else {
#line 4522
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (4 << 2))) {
              goto switch_6_exp_18;
            } else {
#line 4525
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
                goto switch_6_exp_19;
              } else {
#line 4528
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
                  goto switch_6_exp_20;
                } else {
#line 4531
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                    goto switch_6_exp_21;
                  } else {
#line 4534
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                      goto switch_6_exp_22;
                    } else {
#line 4537
                      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                        goto switch_6_exp_23;
                      } else {
#line 4540
                        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                          goto switch_6_exp_24;
                        } else {
                          goto switch_6_default;
#line 4545
                          if (0) {
                            switch_6_exp_13: ;
#line 4547
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 4548
                              status = -1073741789L;
#line 4549
                              Irp->IoStatus.Information = 0UL;
                              goto switch_6_break;
                            } else {

                            }
                            {
#line 4555
                            tmp = CdAudioIsPlayActive(DeviceObject);
                            }
#line 4557
                            if (tmp) {
#line 4558
                              status = -2147483631L;
#line 4559
                              Irp->IoStatus.Information = 0UL;
                              goto switch_6_break;
                            } else {

                            }
                            {
#line 4565
                            tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(CDROM_TOC ),
                                                            541156419UL);
#line 4567
                            Toc = (UCHAR *)tmp___0;
                            }
#line 4569
                            if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 4570
                              status = -1073741670L;
#line 4571
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 4577
                            memset((void *)Toc, 0, sizeof(CDROM_TOC ));
                            }
#line 4579
                            if ((int )deviceExtension->Active == 9) {
#line 4580
                              cdb->PNR_START_STOP.Immediate = (unsigned char)1;
                            } else {
#line 4582
                              cdb->PNR_START_STOP.Immediate = (unsigned char)0;
                            }
                            {
#line 4585
                            cdb->PNR_START_STOP.OperationCode = (unsigned char)27;
#line 4586
                            cdb->PNR_START_STOP.Start = (unsigned char)1;
#line 4587
                            srb.CdbLength = (unsigned char)6;
#line 4588
                            srb.TimeOutValue = 10UL;
#line 4589
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 4592
                            if (! (status >= 0L)) {
#line 4595
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 4602
                            memset((void *)cdb, 0, 12U);
#line 4603
                            srb.CdbLength = (unsigned char)10;
#line 4604
                            cdb->PNR_READ_TOC.OperationCode = (unsigned char)193;
#line 4605
                            cdb->PNR_READ_TOC.AssignedLength[1] = (unsigned char)4;
#line 4606
                            cdb->PNR_READ_TOC.Type = (unsigned char)0;
#line 4607
                            srb.TimeOutValue = 10UL;
#line 4608
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)Toc,
                                                        4UL);
                            }
#line 4611
                            if (! (status >= 0L)) {
#line 4614
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 4620
                            cdaudioDataOut->FirstTrack = (unsigned char )((((int )*(Toc + 0) & 240) >> 4) * 10 + ((int )*(Toc + 0) & 15));
#line 4621
                            cdaudioDataOut->LastTrack = (unsigned char )((((int )*(Toc + 1) & 240) >> 4) * 10 + ((int )*(Toc + 1) & 15));
#line 4622
                            tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 4623
                            dataLength = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[tracksOnCd])) - 2UL;
#line 4624
                            cdaudioDataOut->Length[0] = (unsigned char )(dataLength >> 8);
#line 4625
                            cdaudioDataOut->Length[1] = (unsigned char )(dataLength & 255UL);
#line 4626
                            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 4627
                            tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 4628
                            if (tracksInBuffer < tracksOnCd) {
#line 4629
                              tracksToReturn = tracksInBuffer;
                            } else {
#line 4631
                              tracksToReturn = tracksOnCd;
                            }
#line 4633
                            i = 0UL;
                            {
#line 4635
                            while (1) {
                              while_2_continue: /* CIL Label */ ;

#line 4637
                              if (i < tracksToReturn) {

                              } else {
                                goto while_7_break;
                              }
                              {
#line 4643
                              memset((void *)cdb, 0, 12U);
#line 4644
                              cdb->PNR_READ_TOC.OperationCode = (unsigned char)193;
#line 4645
                              cdb->PNR_READ_TOC.TrackNumber = (unsigned char )(((i + (unsigned long )cdaudioDataOut->FirstTrack) / 10UL << 4) + (i + (unsigned long )cdaudioDataOut->FirstTrack) % 10UL);
#line 4646
                              cdb->PNR_READ_TOC.AssignedLength[1] = (unsigned char)4;
#line 4647
                              cdb->PNR_READ_TOC.Type = (unsigned char)2;
#line 4648
                              srb.TimeOutValue = 10UL;
#line 4649
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)Toc, 4UL);
                              }
#line 4652
                              if (! (status >= 0L)) {
#line 4655
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 4661
                              cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 4662
                              cdaudioDataOut->TrackData[i].Control = *(Toc + 0);
#line 4663
                              cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )(i + (unsigned long )cdaudioDataOut->FirstTrack);
#line 4664
                              cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 4665
                              cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 4666
                              cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + 1) & 240) >> 4) * 10 + ((int )*(Toc + 1) & 15));
#line 4667
                              cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + 2) & 240) >> 4) * 10 + ((int )*(Toc + 2) & 15));
#line 4668
                              cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + 3) & 240) >> 4) * 10 + ((int )*(Toc + 3) & 15));
#line 4669
                              i += 1UL;
                            }
                            while_2_break: /* CIL Label */ ;
                            }
                            while_7_break: ;
#line 4673
                            if (tracksInBuffer > tracksOnCd) {
                              {
#line 4675
                              memset((void *)cdb, 0, 12U);
#line 4676
                              cdb->PNR_READ_TOC.OperationCode = (unsigned char)193;
#line 4677
                              cdb->PNR_READ_TOC.AssignedLength[1] = (unsigned char)4;
#line 4678
                              cdb->PNR_READ_TOC.Type = (unsigned char)1;
#line 4679
                              srb.TimeOutValue = 10UL;
#line 4680
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)Toc, 4UL);
                              }
#line 4683
                              if (! (status >= 0L)) {
#line 4686
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 4692
                              cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 4693
                              cdaudioDataOut->TrackData[i].Control = (unsigned char)16;
#line 4694
                              cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char)170;
#line 4695
                              cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 4696
                              cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 4697
                              cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + 0) & 240) >> 4) * 10 + ((int )*(Toc + 0) & 15));
#line 4698
                              cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + 1) & 240) >> 4) * 10 + ((int )*(Toc + 1) & 15));
#line 4699
                              cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + 2) & 240) >> 4) * 10 + ((int )*(Toc + 2) & 15));
#line 4700
                              i += 1UL;
                            } else {

                            }
#line 4705
                            Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
                            goto switch_6_break;
                            switch_6_exp_14: 
                            {
#line 4711
                            deviceExtension->PlayActive = (unsigned char)0;
#line 4712
                            tmp___1 = CdAudioSendToNextDriver(DeviceObject, Irp);
                            }
#line 4714
                            return (tmp___1);
                            goto switch_6_break;
                            switch_6_exp_15: 
#line 4717
                            inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 4718
                            Irp->IoStatus.Information = 0UL;
#line 4719
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 4720
                              status = -1073741820L;
                              goto switch_6_break;
                            } else {

                            }
#line 4725
                            retry = 5UL;
                            {
#line 4727
                            while (1) {
                              while_3_continue: /* CIL Label */ ;
                              {
#line 4730
                              srb.CdbLength = (unsigned char)10;
#line 4731
                              srb.TimeOutValue = 10UL;
#line 4732
                              cdb->PNR_SEEK_AUDIO.OperationCode = (unsigned char)200;
#line 4733
                              cdb->PNR_SEEK_AUDIO.Minute = (unsigned char )(((int )inputBuffer->StartingM / 10 << 4) + (int )inputBuffer->StartingM % 10);
#line 4734
                              cdb->PNR_SEEK_AUDIO.Second = (unsigned char )(((int )inputBuffer->StartingS / 10 << 4) + (int )inputBuffer->StartingS % 10);
#line 4735
                              cdb->PNR_SEEK_AUDIO.Frame = (unsigned char )(((int )inputBuffer->StartingF / 10 << 4) + (int )inputBuffer->StartingF % 10);
#line 4736
                              cdb->PNR_SEEK_AUDIO.Type = (unsigned char)1;
#line 4737
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 4740
                              if (! (status >= 0L)) {
#line 4741
                                tmp___2 = retry;
#line 4742
                                retry -= 1UL;
#line 4743
                                if (tmp___2 > 0UL) {

                                } else {
                                  goto while_8_break;
                                }
                              } else {
                                goto while_8_break;
                              }
                            }
                            while_3_break: /* CIL Label */ ;
                            }
                            while_8_break: ;
#line 4754
                            if (status >= 0L) {
                              {
#line 4756
                              memset((void *)cdb, 0, 12U);
#line 4757
                              retry = 5UL;
                              }
                              {
#line 4760
                              while (1) {
                                while_4_continue: /* CIL Label */ ;
                                {
#line 4763
                                srb.CdbLength = (unsigned char)10;
#line 4764
                                srb.TimeOutValue = 10UL;
#line 4765
                                cdb->PNR_PLAY_AUDIO.OperationCode = (unsigned char)201;
#line 4766
                                cdb->PNR_PLAY_AUDIO.StopAddr = (unsigned char)1;
#line 4767
                                cdb->PNR_PLAY_AUDIO.Minute = (unsigned char )(((int )inputBuffer->EndingM / 10 << 4) + (int )inputBuffer->EndingM % 10);
#line 4768
                                cdb->PNR_PLAY_AUDIO.Second = (unsigned char )(((int )inputBuffer->EndingS / 10 << 4) + (int )inputBuffer->EndingS % 10);
#line 4769
                                cdb->PNR_PLAY_AUDIO.Frame = (unsigned char )(((int )inputBuffer->EndingF / 10 << 4) + (int )inputBuffer->EndingF % 10);
#line 4770
                                cdb->PNR_PLAY_AUDIO.Type = (unsigned char)1;
#line 4771
                                status = SendSrbSynchronous(deviceExtension, & srb,
                                                            (void *)0, 0UL);
                                }
#line 4774
                                if (! (status >= 0L)) {
#line 4775
                                  tmp___3 = retry;
#line 4776
                                  retry -= 1UL;
#line 4777
                                  if (tmp___3 > 0UL) {

                                  } else {
                                    goto while_9_break;
                                  }
                                } else {
                                  goto while_9_break;
                                }
                              }
                              while_4_break: /* CIL Label */ ;
                              }
                              while_9_break: ;
#line 4788
                              if (status >= 0L) {
#line 4789
                                deviceExtension->PlayActive = (unsigned char)1;
                              } else {

                              }
                            } else {

                            }
                            goto switch_6_break;
                            switch_6_exp_16: 
#line 4798
                            inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 4799
                            Irp->IoStatus.Information = 0UL;
#line 4800
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 4801
                              status = -1073741820L;
                              goto switch_6_break;
                            } else {

                            }
#line 4806
                            retry = 5UL;
                            {
#line 4808
                            while (1) {
                              while_5_continue: /* CIL Label */ ;
                              {
#line 4811
                              srb.CdbLength = (unsigned char)10;
#line 4812
                              srb.TimeOutValue = 10UL;
#line 4813
                              cdb->PNR_SEEK_AUDIO.OperationCode = (unsigned char)200;
#line 4814
                              cdb->PNR_SEEK_AUDIO.Minute = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 4815
                              cdb->PNR_SEEK_AUDIO.Second = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 4816
                              cdb->PNR_SEEK_AUDIO.Frame = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
#line 4817
                              cdb->PNR_SEEK_AUDIO.Type = (unsigned char)1;
#line 4818
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 4821
                              if (! (status >= 0L)) {
#line 4822
                                tmp___4 = retry;
#line 4823
                                retry -= 1UL;
#line 4824
                                if (tmp___4 > 0UL) {

                                } else {
                                  goto while_10_break;
                                }
                              } else {
                                goto while_10_break;
                              }
                            }
                            while_5_break: /* CIL Label */ ;
                            }
                            while_10_break: ;
                            goto switch_6_break;
                            switch_6_exp_17: 
                            {
#line 4838
                            Irp->IoStatus.Information = 0UL;
#line 4839
                            deviceExtension->PlayActive = (unsigned char)0;
#line 4840
                            srb.CdbLength = (unsigned char)10;
#line 4841
                            srb.TimeOutValue = 10UL;
#line 4842
                            cdb->PNR_PAUSE_AUDIO.OperationCode = (unsigned char)202;
#line 4843
                            cdb->PNR_PAUSE_AUDIO.Pause = (unsigned char)1;
#line 4844
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
                            goto switch_6_break;
                            switch_6_exp_18: 
                            {
#line 4850
                            Irp->IoStatus.Information = 0UL;
#line 4851
                            srb.CdbLength = (unsigned char)10;
#line 4852
                            srb.TimeOutValue = 10UL;
#line 4853
                            cdb->PNR_PAUSE_AUDIO.OperationCode = (unsigned char)202;
#line 4854
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
                            goto switch_6_break;
                            switch_6_exp_19: 
                            {
#line 4860
                            userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 4861
                            tmp___5 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, 9UL,
                                                            541156419UL);
#line 4862
                            SubQPtr = (UCHAR *)tmp___5;
                            }
#line 4864
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 4865
                              status = -1073741789L;
#line 4866
                              Irp->IoStatus.Information = 0UL;
#line 4867
                              if (SubQPtr) {

                              } else {

                              }
                              goto switch_6_break;
                            } else {

                            }
#line 4878
                            if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
                              {
#line 4880
                              memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 4881
                              status = -1073741670L;
#line 4882
                              Irp->IoStatus.Information = 0UL;
                              }
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 4888
                            if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
                              {
#line 4891
                              memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 4892
                              Irp->IoStatus.Information = 0UL;
#line 4893
                              status = -1073741808L;
                              }
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 4899
                            retry = 5UL;
                            {
#line 4901
                            while (1) {
                              while_6_continue: /* CIL Label */ ;
                              {
#line 4904
                              srb.CdbLength = (unsigned char)10;
#line 4905
                              srb.TimeOutValue = 10UL;
#line 4906
                              cdb->PNR_AUDIO_STATUS.OperationCode = (unsigned char)204;
#line 4907
                              cdb->PNR_AUDIO_STATUS.AssignedLength = (unsigned char)6;
#line 4908
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)SubQPtr, 6UL);
                              }
#line 4911
                              if (! (status >= 0L)) {
#line 4912
                                tmp___6 = retry;
#line 4913
                                retry -= 1UL;
#line 4914
                                if (tmp___6 > 0UL) {
#line 4915
                                  if (status != -1073741661L) {

                                  } else {
                                    goto while_11_break;
                                  }
                                } else {
                                  goto while_11_break;
                                }
                              } else {
                                goto while_11_break;
                              }
                            }
                            while_6_break: /* CIL Label */ ;
                            }
                            while_11_break: ;
#line 4929
                            if (status >= 0L) {
#line 4930
                              userPtr->Header.Reserved = (unsigned char)0;
#line 4931
                              if ((int )*(SubQPtr + 0) == 0) {
#line 4932
                                userPtr->Header.AudioStatus = (unsigned char)17;
                              } else {
#line 4934
                                if ((int )*(SubQPtr + 0) == 1) {
#line 4935
                                  deviceExtension->PlayActive = (unsigned char)0;
#line 4936
                                  userPtr->Header.AudioStatus = (unsigned char)18;
                                } else {
#line 4938
                                  if ((int )*(SubQPtr + 0) == 2) {
#line 4939
                                    deviceExtension->PlayActive = (unsigned char)0;
#line 4940
                                    userPtr->Header.AudioStatus = (unsigned char)18;
                                  } else {
#line 4942
                                    if ((int )*(SubQPtr + 0) == 3) {
#line 4943
                                      userPtr->Header.AudioStatus = (unsigned char)19;
#line 4944
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    } else {
#line 4946
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    }
                                  }
                                }
                              }
                            } else {
#line 4954
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            }
                            {
#line 4959
                            memset((void *)cdb, 0, 12U);
#line 4960
                            retry = 5UL;
                            }
                            {
#line 4963
                            while (1) {
                              while_7_continue: /* CIL Label */ ;
                              {
#line 4966
                              srb.CdbLength = (unsigned char)10;
#line 4967
                              srb.TimeOutValue = 10UL;
#line 4968
                              cdb->PNR_READ_Q_CHANNEL.OperationCode = (unsigned char)194;
#line 4969
                              cdb->PNR_READ_Q_CHANNEL.AssignedLength = (unsigned char)9;
#line 4970
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)SubQPtr, 9UL);
                              }
#line 4973
                              if (! (status >= 0L)) {
#line 4974
                                tmp___7 = retry;
#line 4975
                                retry -= 1UL;
#line 4976
                                if (tmp___7 > 0UL) {

                                } else {
                                  goto while_12_break;
                                }
                              } else {
                                goto while_12_break;
                              }
                            }
                            while_7_break: /* CIL Label */ ;
                            }
                            while_12_break: ;
#line 4987
                            if (status >= 0L) {
#line 4988
                              userPtr->Header.DataLength[0] = (unsigned char)0;
#line 4989
                              userPtr->Header.DataLength[0] = (unsigned char)12;
#line 4990
                              userPtr->FormatCode = (unsigned char)1;
#line 4991
                              userPtr->Control = (unsigned char )((int )*(SubQPtr + 0) & 15);
#line 4992
                              userPtr->ADR = (unsigned char)0;
#line 4993
                              userPtr->TrackNumber = (unsigned char )((((int )*(SubQPtr + 1) & 240) >> 4) * 10 + ((int )*(SubQPtr + 1) & 15));
#line 4994
                              userPtr->IndexNumber = (unsigned char )((((int )*(SubQPtr + 2) & 240) >> 4) * 10 + ((int )*(SubQPtr + 2) & 15));
#line 4995
                              userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 4996
                              userPtr->AbsoluteAddress[1] = (unsigned char )((((int )*(SubQPtr + 6) & 240) >> 4) * 10 + ((int )*(SubQPtr + 6) & 15));
#line 4997
                              userPtr->AbsoluteAddress[2] = (unsigned char )((((int )*(SubQPtr + 7) & 240) >> 4) * 10 + ((int )*(SubQPtr + 7) & 15));
#line 4998
                              userPtr->AbsoluteAddress[3] = (unsigned char )((((int )*(SubQPtr + 8) & 240) >> 4) * 10 + ((int )*(SubQPtr + 8) & 15));
#line 4999
                              userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 5000
                              userPtr->TrackRelativeAddress[1] = (unsigned char )((((int )*(SubQPtr + 3) & 240) >> 4) * 10 + ((int )*(SubQPtr + 3) & 15));
#line 5001
                              userPtr->TrackRelativeAddress[2] = (unsigned char )((((int )*(SubQPtr + 4) & 240) >> 4) * 10 + ((int )*(SubQPtr + 4) & 15));
#line 5002
                              userPtr->TrackRelativeAddress[3] = (unsigned char )((((int )*(SubQPtr + 5) & 240) >> 4) * 10 + ((int )*(SubQPtr + 5) & 15));
#line 5003
                              Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
                            } else {
#line 5005
                              Irp->IoStatus.Information = 0UL;
                            }
                            goto switch_6_break;
                            switch_6_exp_20: 
#line 5012
                            Irp->IoStatus.Information = 0UL;
#line 5013
                            deviceExtension->PlayActive = (unsigned char)0;
#line 5014
                            if ((int )deviceExtension->Active == 9) {
#line 5015
                              srb.CdbLength = (unsigned char)10;
#line 5016
                              srb.TimeOutValue = 10UL;
#line 5017
                              cdb->PNR_EJECT.OperationCode = (unsigned char)192;
#line 5018
                              cdb->PNR_EJECT.Immediate = (unsigned char)1;
                            } else {
#line 5020
                              srb.CdbLength = (unsigned char)6;
#line 5021
                              scsiCdb->START_STOP.OperationCode = (unsigned char)27;
#line 5022
                              scsiCdb->START_STOP.LoadEject = (unsigned char)1;
#line 5023
                              scsiCdb->START_STOP.Start = (unsigned char)0;
                            }
                            {
#line 5026
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
                            goto switch_6_break;
                            switch_6_exp_21: ;
                            switch_6_exp_22: ;
                            switch_6_exp_23: 
#line 5033
                            Irp->IoStatus.Information = 0UL;
#line 5034
                            status = -1073741808L;
                            goto switch_6_break;
                            switch_6_exp_24: 
                            {
#line 5038
                            CdAudioIsPlayActive(DeviceObject);
                            }
                            switch_6_default: 
                            {
#line 5042
                            tmp___8 = CdAudioSendToNextDriver(DeviceObject, Irp);
                            }
#line 5044
                            return (tmp___8);
                            goto switch_6_break;
                          } else {
                            switch_6_break: ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 5063
  if (status == -2147483626L) {
#line 5064
    if ((int )currentIrpStack->Flags & 2) {
#line 5065
      status = -1073741435L;
      goto PioneerRestart;
    } else {

    }
#line 5072
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 5078
  Irp->IoStatus.__annonCompField4.Status = status;
#line 5079
  myStatus = (int )status;
#line 5080
  IofCompleteRequest(Irp, (char)0);
  }
#line 5082
  return (status);
}
}
#line 5085 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioDenonDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG bytesTransfered ;
  PUCHAR Toc ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  PUCHAR SubQPtr ;
  PVOID tmp___1 ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr___0 ;
  PVOID tmp___2 ;
  NTSTATUS tmp___3 ;

  {
#line 5111
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5112
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 5113
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 5114
  cdb = (union _CDB *)(srb.Cdb);
  DenonRestart: 
  {
#line 5117
  memset((void *)cdb, 0, 12U);
  }
#line 5119
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (14 << 2))) {
    goto switch_13_exp_25;
  } else {
#line 5122
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
      goto switch_13_exp_26;
    } else {
#line 5125
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
        goto switch_13_exp_27;
      } else {
#line 5128
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (2 << 2))) {
          goto switch_13_exp_28;
        } else {
#line 5131
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
            goto switch_13_exp_29;
          } else {
#line 5134
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (3 << 2))) {
              goto switch_13_exp_30;
            } else {
#line 5137
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (4 << 2))) {
                goto switch_13_exp_31;
              } else {
#line 5140
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
                  goto switch_13_exp_32;
                } else {
#line 5143
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
                    goto switch_13_exp_33;
                  } else {
#line 5146
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                      goto switch_13_exp_34;
                    } else {
#line 5149
                      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                        goto switch_13_exp_35;
                      } else {
#line 5152
                        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                          goto switch_13_exp_36;
                        } else {
#line 5155
                          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                            goto switch_13_exp_37;
                          } else {
                            goto switch_13_default;
#line 5160
                            if (0) {
                              switch_13_exp_25: 
#line 5162
                              status = -1073741808L;
#line 5163
                              Irp->IoStatus.Information = 0UL;
                              goto switch_13_break;
                              switch_13_exp_26: ;
#line 5166
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 5167
                                status = -1073741789L;
#line 5168
                                Irp->IoStatus.Information = 0UL;
                                goto switch_13_break;
                              } else {

                              }
                              {
#line 5174
                              tmp = CdAudioIsPlayActive(DeviceObject);
                              }
#line 5176
                              if (tmp) {
#line 5177
                                status = -2147483631L;
#line 5178
                                Irp->IoStatus.Information = 0UL;
                                goto switch_13_break;
                              } else {

                              }
                              {
#line 5184
                              tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              (unsigned long )sizeof(CDROM_TOC ),
                                                              541156419UL);
#line 5186
                              Toc = (UCHAR *)tmp___0;
                              }
#line 5188
                              if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 5189
                                status = -1073741670L;
#line 5190
                                Irp->IoStatus.Information = 0UL;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 5196
                              memset((void *)Toc, 0, sizeof(CDROM_TOC ));
#line 5197
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)233;
#line 5198
                              srb.TimeOutValue = 10UL;
#line 5199
                              srb.CdbLength = (unsigned char)6;
#line 5200
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)Toc, (unsigned long )sizeof(CDROM_TOC ));
                              }
#line 5203
                              if (! (status >= 0L)) {
#line 5204
                                if (status != -1073741764L) {
#line 5205
                                  if (status != -1073741764L) {
#line 5208
                                    Irp->IoStatus.Information = 0UL;
                                    goto SetStatusAndReturn;
                                  } else {

                                  }
                                } else {

                                }
                              } else {

                              }
#line 5220
                              status = 0L;
#line 5221
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > srb.DataTransferLength) {
#line 5222
                                bytesTransfered = srb.DataTransferLength;
                              } else {
#line 5224
                                bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                              }
#line 5226
                              cdaudioDataOut->FirstTrack = (unsigned char )((((int )*(Toc + 1) & 240) >> 4) * 10 + ((int )*(Toc + 1) & 15));
#line 5227
                              cdaudioDataOut->LastTrack = (unsigned char )((((int )*(Toc + 5) & 240) >> 4) * 10 + ((int )*(Toc + 5) & 15));
#line 5228
                              tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 5229
                              dataLength = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[tracksOnCd])) - 2UL;
#line 5230
                              cdaudioDataOut->Length[0] = (unsigned char )(dataLength >> 8);
#line 5231
                              cdaudioDataOut->Length[1] = (unsigned char )(dataLength & 255UL);
#line 5232
                              tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 5233
                              tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 5234
                              if (tracksInBuffer < tracksOnCd) {
#line 5235
                                tracksToReturn = tracksInBuffer;
                              } else {
#line 5237
                                tracksToReturn = tracksOnCd;
                              }
#line 5239
                              i = 0UL;
                              {
#line 5241
                              while (1) {
                                while_8_continue: /* CIL Label */ ;

#line 5243
                                if (i < tracksToReturn) {

                                } else {
                                  goto while_14_break;
                                }
#line 5248
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5249
                                cdaudioDataOut->TrackData[i].Control = *(Toc + (i * 4UL + 12UL));
#line 5250
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )(i + (unsigned long )cdaudioDataOut->FirstTrack);
#line 5251
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5252
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5253
                                cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + (i * 4UL + 13UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 4UL + 13UL)) & 15));
#line 5254
                                cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + (i * 4UL + 14UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 4UL + 14UL)) & 15));
#line 5255
                                cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + (i * 4UL + 15UL)) & 240) >> 4) * 10 + ((int )*(Toc + (i * 4UL + 15UL)) & 15));
#line 5256
                                i += 1UL;
                              }
                              while_8_break: /* CIL Label */ ;
                              }
                              while_14_break: ;
#line 5260
                              if (tracksInBuffer > tracksOnCd) {
#line 5261
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5262
                                cdaudioDataOut->TrackData[i].Control = (unsigned char)0;
#line 5263
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char)170;
#line 5264
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5265
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5266
                                cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((((int )*(Toc + 9) & 240) >> 4) * 10 + ((int )*(Toc + 9) & 15));
#line 5267
                                cdaudioDataOut->TrackData[i].Address[2] = (unsigned char )((((int )*(Toc + 10) & 240) >> 4) * 10 + ((int )*(Toc + 10) & 15));
#line 5268
                                cdaudioDataOut->TrackData[i].Address[3] = (unsigned char )((((int )*(Toc + 11) & 240) >> 4) * 10 + ((int )*(Toc + 11) & 15));
#line 5269
                                i += 1UL;
                              } else {

                              }
#line 5274
                              Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
#line 5275
                              deviceExtension->Paused = (unsigned char)0;
#line 5276
                              deviceExtension->PausedM = (unsigned char)0;
#line 5277
                              deviceExtension->PausedS = (unsigned char)0;
#line 5278
                              deviceExtension->PausedF = (unsigned char)0;
#line 5279
                              deviceExtension->LastEndM = (unsigned char)0;
#line 5280
                              deviceExtension->LastEndS = (unsigned char)0;
#line 5281
                              deviceExtension->LastEndF = (unsigned char)0;
                              goto switch_13_break;
                              switch_13_exp_27: ;
                              switch_13_exp_28: 
                              {
#line 5288
                              inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 5289
                              Irp->IoStatus.Information = 0UL;
#line 5290
                              deviceExtension->PlayActive = (unsigned char)0;
#line 5291
                              srb.CdbLength = (unsigned char)6;
#line 5292
                              srb.TimeOutValue = 10UL;
#line 5293
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)231;
#line 5294
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 5297
                              if (status >= 0L) {
#line 5298
                                deviceExtension->Paused = (unsigned char)0;
#line 5299
                                deviceExtension->PausedM = (unsigned char)0;
#line 5300
                                deviceExtension->PausedS = (unsigned char)0;
#line 5301
                                deviceExtension->PausedF = (unsigned char)0;
#line 5302
                                deviceExtension->LastEndM = (unsigned char)0;
#line 5303
                                deviceExtension->LastEndS = (unsigned char)0;
#line 5304
                                deviceExtension->LastEndF = (unsigned char)0;
                              } else {

                              }
#line 5308
                              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((2 << 16) | (1 << 14)) | (2 << 2))) {
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 5313
                              if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 5314
                                status = -1073741820L;
                                goto switch_13_break;
                              } else {

                              }
                              {
#line 5320
                              srb.CdbLength = (unsigned char)10;
#line 5321
                              srb.TimeOutValue = 10UL;
#line 5322
                              cdb->CDB10.OperationCode = (unsigned char)34;
#line 5323
                              cdb->CDB10.LogicalBlockByte0 = (unsigned char )(((int )inputBuffer->StartingM / 10 << 4) + (int )inputBuffer->StartingM % 10);
#line 5324
                              cdb->CDB10.LogicalBlockByte1 = (unsigned char )(((int )inputBuffer->StartingS / 10 << 4) + (int )inputBuffer->StartingS % 10);
#line 5325
                              cdb->CDB10.LogicalBlockByte2 = (unsigned char )(((int )inputBuffer->StartingF / 10 << 4) + (int )inputBuffer->StartingF % 10);
#line 5326
                              cdb->CDB10.LogicalBlockByte3 = (unsigned char )(((int )inputBuffer->EndingM / 10 << 4) + (int )inputBuffer->EndingM % 10);
#line 5327
                              cdb->CDB10.Reserved2 = (unsigned char )(((int )inputBuffer->EndingS / 10 << 4) + (int )inputBuffer->EndingS % 10);
#line 5328
                              cdb->CDB10.TransferBlocksMsb = (unsigned char )(((int )inputBuffer->EndingF / 10 << 4) + (int )inputBuffer->EndingF % 10);
#line 5329
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 5332
                              if (status >= 0L) {
#line 5333
                                deviceExtension->PlayActive = (unsigned char)1;
#line 5334
                                deviceExtension->Paused = (unsigned char)0;
#line 5335
                                deviceExtension->LastEndM = (unsigned char )(((int )inputBuffer->EndingM / 10 << 4) + (int )inputBuffer->EndingM % 10);
#line 5336
                                deviceExtension->LastEndS = (unsigned char )(((int )inputBuffer->EndingS / 10 << 4) + (int )inputBuffer->EndingS % 10);
#line 5337
                                deviceExtension->LastEndF = (unsigned char )(((int )inputBuffer->EndingF / 10 << 4) + (int )inputBuffer->EndingF % 10);
                              } else {
#line 5339
                                if (status == -1073741808L) {
#line 5340
                                  status = -1073741803L;
                                } else {

                                }
                              }
                              goto switch_13_break;
                              switch_13_exp_29: 
#line 5347
                              inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 5348
                              Irp->IoStatus.Information = 0UL;
#line 5349
                              if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 5350
                                status = -1073741820L;
                                goto switch_13_break;
                              } else {

                              }
                              {
#line 5356
                              srb.CdbLength = (unsigned char)10;
#line 5357
                              srb.TimeOutValue = 10UL;
#line 5358
                              cdb->CDB10.OperationCode = (unsigned char)34;
#line 5359
                              cdb->CDB10.LogicalBlockByte0 = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 5360
                              cdb->CDB10.LogicalBlockByte1 = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 5361
                              cdb->CDB10.LogicalBlockByte2 = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
#line 5362
                              cdb->CDB10.LogicalBlockByte3 = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 5363
                              cdb->CDB10.Reserved2 = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 5364
                              cdb->CDB10.TransferBlocksMsb = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
#line 5365
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 5368
                              if (status >= 0L) {
#line 5369
                                deviceExtension->Paused = (unsigned char)1;
#line 5370
                                deviceExtension->PausedM = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 5371
                                deviceExtension->PausedS = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 5372
                                deviceExtension->PausedF = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
#line 5373
                                deviceExtension->LastEndM = (unsigned char )(((int )inputBuffer___0->M / 10 << 4) + (int )inputBuffer___0->M % 10);
#line 5374
                                deviceExtension->LastEndS = (unsigned char )(((int )inputBuffer___0->S / 10 << 4) + (int )inputBuffer___0->S % 10);
#line 5375
                                deviceExtension->LastEndF = (unsigned char )(((int )inputBuffer___0->F / 10 << 4) + (int )inputBuffer___0->F % 10);
                              } else {
#line 5377
                                if (status == -1073741808L) {
#line 5378
                                  status = -1073741803L;
                                } else {

                                }
                              }
                              goto switch_13_break;
                              switch_13_exp_30: 
                              {
#line 5386
                              tmp___1 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              10UL, 541156419UL);
#line 5387
                              SubQPtr = (UCHAR *)tmp___1;
#line 5388
                              Irp->IoStatus.Information = 0UL;
#line 5389
                              deviceExtension->PlayActive = (unsigned char)0;
                              }
#line 5391
                              if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
#line 5392
                                status = -1073741670L;
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 5397
                              if ((int )deviceExtension->Paused == 1) {
#line 5400
                                status = 0L;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 5407
                              srb.CdbLength = (unsigned char)6;
#line 5408
                              srb.TimeOutValue = 10UL;
#line 5409
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)235;
#line 5410
                              cdb->CDB6GENERIC.CommandUniqueBytes[2] = (unsigned char)10;
#line 5411
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)SubQPtr, 10UL);
                              }
#line 5414
                              if (! (status >= 0L)) {
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 5423
                              deviceExtension->PausedM = *(SubQPtr + 7);
#line 5424
                              deviceExtension->PausedS = *(SubQPtr + 8);
#line 5425
                              deviceExtension->PausedF = *(SubQPtr + 9);
#line 5426
                              memset((void *)cdb, 0, 12U);
#line 5427
                              srb.CdbLength = (unsigned char)6;
#line 5428
                              srb.TimeOutValue = 10UL;
#line 5429
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)231;
#line 5430
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 5433
                              if (! (status >= 0L)) {
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 5442
                              deviceExtension->Paused = (unsigned char)1;
#line 5443
                              deviceExtension->PausedM = *(SubQPtr + 7);
#line 5444
                              deviceExtension->PausedS = *(SubQPtr + 8);
#line 5445
                              deviceExtension->PausedF = *(SubQPtr + 9);
                              goto switch_13_break;
                              switch_13_exp_31: 
#line 5450
                              Irp->IoStatus.Information = 0UL;
#line 5451
                              if ((int )deviceExtension->Paused == 0) {
#line 5452
                                status = -1073741823L;
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 5458
                              srb.CdbLength = (unsigned char)10;
#line 5459
                              srb.TimeOutValue = 10UL;
#line 5460
                              cdb->CDB10.OperationCode = (unsigned char)34;
#line 5461
                              cdb->CDB10.LogicalBlockByte0 = deviceExtension->PausedM;
#line 5462
                              cdb->CDB10.LogicalBlockByte1 = deviceExtension->PausedS;
#line 5463
                              cdb->CDB10.LogicalBlockByte2 = deviceExtension->PausedF;
#line 5464
                              cdb->CDB10.LogicalBlockByte3 = deviceExtension->LastEndM;
#line 5465
                              cdb->CDB10.Reserved2 = deviceExtension->LastEndS;
#line 5466
                              cdb->CDB10.TransferBlocksMsb = deviceExtension->LastEndF;
#line 5467
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
#line 5470
                              if (status >= 0L) {
#line 5471
                                deviceExtension->Paused = (unsigned char)0;
                              } else {

                              }
                              goto switch_13_break;
                              switch_13_exp_32: 
                              {
#line 5478
                              userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 5479
                              tmp___2 = ExAllocatePoolWithTag((enum _POOL_TYPE )4,
                                                              (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ),
                                                              541156419UL);
#line 5481
                              SubQPtr___0 = (UCHAR *)tmp___2;
                              }
#line 5483
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 5484
                                status = -1073741789L;
#line 5485
                                Irp->IoStatus.Information = 0UL;
#line 5486
                                if (SubQPtr___0) {

                                } else {

                                }
                                goto switch_13_break;
                              } else {

                              }
#line 5497
                              if ((unsigned int )SubQPtr___0 == (unsigned int )((void *)0)) {
                                {
#line 5499
                                memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 5500
                                status = -1073741670L;
#line 5501
                                Irp->IoStatus.Information = 0UL;
                                }
                                goto SetStatusAndReturn;
                              } else {

                              }
#line 5507
                              if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
                                {
#line 5510
                                memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 5511
                                status = -1073741823L;
#line 5512
                                Irp->IoStatus.Information = 0UL;
                                }
                                goto SetStatusAndReturn;
                              } else {

                              }
                              {
#line 5519
                              srb.CdbLength = (unsigned char)6;
#line 5520
                              srb.TimeOutValue = 10UL;
#line 5521
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)235;
#line 5522
                              cdb->CDB6GENERIC.CommandUniqueBytes[2] = (unsigned char)10;
#line 5523
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)SubQPtr___0, 10UL);
                              }
#line 5526
                              if (status >= 0L) {
#line 5527
                                userPtr->Header.Reserved = (unsigned char)0;
#line 5528
                                if ((int )deviceExtension->Paused == 1) {
#line 5529
                                  deviceExtension->PlayActive = (unsigned char)0;
#line 5530
                                  userPtr->Header.AudioStatus = (unsigned char)18;
                                } else {
#line 5532
                                  if ((int )*(SubQPtr___0 + 0) == 1) {
#line 5533
                                    userPtr->Header.AudioStatus = (unsigned char)17;
                                  } else {
#line 5535
                                    if ((int )*(SubQPtr___0 + 0) == 0) {
#line 5536
                                      userPtr->Header.AudioStatus = (unsigned char)19;
#line 5537
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    } else {
#line 5539
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    }
                                  }
                                }
#line 5543
                                userPtr->Header.DataLength[0] = (unsigned char)0;
#line 5544
                                userPtr->Header.DataLength[0] = (unsigned char)12;
#line 5545
                                userPtr->FormatCode = (unsigned char)1;
#line 5546
                                userPtr->Control = *(SubQPtr___0 + 1);
#line 5547
                                userPtr->ADR = (unsigned char)0;
#line 5548
                                userPtr->TrackNumber = (unsigned char )((((int )*(SubQPtr___0 + 2) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 2) & 15));
#line 5549
                                userPtr->IndexNumber = (unsigned char )((((int )*(SubQPtr___0 + 3) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 3) & 15));
#line 5550
                                userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 5551
                                userPtr->AbsoluteAddress[1] = (unsigned char )((((int )*(SubQPtr___0 + 7) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 7) & 15));
#line 5552
                                userPtr->AbsoluteAddress[2] = (unsigned char )((((int )*(SubQPtr___0 + 8) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 8) & 15));
#line 5553
                                userPtr->AbsoluteAddress[3] = (unsigned char )((((int )*(SubQPtr___0 + 9) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 9) & 15));
#line 5554
                                userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 5555
                                userPtr->TrackRelativeAddress[1] = (unsigned char )((((int )*(SubQPtr___0 + 4) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 4) & 15));
#line 5556
                                userPtr->TrackRelativeAddress[2] = (unsigned char )((((int )*(SubQPtr___0 + 5) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 5) & 15));
#line 5557
                                userPtr->TrackRelativeAddress[3] = (unsigned char )((((int )*(SubQPtr___0 + 6) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 6) & 15));
#line 5558
                                Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
                              } else {
#line 5560
                                Irp->IoStatus.Information = 0UL;
                              }
                              goto switch_13_break;
                              switch_13_exp_33: 
                              {
#line 5568
                              Irp->IoStatus.Information = 0UL;
#line 5569
                              deviceExtension->PlayActive = (unsigned char)0;
#line 5570
                              srb.CdbLength = (unsigned char)6;
#line 5571
                              srb.TimeOutValue = 10UL;
#line 5572
                              cdb->CDB6GENERIC.OperationCode = (unsigned char)230;
#line 5573
                              status = SendSrbSynchronous(deviceExtension, & srb,
                                                          (void *)0, 0UL);
                              }
                              goto switch_13_break;
                              switch_13_exp_34: ;
                              switch_13_exp_35: ;
                              switch_13_exp_36: 
#line 5580
                              Irp->IoStatus.Information = 0UL;
#line 5581
                              status = -1073741808L;
                              goto switch_13_break;
                              switch_13_exp_37: 
                              {
#line 5585
                              CdAudioIsPlayActive(DeviceObject);
                              }
                              switch_13_default: 
                              {
#line 5589
                              tmp___3 = CdAudioSendToNextDriver(DeviceObject, Irp);
                              }
#line 5591
                              return (tmp___3);
                              goto switch_13_break;
                            } else {
                              switch_13_break: ;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 5611
  if (status == -2147483626L) {
#line 5612
    if ((int )currentIrpStack->Flags & 2) {
#line 5613
      status = -1073741435L;
      goto DenonRestart;
    } else {

    }
#line 5620
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 5626
  Irp->IoStatus.__annonCompField4.Status = status;
#line 5627
  myStatus = (int )status;
#line 5628
  IofCompleteRequest(Irp, (char)0);
  }
#line 5630
  return (status);
}
}
#line 5633 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioHitachiSendPauseCommand(PDEVICE_OBJECT DeviceObject ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb ;
  NTSTATUS status ;
  PUCHAR PausePos ;
  PVOID tmp ;

  {
  {
#line 5643
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 5644
  cdb = (union _HITACHICDB *)(srb.Cdb);
#line 5645
  tmp = ExAllocatePoolWithTag((enum _POOL_TYPE )4, 3UL, 541156419UL);
#line 5646
  PausePos = (UCHAR *)tmp;
  }
#line 5648
  if ((unsigned int )PausePos == (unsigned int )((void *)0)) {
#line 5649
    return (-1073741670L);
  } else {

  }
  {
#line 5654
  memset((void *)PausePos, 0, 3U);
#line 5655
  memset((void *)cdb, 0, 12U);
#line 5656
  srb.CdbLength = (unsigned char)12;
#line 5657
  srb.TimeOutValue = 10UL;
#line 5658
  cdb->PAUSE_AUDIO.OperationCode = (unsigned char)225;
#line 5659
  status = SendSrbSynchronous(deviceExtension, & srb, (void *)PausePos, 3UL);
  }
#line 5662
  return (status);
}
}
#line 5665 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioHitachiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG bytesTransfered ;
  PUCHAR Toc ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  ULONG tracksToReturn___0 ;
  ULONG tracksOnCd___0 ;
  ULONG tracksInBuffer___0 ;
  ULONG dataLength___0 ;
  NTSTATUS tmp___1 ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  PUCHAR PausePos ;
  PVOID tmp___2 ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr ;
  PVOID tmp___3 ;
  PUCHAR EjectStatus ;
  PVOID tmp___4 ;
  NTSTATUS tmp___5 ;

  {
#line 5698
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 5699
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 5700
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 5701
  cdb = (union _HITACHICDB *)(srb.Cdb);
  HitachiRestart: 
  {
#line 5704
  memset((void *)cdb, 0, 12U);
  }
#line 5706
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
    goto switch_15_exp_38;
  } else {
#line 5709
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (2 << 2))) {
      goto switch_15_exp_39;
    } else {
#line 5712
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
        goto switch_15_exp_40;
      } else {
#line 5715
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
          goto switch_15_exp_41;
        } else {
#line 5718
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (3 << 2))) {
            goto switch_15_exp_42;
          } else {
#line 5721
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (4 << 2))) {
              goto switch_15_exp_43;
            } else {
#line 5724
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
                goto switch_15_exp_44;
              } else {
#line 5727
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
                  goto switch_15_exp_45;
                } else {
#line 5730
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                    goto switch_15_exp_46;
                  } else {
#line 5733
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                      goto switch_15_exp_47;
                    } else {
#line 5736
                      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                        goto switch_15_exp_48;
                      } else {
#line 5739
                        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                          goto switch_15_exp_49;
                        } else {
                          goto switch_15_default;
#line 5744
                          if (0) {
                            switch_15_exp_38: ;
#line 5746
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 5747
                              status = -1073741789L;
#line 5748
                              Irp->IoStatus.Information = 0UL;
                              goto switch_15_break;
                            } else {

                            }
                            {
#line 5754
                            tmp = CdAudioIsPlayActive(DeviceObject);
                            }
#line 5756
                            if (tmp) {
#line 5757
                              status = -2147483631L;
#line 5758
                              Irp->IoStatus.Information = 0UL;
                              goto switch_15_break;
                            } else {

                            }
                            {
#line 5764
                            tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(CDROM_TOC ),
                                                            541156419UL);
#line 5766
                            Toc = (UCHAR *)tmp___0;
                            }
#line 5768
                            if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 5769
                              status = -1073741670L;
#line 5770
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 5776
                            memset((void *)Toc, 0, sizeof(CDROM_TOC ));
#line 5777
                            srb.CdbLength = (unsigned char)12;
                            }
#line 5779
                            if ((int )deviceExtension->Active == 5) {
#line 5780
                              cdb->READ_DISC_INFO.OperationCode = (unsigned char)227;
                            } else {
#line 5782
                              cdb->READ_DISC_INFO.OperationCode = (unsigned char)232;
                            }
                            {
#line 5785
                            cdb->READ_DISC_INFO.AllocationLength[0] = (unsigned char )(sizeof(CDROM_TOC ) >> 8);
#line 5786
                            cdb->READ_DISC_INFO.AllocationLength[1] = (unsigned char )(sizeof(CDROM_TOC ) & 255U);
#line 5787
                            srb.TimeOutValue = 10UL;
#line 5788
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)Toc,
                                                        (unsigned long )sizeof(CDROM_TOC ));
                            }
#line 5791
                            if (! (status >= 0L)) {
#line 5792
                              if (status != -1073741764L) {
#line 5793
                                if (status != -1073741764L) {
#line 5796
                                  Irp->IoStatus.Information = 0UL;
                                  goto SetStatusAndReturn;
                                } else {

                                }
                              } else {
#line 5803
                                status = 0L;
                              }
                            } else {
#line 5806
                              status = 0L;
                            }
#line 5808
                            if ((int )deviceExtension->Active == 6) {
#line 5809
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > (unsigned long )sizeof(CDROM_TOC )) {
#line 5810
                                bytesTransfered = (unsigned long )sizeof(CDROM_TOC );
                              } else {
#line 5812
                                bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                              }
#line 5814
                              cdaudioDataOut->FirstTrack = *(Toc + 2);
#line 5815
                              cdaudioDataOut->LastTrack = *(Toc + 3);
#line 5816
                              tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 5817
                              dataLength = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[tracksOnCd])) - 2UL;
#line 5818
                              cdaudioDataOut->Length[0] = (unsigned char )(dataLength >> 8);
#line 5819
                              cdaudioDataOut->Length[1] = (unsigned char )(dataLength & 255UL);
#line 5820
                              tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 5821
                              tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 5822
                              if (tracksInBuffer < tracksOnCd) {
#line 5823
                                tracksToReturn = tracksInBuffer;
                              } else {
#line 5825
                                tracksToReturn = tracksOnCd;
                              }
#line 5827
                              i = 0UL;
                              {
#line 5829
                              while (1) {
                                while_9_continue: /* CIL Label */ ;

#line 5831
                                if (i < tracksToReturn) {

                                } else {
                                  goto while_16_break;
                                }
#line 5836
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5837
                                cdaudioDataOut->TrackData[i].Control = (unsigned char )((((int )*(Toc + (i * 4UL + 8UL)) & 15) << 4) | ((int )*(Toc + (i * 4UL + 8UL)) >> 4));
#line 5838
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )(i + (unsigned long )cdaudioDataOut->FirstTrack);
#line 5839
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5840
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5841
                                cdaudioDataOut->TrackData[i].Address[1] = *(Toc + (i * 4UL + 9UL));
#line 5842
                                cdaudioDataOut->TrackData[i].Address[2] = *(Toc + (i * 4UL + 10UL));
#line 5843
                                cdaudioDataOut->TrackData[i].Address[3] = *(Toc + (i * 4UL + 11UL));
#line 5844
                                i += 1UL;
                              }
                              while_9_break: /* CIL Label */ ;
                              }
                              while_16_break: ;
#line 5848
                              if (tracksInBuffer > tracksOnCd) {
#line 5849
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5850
                                cdaudioDataOut->TrackData[i].Control = (unsigned char)16;
#line 5851
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char)170;
#line 5852
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5853
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5854
                                cdaudioDataOut->TrackData[i].Address[1] = *(Toc + 5);
#line 5855
                                cdaudioDataOut->TrackData[i].Address[2] = *(Toc + 6);
#line 5856
                                cdaudioDataOut->TrackData[i].Address[3] = *(Toc + 7);
#line 5857
                                i += 1UL;
                              } else {

                              }
#line 5861
                              Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
#line 5862
                              deviceExtension->Paused = (unsigned char)0;
#line 5863
                              deviceExtension->PausedM = (unsigned char)0;
#line 5864
                              deviceExtension->PausedS = (unsigned char)0;
#line 5865
                              deviceExtension->PausedF = (unsigned char)0;
#line 5866
                              deviceExtension->LastEndM = (unsigned char)0;
#line 5867
                              deviceExtension->LastEndS = (unsigned char)0;
#line 5868
                              deviceExtension->LastEndF = (unsigned char)0;
                            } else {
#line 5870
                              if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > (unsigned long )sizeof(CDROM_TOC )) {
#line 5871
                                bytesTransfered = (unsigned long )sizeof(CDROM_TOC );
                              } else {
#line 5873
                                bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                              }
#line 5875
                              cdaudioDataOut->FirstTrack = *(Toc + 1);
#line 5876
                              cdaudioDataOut->LastTrack = *(Toc + 2);
#line 5877
                              tracksOnCd___0 = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 5878
                              dataLength___0 = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[tracksOnCd___0])) - 2UL;
#line 5879
                              cdaudioDataOut->Length[0] = (unsigned char )(dataLength___0 >> 8);
#line 5880
                              cdaudioDataOut->Length[1] = (unsigned char )(dataLength___0 & 255UL);
#line 5881
                              tracksInBuffer___0 = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 5882
                              tracksInBuffer___0 /= (unsigned long )sizeof(TRACK_DATA );
#line 5883
                              if (tracksInBuffer___0 < tracksOnCd___0) {
#line 5884
                                tracksToReturn___0 = tracksInBuffer___0;
                              } else {
#line 5886
                                tracksToReturn___0 = tracksOnCd___0;
                              }
#line 5888
                              i = 0UL;
                              {
#line 5890
                              while (1) {
                                while_10_continue: /* CIL Label */ ;

#line 5892
                                if (i < tracksToReturn___0) {

                                } else {
                                  goto while_17_break;
                                }
#line 5897
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5898
                                if ((int )*(Toc + (i * 3UL + 6UL)) & 128) {
#line 5899
                                  cdaudioDataOut->TrackData[i].Control = (unsigned char)4;
                                } else {
#line 5901
                                  cdaudioDataOut->TrackData[i].Control = (unsigned char)0;
                                }
#line 5903
                                cdaudioDataOut->TrackData[i].Adr = (unsigned char)0;
#line 5904
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )(i + (unsigned long )cdaudioDataOut->FirstTrack);
#line 5905
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5906
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5907
                                cdaudioDataOut->TrackData[i].Address[1] = (unsigned char )((int )*(Toc + (i * 3UL + 6UL)) & 127);
#line 5908
                                cdaudioDataOut->TrackData[i].Address[2] = *(Toc + (i * 3UL + 7UL));
#line 5909
                                cdaudioDataOut->TrackData[i].Address[3] = *(Toc + (i * 3UL + 8UL));
#line 5910
                                i += 1UL;
                              }
                              while_10_break: /* CIL Label */ ;
                              }
                              while_17_break: ;
#line 5914
                              if (tracksInBuffer___0 > tracksOnCd___0) {
#line 5915
                                cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 5916
                                cdaudioDataOut->TrackData[i].Control = (unsigned char)16;
#line 5917
                                cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char)170;
#line 5918
                                cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 5919
                                cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 5920
                                cdaudioDataOut->TrackData[i].Address[1] = *(Toc + 3);
#line 5921
                                cdaudioDataOut->TrackData[i].Address[2] = *(Toc + 4);
#line 5922
                                cdaudioDataOut->TrackData[i].Address[3] = *(Toc + 5);
#line 5923
                                i += 1UL;
                              } else {

                              }
#line 5927
                              Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
                            }
                            goto switch_15_break;
                            switch_15_exp_39: 
                            {
#line 5935
                            deviceExtension->PlayActive = (unsigned char)0;
#line 5936
                            Irp->IoStatus.Information = 0UL;
#line 5937
                            CdAudioHitachiSendPauseCommand(DeviceObject);
#line 5938
                            deviceExtension->Paused = (unsigned char)0;
#line 5939
                            deviceExtension->PausedM = (unsigned char)0;
#line 5940
                            deviceExtension->PausedS = (unsigned char)0;
#line 5941
                            deviceExtension->PausedF = (unsigned char)0;
#line 5942
                            deviceExtension->LastEndM = (unsigned char)0;
#line 5943
                            deviceExtension->LastEndS = (unsigned char)0;
#line 5944
                            deviceExtension->LastEndF = (unsigned char)0;
#line 5945
                            tmp___1 = CdAudioSendToNextDriver(DeviceObject, Irp);
                            }
#line 5947
                            return (tmp___1);
                            goto switch_15_break;
                            switch_15_exp_40: 
#line 5950
                            inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 5951
                            Irp->IoStatus.Information = 0UL;
#line 5952
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 5953
                              status = -1073741820L;
                              goto switch_15_break;
                            } else {

                            }
                            {
#line 5959
                            CdAudioHitachiSendPauseCommand(DeviceObject);
#line 5960
                            srb.CdbLength = (unsigned char)12;
#line 5961
                            srb.TimeOutValue = 10UL;
#line 5962
                            cdb->PLAY_AUDIO.OperationCode = (unsigned char)224;
#line 5963
                            cdb->PLAY_AUDIO.Immediate = (unsigned char)1;
#line 5964
                            cdb->PLAY_AUDIO.StartingM = inputBuffer->StartingM;
#line 5965
                            cdb->PLAY_AUDIO.StartingS = inputBuffer->StartingS;
#line 5966
                            cdb->PLAY_AUDIO.StartingF = inputBuffer->StartingF;
#line 5967
                            cdb->PLAY_AUDIO.EndingM = inputBuffer->EndingM;
#line 5968
                            cdb->PLAY_AUDIO.EndingS = inputBuffer->EndingS;
#line 5969
                            cdb->PLAY_AUDIO.EndingF = inputBuffer->EndingF;
#line 5970
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 5973
                            if (status >= 0L) {
#line 5974
                              deviceExtension->PlayActive = (unsigned char)1;
#line 5975
                              deviceExtension->Paused = (unsigned char)0;
#line 5976
                              deviceExtension->PausedM = inputBuffer->StartingM;
#line 5977
                              deviceExtension->PausedS = inputBuffer->StartingS;
#line 5978
                              deviceExtension->PausedF = inputBuffer->StartingF;
#line 5979
                              deviceExtension->LastEndM = inputBuffer->EndingM;
#line 5980
                              deviceExtension->LastEndS = inputBuffer->EndingS;
#line 5981
                              deviceExtension->LastEndF = inputBuffer->EndingF;
                            } else {

                            }
                            goto switch_15_break;
                            switch_15_exp_41: 
#line 5987
                            inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 5988
                            Irp->IoStatus.Information = 0UL;
#line 5989
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 5990
                              status = -1073741820L;
                              goto switch_15_break;
                            } else {

                            }
                            {
#line 5996
                            CdAudioHitachiSendPauseCommand(DeviceObject);
#line 5997
                            srb.CdbLength = (unsigned char)12;
#line 5998
                            srb.TimeOutValue = 10UL;
#line 5999
                            cdb->PLAY_AUDIO.OperationCode = (unsigned char)224;
#line 6000
                            cdb->PLAY_AUDIO.Immediate = (unsigned char)1;
#line 6001
                            cdb->PLAY_AUDIO.StartingM = inputBuffer___0->M;
#line 6002
                            cdb->PLAY_AUDIO.StartingS = inputBuffer___0->S;
#line 6003
                            cdb->PLAY_AUDIO.StartingF = inputBuffer___0->F;
#line 6004
                            cdb->PLAY_AUDIO.EndingM = inputBuffer___0->M;
#line 6005
                            cdb->PLAY_AUDIO.EndingS = inputBuffer___0->S;
#line 6006
                            cdb->PLAY_AUDIO.EndingF = inputBuffer___0->F;
#line 6007
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 6010
                            if (status >= 0L) {
#line 6011
                              deviceExtension->PausedM = inputBuffer___0->M;
#line 6012
                              deviceExtension->PausedS = inputBuffer___0->S;
#line 6013
                              deviceExtension->PausedF = inputBuffer___0->F;
#line 6014
                              deviceExtension->LastEndM = inputBuffer___0->M;
#line 6015
                              deviceExtension->LastEndS = inputBuffer___0->S;
#line 6016
                              deviceExtension->LastEndF = inputBuffer___0->F;
                            } else {

                            }
                            goto switch_15_break;
                            switch_15_exp_42: 
                            {
#line 6023
                            tmp___2 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, 3UL,
                                                            541156419UL);
#line 6024
                            PausePos = (UCHAR *)tmp___2;
#line 6025
                            Irp->IoStatus.Information = 0UL;
                            }
#line 6027
                            if ((unsigned int )PausePos == (unsigned int )((void *)0)) {
#line 6028
                              status = -1073741670L;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 6034
                            deviceExtension->PlayActive = (unsigned char)0;
#line 6035
                            memset((void *)PausePos, 0, 3U);
#line 6036
                            srb.CdbLength = (unsigned char)12;
#line 6037
                            srb.TimeOutValue = 10UL;
#line 6038
                            cdb->PAUSE_AUDIO.OperationCode = (unsigned char)225;
#line 6039
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)PausePos,
                                                        3UL);
#line 6041
                            deviceExtension->Paused = (unsigned char)1;
#line 6042
                            deviceExtension->PausedM = *(PausePos + 0);
#line 6043
                            deviceExtension->PausedS = *(PausePos + 1);
#line 6044
                            deviceExtension->PausedF = *(PausePos + 2);
                            }
                            goto switch_15_break;
                            switch_15_exp_43: 
                            {
#line 6050
                            Irp->IoStatus.Information = 0UL;
#line 6051
                            CdAudioHitachiSendPauseCommand(DeviceObject);
#line 6052
                            srb.CdbLength = (unsigned char)12;
#line 6053
                            srb.TimeOutValue = 10UL;
#line 6054
                            cdb->PLAY_AUDIO.OperationCode = (unsigned char)224;
#line 6055
                            cdb->PLAY_AUDIO.Immediate = (unsigned char)1;
#line 6056
                            cdb->PLAY_AUDIO.StartingM = deviceExtension->PausedM;
#line 6057
                            cdb->PLAY_AUDIO.StartingS = deviceExtension->PausedS;
#line 6058
                            cdb->PLAY_AUDIO.StartingF = deviceExtension->PausedF;
#line 6059
                            cdb->PLAY_AUDIO.EndingM = deviceExtension->LastEndM;
#line 6060
                            cdb->PLAY_AUDIO.EndingS = deviceExtension->LastEndS;
#line 6061
                            cdb->PLAY_AUDIO.EndingF = deviceExtension->LastEndF;
#line 6062
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 6065
                            if (status >= 0L) {
#line 6066
                              deviceExtension->Paused = (unsigned char)0;
                            } else {

                            }
                            goto switch_15_break;
                            switch_15_exp_44: 
                            {
#line 6073
                            userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 6074
                            tmp___3 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ),
                                                            541156419UL);
#line 6076
                            SubQPtr = (UCHAR *)tmp___3;
                            }
#line 6078
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 6079
                              status = -1073741789L;
#line 6080
                              Irp->IoStatus.Information = 0UL;
#line 6081
                              if (SubQPtr) {

                              } else {

                              }
                              goto switch_15_break;
                            } else {

                            }
#line 6092
                            if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
#line 6093
                              status = -1073741670L;
#line 6094
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 6099
                            if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
#line 6102
                              status = -1073741823L;
#line 6103
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 6109
                            srb.CdbLength = (unsigned char)12;
#line 6110
                            srb.TimeOutValue = 10UL;
#line 6111
                            cdb->AUDIO_STATUS.OperationCode = (unsigned char)229;
                            Retry: 
                            {
#line 6114
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)SubQPtr,
                                                        (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ));
                            }
#line 6117
                            if (status >= 0L) {
                              goto _L;
                            } else {
#line 6120
                              if (status == -1073741764L) {
                                _L: 
#line 6122
                                if (((int )*(SubQPtr + 1) & 15) != 1) {
                                  goto Retry;
                                } else {

                                }
#line 6127
                                userPtr->Header.Reserved = (unsigned char)0;
#line 6128
                                if ((int )deviceExtension->Paused == 1) {
#line 6129
                                  deviceExtension->PlayActive = (unsigned char)0;
#line 6130
                                  userPtr->Header.AudioStatus = (unsigned char)18;
                                } else {
#line 6132
                                  if ((int )*(SubQPtr + 0) == 1) {
#line 6133
                                    userPtr->Header.AudioStatus = (unsigned char)17;
                                  } else {
#line 6135
                                    if ((int )*(SubQPtr + 0) == 0) {
#line 6136
                                      userPtr->Header.AudioStatus = (unsigned char)19;
#line 6137
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    } else {
#line 6139
                                      deviceExtension->PlayActive = (unsigned char)0;
                                    }
                                  }
                                }
#line 6143
                                userPtr->Header.DataLength[0] = (unsigned char)0;
#line 6144
                                userPtr->Header.DataLength[0] = (unsigned char)12;
#line 6145
                                userPtr->FormatCode = (unsigned char)1;
#line 6146
                                userPtr->Control = (unsigned char )(((int )*(SubQPtr + 1) & 240) >> 4);
#line 6147
                                userPtr->ADR = (unsigned char )((int )*(SubQPtr + 1) & 15);
#line 6148
                                userPtr->TrackNumber = *(SubQPtr + 2);
#line 6149
                                userPtr->IndexNumber = *(SubQPtr + 3);
#line 6150
                                userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 6151
                                userPtr->AbsoluteAddress[1] = *(SubQPtr + 8);
#line 6152
                                userPtr->AbsoluteAddress[2] = *(SubQPtr + 9);
#line 6153
                                userPtr->AbsoluteAddress[3] = *(SubQPtr + 10);
#line 6154
                                userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 6155
                                userPtr->TrackRelativeAddress[1] = *(SubQPtr + 4);
#line 6156
                                userPtr->TrackRelativeAddress[2] = *(SubQPtr + 5);
#line 6157
                                userPtr->TrackRelativeAddress[3] = *(SubQPtr + 6);
#line 6158
                                Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
#line 6159
                                status = 0L;
                              } else {
#line 6161
                                Irp->IoStatus.Information = 0UL;
                              }
                            }
                            goto switch_15_break;
                            switch_15_exp_45: 
                            {
#line 6170
                            tmp___4 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, 1UL,
                                                            541156419UL);
#line 6171
                            EjectStatus = (UCHAR *)tmp___4;
#line 6172
                            Irp->IoStatus.Information = 0UL;
                            }
#line 6174
                            if ((unsigned int )EjectStatus == (unsigned int )((void *)0)) {
#line 6175
                              status = -1073741670L;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 6181
                            deviceExtension->PlayActive = (unsigned char)0;
#line 6182
                            srb.CdbLength = (unsigned char)12;
#line 6183
                            srb.TimeOutValue = 10UL;
#line 6184
                            cdb->EJECT.OperationCode = (unsigned char)228;
#line 6185
                            cdb->EJECT.Eject = (unsigned char)1;
#line 6186
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)EjectStatus,
                                                        1UL);
                            }
#line 6189
                            if (status >= 0L) {
#line 6190
                              deviceExtension->Paused = (unsigned char)0;
#line 6191
                              deviceExtension->PausedM = (unsigned char)0;
#line 6192
                              deviceExtension->PausedS = (unsigned char)0;
#line 6193
                              deviceExtension->PausedF = (unsigned char)0;
#line 6194
                              deviceExtension->LastEndM = (unsigned char)0;
#line 6195
                              deviceExtension->LastEndS = (unsigned char)0;
#line 6196
                              deviceExtension->LastEndF = (unsigned char)0;
                            } else {

                            }
                            goto switch_15_break;
                            switch_15_exp_46: ;
                            switch_15_exp_47: ;
                            switch_15_exp_48: 
#line 6207
                            Irp->IoStatus.Information = 0UL;
#line 6208
                            status = -1073741808L;
                            goto switch_15_break;
                            switch_15_exp_49: 
                            {
#line 6212
                            CdAudioIsPlayActive(DeviceObject);
                            }
                            switch_15_default: 
                            {
#line 6216
                            tmp___5 = CdAudioSendToNextDriver(DeviceObject, Irp);
                            }
#line 6218
                            return (tmp___5);
                            goto switch_15_break;
                          } else {
                            switch_15_break: ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 6237
  if (status == -2147483626L) {
#line 6238
    if ((int )currentIrpStack->Flags & 2) {
#line 6239
      status = -1073741435L;
      goto HitachiRestart;
    } else {

    }
#line 6246
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 6252
  Irp->IoStatus.__annonCompField4.Status = status;
#line 6253
  myStatus = (int )status;
#line 6254
  IofCompleteRequest(Irp, (char)0);
  }
#line 6256
  return (status);
}
}
#line 6259 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudio535DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PREAD_CAPACITY_DATA lastSession ;
  PCDB cdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG bytesTransfered ;
  PUCHAR Toc ;
  ULONG destblock ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  BOOLEAN tmp___1 ;
  PVOID tmp___2 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr ;
  PVOID tmp___3 ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  NTSTATUS tmp___4 ;

  {
  {
#line 6287
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6288
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6289
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 6290
  cdb = (union _CDB *)(srb.Cdb);
#line 6291
  memset((void *)cdb, 0, 12U);
  }
#line 6293
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (14 << 2))) {
    goto switch_18_exp_50;
  } else {
#line 6296
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
      goto switch_18_exp_51;
    } else {
#line 6299
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
        goto switch_18_exp_52;
      } else {
#line 6302
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
          goto switch_18_exp_53;
        } else {
#line 6305
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
            goto switch_18_exp_54;
          } else {
#line 6308
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
              goto switch_18_exp_55;
            } else {
#line 6311
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                goto switch_18_exp_56;
              } else {
#line 6314
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                  goto switch_18_exp_57;
                } else {
#line 6317
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                    goto switch_18_exp_58;
                  } else {
#line 6320
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                      goto switch_18_exp_59;
                    } else {
                      goto switch_18_default;
#line 6325
                      if (0) {
                        switch_18_exp_50: 
                        {
#line 6328
                        tmp = CdAudioIsPlayActive(DeviceObject);
                        }
#line 6330
                        if (tmp) {
#line 6331
                          status = -2147483631L;
#line 6332
                          Irp->IoStatus.Information = 0UL;
                          goto switch_18_break;
                        } else {

                        }
#line 6337
                        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[1]))) {
#line 6338
                          status = -1073741789L;
#line 6339
                          Irp->IoStatus.Information = 0UL;
                          goto switch_18_break;
                        } else {

                        }
                        {
#line 6345
                        tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(READ_CAPACITY_DATA ),
                                                        541156419UL);
#line 6347
                        lastSession = (struct _READ_CAPACITY_DATA *)tmp___0;
                        }
#line 6349
                        if ((unsigned int )lastSession == (unsigned int )((void *)0)) {
#line 6350
                          status = -1073741670L;
#line 6351
                          Irp->IoStatus.Information = 0UL;
                          goto SetStatusAndReturn;
                        } else {

                        }
                        {
#line 6357
                        memset((void *)lastSession, 0, sizeof(READ_CAPACITY_DATA ));
#line 6358
                        srb.CdbLength = (unsigned char)10;
#line 6359
                        cdb->CDB10.OperationCode = (unsigned char)38;
#line 6360
                        srb.TimeOutValue = 10UL;
#line 6361
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)lastSession,
                                                    (unsigned long )sizeof(READ_CAPACITY_DATA ));
                        }
#line 6364
                        if (! (status >= 0L)) {
#line 6367
                          Irp->IoStatus.Information = 0UL;
                          goto SetStatusAndReturn;
                        } else {
#line 6371
                          status = 0L;
                        }
                        {
#line 6374
                        bytesTransfered = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[1]));
#line 6375
                        Irp->IoStatus.Information = bytesTransfered;
#line 6376
                        memset((void *)cdaudioDataOut, 0, (unsigned int )bytesTransfered);
#line 6377
                        cdaudioDataOut->Length[0] = (unsigned char )((bytesTransfered - 2UL) >> 8);
#line 6378
                        cdaudioDataOut->Length[1] = (unsigned char )((bytesTransfered - 2UL) & 255UL);
                        }
#line 6380
                        if (lastSession->LogicalBlockAddress == 0UL) {
                          goto switch_18_break;
                        } else {

                        }
#line 6389
                        cdaudioDataOut->FirstTrack = (unsigned char)1;
#line 6390
                        cdaudioDataOut->LastTrack = (unsigned char)2;
#line 6391
                        *((ULONG *)(& cdaudioDataOut->TrackData[0].Address[0])) = lastSession->LogicalBlockAddress;
                        goto switch_18_break;
                        switch_18_exp_51: ;
#line 6396
                        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 6397
                          status = -1073741789L;
#line 6398
                          Irp->IoStatus.Information = 0UL;
                          goto switch_18_break;
                        } else {

                        }
                        {
#line 6404
                        tmp___1 = CdAudioIsPlayActive(DeviceObject);
                        }
#line 6406
                        if (tmp___1) {
#line 6407
                          status = -2147483631L;
#line 6408
                          Irp->IoStatus.Information = 0UL;
                          goto switch_18_break;
                        } else {

                        }
                        {
#line 6414
                        tmp___2 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(CDROM_TOC ),
                                                        541156419UL);
#line 6415
                        Toc = (UCHAR *)tmp___2;
                        }
#line 6417
                        if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 6418
                          status = -1073741670L;
#line 6419
                          Irp->IoStatus.Information = 0UL;
                          goto SetStatusAndReturn;
                        } else {

                        }
                        {
#line 6425
                        memset((void *)Toc, 0, sizeof(CDROM_TOC ));
#line 6426
                        cdb->CDB10.OperationCode = (unsigned char)67;
#line 6427
                        cdb->CDB10.Reserved1 = (unsigned char)1;
#line 6428
                        cdb->CDB10.TransferBlocksMsb = (unsigned char )(sizeof(CDROM_TOC ) >> 8);
#line 6429
                        cdb->CDB10.TransferBlocksLsb = (unsigned char )(sizeof(CDROM_TOC ) & 255U);
#line 6430
                        srb.TimeOutValue = 10UL;
#line 6431
                        srb.CdbLength = (unsigned char)10;
#line 6432
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)Toc,
                                                    (unsigned long )sizeof(CDROM_TOC ));
                        }
#line 6434
                        if (! (status >= 0L)) {
#line 6435
                          if (status != -1073741764L) {
#line 6436
                            if (status != -1073741764L) {
#line 6439
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
                          } else {
#line 6446
                            status = 0L;
                          }
                        } else {
#line 6449
                          status = 0L;
                        }
#line 6451
                        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > (unsigned long )sizeof(CDROM_TOC )) {
#line 6452
                          bytesTransfered = (unsigned long )sizeof(CDROM_TOC );
                        } else {
#line 6454
                          bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                        }
#line 6456
                        cdaudioDataOut->Length[0] = *(Toc + 0);
#line 6457
                        cdaudioDataOut->Length[1] = *(Toc + 1);
#line 6458
                        cdaudioDataOut->FirstTrack = (unsigned char )((((int )*(Toc + 2) & 240) >> 4) * 10 + ((int )*(Toc + 2) & 15));
#line 6459
                        cdaudioDataOut->LastTrack = (unsigned char )((((int )*(Toc + 3) & 240) >> 4) * 10 + ((int )*(Toc + 3) & 15));
#line 6460
                        tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 6461
                        tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 6462
                        tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 6463
                        if (tracksInBuffer < tracksOnCd) {
#line 6464
                          tracksToReturn = tracksInBuffer;
                        } else {
#line 6466
                          tracksToReturn = tracksOnCd;
                        }
#line 6468
                        i = 0UL;
                        {
#line 6470
                        while (1) {
                          while_11_continue: /* CIL Label */ ;

#line 6472
                          if (i < tracksToReturn) {

                          } else {
                            goto while_19_break;
                          }
#line 6477
                          cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 6478
                          cdaudioDataOut->TrackData[i].Control = *(Toc + ((i * 8UL + 4UL) + 1UL));
#line 6479
                          cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )((((int )*(Toc + ((i * 8UL + 4UL) + 2UL)) & 240) >> 4) * 10 + ((int )*(Toc + ((i * 8UL + 4UL) + 2UL)) & 15));
#line 6480
                          cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 6481
                          cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 6482
                          cdaudioDataOut->TrackData[i].Address[1] = *(Toc + ((i * 8UL + 4UL) + 5UL));
#line 6483
                          cdaudioDataOut->TrackData[i].Address[2] = *(Toc + ((i * 8UL + 4UL) + 6UL));
#line 6484
                          cdaudioDataOut->TrackData[i].Address[3] = *(Toc + ((i * 8UL + 4UL) + 7UL));
#line 6485
                          i += 1UL;
                        }
                        while_11_break: /* CIL Label */ ;
                        }
                        while_19_break: ;
#line 6489
                        if (tracksInBuffer > tracksOnCd) {
#line 6490
                          cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 6491
                          cdaudioDataOut->TrackData[i].Control = *(Toc + ((i * 8UL + 4UL) + 1UL));
#line 6492
                          cdaudioDataOut->TrackData[i].TrackNumber = *(Toc + ((i * 8UL + 4UL) + 2UL));
#line 6493
                          cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 6494
                          cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 6495
                          cdaudioDataOut->TrackData[i].Address[1] = *(Toc + ((i * 8UL + 4UL) + 5UL));
#line 6496
                          cdaudioDataOut->TrackData[i].Address[2] = *(Toc + ((i * 8UL + 4UL) + 6UL));
#line 6497
                          cdaudioDataOut->TrackData[i].Address[3] = *(Toc + ((i * 8UL + 4UL) + 7UL));
#line 6498
                          i += 1UL;
                        } else {

                        }
#line 6503
                        Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
                        goto switch_18_break;
                        switch_18_exp_52: 
                        {
#line 6509
                        userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 6510
                        tmp___3 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(SUB_Q_CURRENT_POSITION ),
                                                        541156419UL);
#line 6512
                        SubQPtr = (UCHAR *)tmp___3;
                        }
#line 6514
                        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 6515
                          status = -1073741789L;
#line 6516
                          Irp->IoStatus.Information = 0UL;
#line 6517
                          if (SubQPtr) {

                          } else {

                          }
                          goto switch_18_break;
                        } else {

                        }
#line 6528
                        if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
                          {
#line 6530
                          memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 6531
                          status = -1073741670L;
#line 6532
                          Irp->IoStatus.Information = 0UL;
                          }
                          goto SetStatusAndReturn;
                        } else {

                        }
#line 6538
                        if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
                          {
#line 6541
                          memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 6542
                          status = -1073741823L;
#line 6543
                          Irp->IoStatus.Information = 0UL;
                          }
                          goto SetStatusAndReturn;
                        } else {

                        }
                        {
#line 6550
                        srb.CdbLength = (unsigned char)10;
#line 6551
                        srb.TimeOutValue = 10UL;
#line 6552
                        cdb->SUBCHANNEL.OperationCode = (unsigned char)66;
#line 6553
                        cdb->SUBCHANNEL.Msf = (unsigned char)1;
#line 6554
                        cdb->SUBCHANNEL.SubQ = (unsigned char)1;
#line 6555
                        cdb->SUBCHANNEL.Format = (unsigned char)1;
#line 6556
                        cdb->SUBCHANNEL.AllocationLength[1] = (unsigned char )sizeof(SUB_Q_CURRENT_POSITION );
#line 6557
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)SubQPtr,
                                                    (unsigned long )sizeof(SUB_Q_CURRENT_POSITION ));
                        }
#line 6560
                        if (status >= 0L) {
#line 6561
                          if ((int )*(SubQPtr + 1) == 17) {
#line 6562
                            deviceExtension->PlayActive = (unsigned char)1;
                          } else {
#line 6564
                            deviceExtension->PlayActive = (unsigned char)0;
                          }
#line 6566
                          userPtr->Header.Reserved = (unsigned char)0;
#line 6567
                          userPtr->Header.AudioStatus = *(SubQPtr + 1);
#line 6568
                          userPtr->Header.DataLength[0] = (unsigned char)0;
#line 6569
                          userPtr->Header.DataLength[1] = (unsigned char)12;
#line 6570
                          userPtr->FormatCode = (unsigned char)1;
#line 6571
                          userPtr->Control = *(SubQPtr + 5);
#line 6572
                          userPtr->ADR = (unsigned char)0;
#line 6573
                          userPtr->TrackNumber = (unsigned char )((((int )*(SubQPtr + 6) & 240) >> 4) * 10 + ((int )*(SubQPtr + 6) & 15));
#line 6574
                          userPtr->IndexNumber = (unsigned char )((((int )*(SubQPtr + 7) & 240) >> 4) * 10 + ((int )*(SubQPtr + 7) & 15));
#line 6575
                          userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 6576
                          userPtr->AbsoluteAddress[1] = *(SubQPtr + 9);
#line 6577
                          userPtr->AbsoluteAddress[2] = *(SubQPtr + 10);
#line 6578
                          userPtr->AbsoluteAddress[3] = *(SubQPtr + 11);
#line 6579
                          userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 6580
                          userPtr->TrackRelativeAddress[1] = *(SubQPtr + 13);
#line 6581
                          userPtr->TrackRelativeAddress[2] = *(SubQPtr + 14);
#line 6582
                          userPtr->TrackRelativeAddress[3] = *(SubQPtr + 15);
#line 6583
                          Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
                        } else {
#line 6585
                          Irp->IoStatus.Information = 0UL;
                        }
                        goto switch_18_break;
                        switch_18_exp_53: 
#line 6592
                        inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 6593
                        Irp->IoStatus.Information = 0UL;
#line 6594
                        if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 6595
                          status = -1073741820L;
                          goto switch_18_break;
                        } else {

                        }
#line 6600
                        if ((int )inputBuffer->StartingM == (int )inputBuffer->EndingM) {
#line 6601
                          if ((int )inputBuffer->StartingS == (int )inputBuffer->EndingS) {
#line 6602
                            if ((int )inputBuffer->StartingF == (int )inputBuffer->EndingF) {
#line 6603
                              cdb->PAUSE_RESUME.OperationCode = (unsigned char)75;
#line 6604
                              cdb->PAUSE_RESUME.Action = (unsigned char)0;
                            } else {
                              goto _L___0;
                            }
                          } else {
                            goto _L___0;
                          }
                        } else {
                          _L___0: 
#line 6613
                          cdb->PLAY_AUDIO_MSF.OperationCode = (unsigned char)71;
#line 6614
                          cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
#line 6615
                          cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
#line 6616
                          cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;
#line 6617
                          cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer->EndingM;
#line 6618
                          cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer->EndingS;
#line 6619
                          cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer->EndingF;
                        }
                        {
#line 6622
                        srb.CdbLength = (unsigned char)10;
#line 6623
                        srb.TimeOutValue = 10UL;
#line 6624
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                    0UL);
                        }
#line 6627
                        if (status >= 0L) {
#line 6628
                          if ((int )cdb->PLAY_AUDIO_MSF.OperationCode == 71) {
#line 6629
                            deviceExtension->PlayActive = (unsigned char)1;
                          } else {

                          }
                        } else {

                        }
                        goto switch_18_break;
                        switch_18_exp_54: 
#line 6638
                        inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 6639
                        Irp->IoStatus.Information = 0UL;
#line 6640
                        if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 6641
                          status = -1073741820L;
                          goto switch_18_break;
                        } else {

                        }
                        {
#line 6647
                        destblock = (((unsigned long )inputBuffer___0->M * 60UL + (unsigned long )inputBuffer___0->S) * 75UL + (unsigned long )inputBuffer___0->F) - 150UL;
#line 6648
                        srb.CdbLength = (unsigned char)10;
#line 6649
                        srb.TimeOutValue = 10UL;
#line 6650
                        cdb->SEEK.OperationCode = (unsigned char)43;
#line 6651
                        cdb->SEEK.LogicalBlockAddress[0] = (unsigned char )((int )((unsigned char )(destblock >> 24)) & 255);
#line 6652
                        cdb->SEEK.LogicalBlockAddress[1] = (unsigned char )((int )((unsigned char )(destblock >> 16)) & 255);
#line 6653
                        cdb->SEEK.LogicalBlockAddress[2] = (unsigned char )((int )((unsigned char )(destblock >> 8)) & 255);
#line 6654
                        cdb->SEEK.LogicalBlockAddress[3] = (unsigned char )(destblock & 255UL);
#line 6655
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                    0UL);
                        }
#line 6658
                        if (! (status >= 0L)) {

                        } else {

                        }
                        goto switch_18_break;
                        switch_18_exp_55: 
                        {
#line 6666
                        Irp->IoStatus.Information = 0UL;
#line 6667
                        deviceExtension->PlayActive = (unsigned char)0;
#line 6668
                        srb.CdbLength = (unsigned char)10;
#line 6669
                        srb.TimeOutValue = 10UL;
#line 6670
                        cdb->CDB10.OperationCode = (unsigned char)192;
#line 6671
                        status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                    0UL);
                        }
                        goto switch_18_break;
                        switch_18_exp_56: ;
                        switch_18_exp_57: ;
                        switch_18_exp_58: 
#line 6678
                        Irp->IoStatus.Information = 0UL;
#line 6679
                        status = -1073741808L;
                        goto switch_18_break;
                        switch_18_exp_59: 
                        {
#line 6683
                        CdAudioIsPlayActive(DeviceObject);
                        }
                        switch_18_default: 
                        {
#line 6687
                        tmp___4 = CdAudioSendToNextDriver(DeviceObject, Irp);
                        }
#line 6689
                        return (tmp___4);
                        goto switch_18_break;
                      } else {
                        switch_18_break: ;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 6706
  if (status == -2147483626L) {
#line 6709
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 6715
  Irp->IoStatus.__annonCompField4.Status = status;
#line 6716
  myStatus = (int )status;
#line 6717
  IofCompleteRequest(Irp, (char)0);
  }
#line 6719
  return (status);
}
}
#line 6722 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudio435DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PCDROM_TOC cdaudioDataOut ;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb ;
  NTSTATUS status ;
  ULONG i ;
  ULONG bytesTransfered ;
  PUCHAR Toc ;
  BOOLEAN tmp ;
  PVOID tmp___0 ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PCDROM_SEEK_AUDIO_MSF inputBuffer___0 ;
  PUCHAR SubQPtr ;
  PVOID tmp___1 ;
  PSUB_Q_CURRENT_POSITION userPtr ;
  PUCHAR SubQPtr___0 ;
  PVOID tmp___2 ;
  NTSTATUS tmp___3 ;
  BOOLEAN tmp___4 ;
  NTSTATUS tmp___5 ;

  {
  {
#line 6750
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 6751
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 6752
  cdaudioDataOut = (struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer;
#line 6753
  cdb = (union _CDB *)(srb.Cdb);
#line 6754
  memset((void *)cdb, 0, 12U);
  }
#line 6756
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )((2 << 16) | (1 << 14))) {
    goto switch_20_exp_60;
  } else {
#line 6759
    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (6 << 2))) {
      goto switch_20_exp_61;
    } else {
#line 6762
      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (2 << 2))) {
        goto switch_20_exp_62;
      } else {
#line 6765
        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (1 << 2))) {
          goto switch_20_exp_63;
        } else {
#line 6768
          if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (3 << 2))) {
            goto switch_20_exp_64;
          } else {
#line 6771
            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (4 << 2))) {
              goto switch_20_exp_65;
            } else {
#line 6774
              if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (11 << 2))) {
                goto switch_20_exp_66;
              } else {
#line 6777
                if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (514 << 2))) {
                  goto switch_20_exp_67;
                } else {
#line 6780
                  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (13 << 2))) {
                    goto switch_20_exp_68;
                  } else {
#line 6783
                    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (5 << 2))) {
                      goto switch_20_exp_69;
                    } else {
#line 6786
                      if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (10 << 2))) {
                        goto switch_20_exp_70;
                      } else {
#line 6789
                        if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (ULONG )(((2 << 16) | (1 << 14)) | (512 << 2))) {
                          goto switch_20_exp_71;
                        } else {
                          goto switch_20_default;
#line 6794
                          if (0) {
                            switch_20_exp_60: ;
#line 6796
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]))) {
#line 6797
                              status = -1073741789L;
#line 6798
                              Irp->IoStatus.Information = 0UL;
                              goto switch_20_break;
                            } else {

                            }
                            {
#line 6804
                            tmp = CdAudioIsPlayActive(DeviceObject);
                            }
#line 6806
                            if (tmp) {
#line 6807
                              status = -2147483631L;
#line 6808
                              Irp->IoStatus.Information = 0UL;
                              goto switch_20_break;
                            } else {

                            }
                            {
#line 6814
                            tmp___0 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(CDROM_TOC ),
                                                            541156419UL);
#line 6816
                            Toc = (UCHAR *)tmp___0;
                            }
#line 6818
                            if ((unsigned int )Toc == (unsigned int )((void *)0)) {
#line 6819
                              status = -1073741670L;
#line 6820
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 6826
                            memset((void *)Toc, 0, sizeof(CDROM_TOC ));
#line 6827
                            cdb->READ_TOC.OperationCode = (unsigned char)67;
#line 6828
                            cdb->READ_TOC.Msf = (unsigned char)1;
#line 6829
                            cdb->READ_TOC.AllocationLength[0] = (unsigned char )(sizeof(CDROM_TOC ) >> 8);
#line 6830
                            cdb->READ_TOC.AllocationLength[1] = (unsigned char )(sizeof(CDROM_TOC ) & 255U);
#line 6831
                            srb.TimeOutValue = 10UL;
#line 6832
                            srb.CdbLength = (unsigned char)10;
#line 6833
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)Toc,
                                                        (unsigned long )sizeof(CDROM_TOC ));
                            }
#line 6836
                            if (! (status >= 0L)) {
#line 6837
                              if (status != -1073741764L) {
#line 6838
                                if (status != -1073741764L) {
#line 6841
                                  Irp->IoStatus.Information = 0UL;
                                  goto SetStatusAndReturn;
                                } else {

                                }
                              } else {
#line 6848
                                status = 0L;
                              }
                            } else {
#line 6851
                              status = 0L;
                            }
#line 6853
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength > (unsigned long )sizeof(CDROM_TOC )) {
#line 6854
                              bytesTransfered = (unsigned long )sizeof(CDROM_TOC );
                            } else {
#line 6856
                              bytesTransfered = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
                            }
#line 6858
                            cdaudioDataOut->Length[0] = *(Toc + 0);
#line 6859
                            cdaudioDataOut->Length[1] = *(Toc + 1);
#line 6860
                            cdaudioDataOut->FirstTrack = (unsigned char )((((int )*(Toc + 2) & 240) >> 4) * 10 + ((int )*(Toc + 2) & 15));
#line 6861
                            cdaudioDataOut->LastTrack = (unsigned char )((((int )*(Toc + 3) & 240) >> 4) * 10 + ((int )*(Toc + 3) & 15));
#line 6862
                            tracksOnCd = (unsigned long )(((int )cdaudioDataOut->LastTrack - (int )cdaudioDataOut->FirstTrack) + 1);
#line 6863
                            tracksInBuffer = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength - (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[0]));
#line 6864
                            tracksInBuffer /= (unsigned long )sizeof(TRACK_DATA );
#line 6865
                            if (tracksInBuffer < tracksOnCd) {
#line 6866
                              tracksToReturn = tracksInBuffer;
                            } else {
#line 6868
                              tracksToReturn = tracksOnCd;
                            }
#line 6870
                            i = 0UL;
                            {
#line 6872
                            while (1) {
                              while_12_continue: /* CIL Label */ ;

#line 6874
                              if (i < tracksToReturn) {

                              } else {
                                goto while_21_break;
                              }
#line 6879
                              cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 6880
                              cdaudioDataOut->TrackData[i].Control = *(Toc + ((i * 8UL + 4UL) + 1UL));
#line 6881
                              cdaudioDataOut->TrackData[i].TrackNumber = (unsigned char )((((int )*(Toc + ((i * 8UL + 4UL) + 2UL)) & 240) >> 4) * 10 + ((int )*(Toc + ((i * 8UL + 4UL) + 2UL)) & 15));
#line 6882
                              cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 6883
                              cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 6884
                              cdaudioDataOut->TrackData[i].Address[1] = *(Toc + ((i * 8UL + 4UL) + 5UL));
#line 6885
                              cdaudioDataOut->TrackData[i].Address[2] = *(Toc + ((i * 8UL + 4UL) + 6UL));
#line 6886
                              cdaudioDataOut->TrackData[i].Address[3] = *(Toc + ((i * 8UL + 4UL) + 7UL));
#line 6887
                              i += 1UL;
                            }
                            while_12_break: /* CIL Label */ ;
                            }
                            while_21_break: ;
#line 6891
                            if (tracksInBuffer > tracksOnCd) {
#line 6892
                              cdaudioDataOut->TrackData[i].Reserved = (unsigned char)0;
#line 6893
                              cdaudioDataOut->TrackData[i].Control = *(Toc + ((i * 8UL + 4UL) + 1UL));
#line 6894
                              cdaudioDataOut->TrackData[i].TrackNumber = *(Toc + ((i * 8UL + 4UL) + 2UL));
#line 6895
                              cdaudioDataOut->TrackData[i].Reserved1 = (unsigned char)0;
#line 6896
                              cdaudioDataOut->TrackData[i].Address[0] = (unsigned char)0;
#line 6897
                              cdaudioDataOut->TrackData[i].Address[1] = *(Toc + ((i * 8UL + 4UL) + 5UL));
#line 6898
                              cdaudioDataOut->TrackData[i].Address[2] = *(Toc + ((i * 8UL + 4UL) + 6UL));
#line 6899
                              cdaudioDataOut->TrackData[i].Address[3] = *(Toc + ((i * 8UL + 4UL) + 7UL));
#line 6900
                              i += 1UL;
                            } else {

                            }
#line 6905
                            Irp->IoStatus.Information = (unsigned long )((long )(& ((CDROM_TOC *)0)->TrackData[i]));
#line 6906
                            deviceExtension->Paused = (unsigned char)0;
#line 6907
                            deviceExtension->PausedM = (unsigned char)0;
#line 6908
                            deviceExtension->PausedS = (unsigned char)0;
#line 6909
                            deviceExtension->PausedF = (unsigned char)0;
#line 6910
                            deviceExtension->LastEndM = (unsigned char)0;
#line 6911
                            deviceExtension->LastEndS = (unsigned char)0;
#line 6912
                            deviceExtension->LastEndF = (unsigned char)0;
                            goto switch_20_break;
                            switch_20_exp_61: ;
                            switch_20_exp_62: 
                            {
#line 6919
                            inputBuffer = (struct _CDROM_PLAY_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 6920
                            Irp->IoStatus.Information = 0UL;
#line 6921
                            srb.CdbLength = (unsigned char)10;
#line 6922
                            srb.TimeOutValue = 10UL;
#line 6923
                            cdb->CDB10.OperationCode = (unsigned char)198;
#line 6924
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 6927
                            if (status >= 0L) {
#line 6928
                              deviceExtension->PlayActive = (unsigned char)0;
#line 6929
                              deviceExtension->Paused = (unsigned char)0;
#line 6930
                              deviceExtension->PausedM = (unsigned char)0;
#line 6931
                              deviceExtension->PausedS = (unsigned char)0;
#line 6932
                              deviceExtension->PausedF = (unsigned char)0;
#line 6933
                              deviceExtension->LastEndM = (unsigned char)0;
#line 6934
                              deviceExtension->LastEndS = (unsigned char)0;
#line 6935
                              deviceExtension->LastEndF = (unsigned char)0;
                            } else {

                            }
#line 6939
                            if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((2 << 16) | (1 << 14)) | (2 << 2))) {
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 6944
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_PLAY_AUDIO_MSF )) {
#line 6945
                              status = -1073741820L;
                              goto switch_20_break;
                            } else {

                            }
                            {
#line 6951
                            srb.CdbLength = (unsigned char)10;
#line 6952
                            srb.TimeOutValue = 10UL;
#line 6953
                            cdb->PLAY_AUDIO_MSF.OperationCode = (unsigned char)71;
#line 6954
                            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer->StartingM;
#line 6955
                            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer->StartingS;
#line 6956
                            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer->StartingF;
#line 6957
                            cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer->EndingM;
#line 6958
                            cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer->EndingS;
#line 6959
                            cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer->EndingF;
#line 6960
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 6963
                            if (status >= 0L) {
#line 6964
                              deviceExtension->PlayActive = (unsigned char)1;
#line 6965
                              deviceExtension->Paused = (unsigned char)0;
#line 6966
                              deviceExtension->LastEndM = inputBuffer->EndingM;
#line 6967
                              deviceExtension->LastEndS = inputBuffer->EndingS;
#line 6968
                              deviceExtension->LastEndF = inputBuffer->EndingF;
                            } else {

                            }
                            goto switch_20_break;
                            switch_20_exp_63: 
#line 6974
                            inputBuffer___0 = (struct _CDROM_SEEK_AUDIO_MSF *)Irp->AssociatedIrp.SystemBuffer;
#line 6975
                            Irp->IoStatus.Information = 0UL;
#line 6976
                            if (currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < (unsigned long )sizeof(CDROM_SEEK_AUDIO_MSF )) {
#line 6977
                              status = -1073741820L;
                              goto switch_20_break;
                            } else {

                            }
                            {
#line 6983
                            srb.CdbLength = (unsigned char)10;
#line 6984
                            srb.TimeOutValue = 10UL;
#line 6985
                            cdb->CDB10.OperationCode = (unsigned char)71;
#line 6986
                            cdb->PLAY_AUDIO_MSF.StartingM = inputBuffer___0->M;
#line 6987
                            cdb->PLAY_AUDIO_MSF.StartingS = inputBuffer___0->S;
#line 6988
                            cdb->PLAY_AUDIO_MSF.StartingF = inputBuffer___0->F;
#line 6989
                            cdb->PLAY_AUDIO_MSF.EndingM = inputBuffer___0->M;
#line 6990
                            cdb->PLAY_AUDIO_MSF.EndingS = inputBuffer___0->S;
#line 6991
                            cdb->PLAY_AUDIO_MSF.EndingF = inputBuffer___0->F;
#line 6992
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 6995
                            if (status >= 0L) {
#line 6996
                              deviceExtension->Paused = (unsigned char)1;
#line 6997
                              deviceExtension->PausedM = inputBuffer___0->M;
#line 6998
                              deviceExtension->PausedS = inputBuffer___0->S;
#line 6999
                              deviceExtension->PausedF = inputBuffer___0->F;
#line 7000
                              deviceExtension->LastEndM = inputBuffer___0->M;
#line 7001
                              deviceExtension->LastEndS = inputBuffer___0->S;
#line 7002
                              deviceExtension->LastEndF = inputBuffer___0->F;
                            } else {
#line 7004
                              if (status == -1073741808L) {
#line 7005
                                status = -1073741803L;
                              } else {

                              }
                            }
                            goto switch_20_break;
                            switch_20_exp_64: 
                            {
#line 7013
                            tmp___1 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ),
                                                            541156419UL);
#line 7015
                            SubQPtr = (UCHAR *)tmp___1;
#line 7016
                            Irp->IoStatus.Information = 0UL;
                            }
#line 7018
                            if ((unsigned int )SubQPtr == (unsigned int )((void *)0)) {
#line 7019
                              status = -1073741670L;
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 7024
                            if ((int )deviceExtension->Paused == 1) {
#line 7027
                              status = 0L;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 7034
                            srb.CdbLength = (unsigned char)10;
#line 7035
                            srb.TimeOutValue = 10UL;
#line 7036
                            cdb->SUBCHANNEL.OperationCode = (unsigned char)66;
#line 7037
                            cdb->SUBCHANNEL.Msf = (unsigned char)1;
#line 7038
                            cdb->SUBCHANNEL.SubQ = (unsigned char)1;
#line 7039
                            cdb->SUBCHANNEL.AllocationLength[1] = (unsigned char )sizeof(SUB_Q_CHANNEL_DATA );
#line 7040
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)SubQPtr,
                                                        (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ));
                            }
#line 7043
                            if (! (status >= 0L)) {
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 7052
                            deviceExtension->PausedM = *(SubQPtr + 9);
#line 7053
                            deviceExtension->PausedS = *(SubQPtr + 10);
#line 7054
                            deviceExtension->PausedF = *(SubQPtr + 11);
#line 7055
                            memset((void *)cdb, 0, 12U);
#line 7056
                            srb.CdbLength = (unsigned char)10;
#line 7057
                            srb.TimeOutValue = 10UL;
#line 7058
                            cdb->CDB10.OperationCode = (unsigned char)198;
#line 7059
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 7062
                            if (! (status >= 0L)) {
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 7071
                            deviceExtension->PlayActive = (unsigned char)0;
#line 7072
                            deviceExtension->Paused = (unsigned char)1;
#line 7073
                            deviceExtension->PausedM = *(SubQPtr + 9);
#line 7074
                            deviceExtension->PausedS = *(SubQPtr + 10);
#line 7075
                            deviceExtension->PausedF = *(SubQPtr + 11);
                            goto switch_20_break;
                            switch_20_exp_65: 
#line 7080
                            Irp->IoStatus.Information = 0UL;
#line 7081
                            if ((int )deviceExtension->Paused == 0) {
#line 7082
                              status = -1073741823L;
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 7088
                            srb.CdbLength = (unsigned char)10;
#line 7089
                            srb.TimeOutValue = 10UL;
#line 7090
                            cdb->PLAY_AUDIO_MSF.OperationCode = (unsigned char)71;
#line 7091
                            cdb->PLAY_AUDIO_MSF.StartingM = deviceExtension->PausedM;
#line 7092
                            cdb->PLAY_AUDIO_MSF.StartingS = deviceExtension->PausedS;
#line 7093
                            cdb->PLAY_AUDIO_MSF.StartingF = deviceExtension->PausedF;
#line 7094
                            cdb->PLAY_AUDIO_MSF.EndingM = deviceExtension->LastEndM;
#line 7095
                            cdb->PLAY_AUDIO_MSF.EndingS = deviceExtension->LastEndS;
#line 7096
                            cdb->PLAY_AUDIO_MSF.EndingF = deviceExtension->LastEndF;
#line 7097
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
                            }
#line 7100
                            if (status >= 0L) {
#line 7101
                              deviceExtension->PlayActive = (unsigned char)1;
#line 7102
                              deviceExtension->Paused = (unsigned char)0;
                            } else {

                            }
                            goto switch_20_break;
                            switch_20_exp_66: 
                            {
#line 7109
                            userPtr = (struct _SUB_Q_CURRENT_POSITION *)Irp->AssociatedIrp.SystemBuffer;
#line 7110
                            tmp___2 = ExAllocatePoolWithTag((enum _POOL_TYPE )4, (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ),
                                                            541156419UL);
#line 7112
                            SubQPtr___0 = (UCHAR *)tmp___2;
                            }
#line 7114
                            if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength < (unsigned long )sizeof(SUB_Q_CURRENT_POSITION )) {
#line 7115
                              status = -1073741789L;
#line 7116
                              Irp->IoStatus.Information = 0UL;
#line 7117
                              if (SubQPtr___0) {

                              } else {

                              }
                              goto switch_20_break;
                            } else {

                            }
#line 7128
                            if ((unsigned int )SubQPtr___0 == (unsigned int )((void *)0)) {
                              {
#line 7130
                              memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 7131
                              status = -1073741670L;
#line 7132
                              Irp->IoStatus.Information = 0UL;
                              }
                              goto SetStatusAndReturn;
                            } else {

                            }
#line 7138
                            if ((int )((struct _CDROM_SUB_Q_DATA_FORMAT *)userPtr)->Format != 1) {
                              {
#line 7141
                              memset((void *)userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION ));
#line 7142
                              status = -1073741823L;
#line 7143
                              Irp->IoStatus.Information = 0UL;
                              }
                              goto SetStatusAndReturn;
                            } else {

                            }
                            {
#line 7150
                            srb.CdbLength = (unsigned char)10;
#line 7151
                            srb.TimeOutValue = 10UL;
#line 7152
                            cdb->SUBCHANNEL.OperationCode = (unsigned char)66;
#line 7153
                            cdb->SUBCHANNEL.Msf = (unsigned char)1;
#line 7154
                            cdb->SUBCHANNEL.SubQ = (unsigned char)1;
#line 7155
                            cdb->SUBCHANNEL.AllocationLength[1] = (unsigned char )sizeof(SUB_Q_CHANNEL_DATA );
#line 7156
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)SubQPtr___0,
                                                        (unsigned long )sizeof(SUB_Q_CHANNEL_DATA ));
                            }
#line 7159
                            if (status >= 0L) {
#line 7160
                              userPtr->Header.Reserved = (unsigned char)0;
#line 7161
                              if ((int )deviceExtension->Paused == 1) {
#line 7162
                                deviceExtension->PlayActive = (unsigned char)0;
#line 7163
                                userPtr->Header.AudioStatus = (unsigned char)18;
                              } else {
#line 7165
                                if ((int )*(SubQPtr___0 + 1) == 17) {
#line 7166
                                  deviceExtension->PlayActive = (unsigned char)1;
#line 7167
                                  userPtr->Header.AudioStatus = (unsigned char)17;
                                } else {
#line 7169
                                  deviceExtension->PlayActive = (unsigned char)0;
#line 7170
                                  userPtr->Header.AudioStatus = (unsigned char)19;
                                }
                              }
#line 7173
                              userPtr->Header.DataLength[0] = (unsigned char)0;
#line 7174
                              userPtr->Header.DataLength[1] = (unsigned char)12;
#line 7175
                              userPtr->FormatCode = (unsigned char)1;
#line 7176
                              userPtr->Control = *(SubQPtr___0 + 5);
#line 7177
                              userPtr->ADR = (unsigned char)0;
#line 7178
                              userPtr->TrackNumber = (unsigned char )((((int )*(SubQPtr___0 + 6) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 6) & 15));
#line 7179
                              userPtr->IndexNumber = (unsigned char )((((int )*(SubQPtr___0 + 7) & 240) >> 4) * 10 + ((int )*(SubQPtr___0 + 7) & 15));
#line 7180
                              userPtr->AbsoluteAddress[0] = (unsigned char)0;
#line 7181
                              userPtr->AbsoluteAddress[1] = *(SubQPtr___0 + 9);
#line 7182
                              userPtr->AbsoluteAddress[2] = *(SubQPtr___0 + 10);
#line 7183
                              userPtr->AbsoluteAddress[3] = *(SubQPtr___0 + 11);
#line 7184
                              userPtr->TrackRelativeAddress[0] = (unsigned char)0;
#line 7185
                              userPtr->TrackRelativeAddress[1] = *(SubQPtr___0 + 13);
#line 7186
                              userPtr->TrackRelativeAddress[2] = *(SubQPtr___0 + 14);
#line 7187
                              userPtr->TrackRelativeAddress[3] = *(SubQPtr___0 + 15);
#line 7188
                              Irp->IoStatus.Information = (unsigned long )sizeof(SUB_Q_CURRENT_POSITION );
                            } else {
#line 7190
                              Irp->IoStatus.Information = 0UL;
                            }
                            goto switch_20_break;
                            switch_20_exp_67: 
                            {
#line 7198
                            Irp->IoStatus.Information = 0UL;
#line 7199
                            srb.CdbLength = (unsigned char)10;
#line 7200
                            srb.TimeOutValue = 10UL;
#line 7201
                            cdb->CDB10.OperationCode = (unsigned char)192;
#line 7202
                            status = SendSrbSynchronous(deviceExtension, & srb, (void *)0,
                                                        0UL);
#line 7204
                            deviceExtension->Paused = (unsigned char)0;
#line 7205
                            deviceExtension->PausedM = (unsigned char)0;
#line 7206
                            deviceExtension->PausedS = (unsigned char)0;
#line 7207
                            deviceExtension->PausedF = (unsigned char)0;
#line 7208
                            deviceExtension->LastEndM = (unsigned char)0;
#line 7209
                            deviceExtension->LastEndS = (unsigned char)0;
#line 7210
                            deviceExtension->LastEndF = (unsigned char)0;
                            }
                            goto switch_20_break;
                            switch_20_exp_68: ;
                            switch_20_exp_69: ;
                            switch_20_exp_70: 
#line 7216
                            Irp->IoStatus.Information = 0UL;
#line 7217
                            status = -1073741808L;
                            goto switch_20_break;
                            switch_20_exp_71: 
                            {
#line 7221
                            tmp___4 = CdAudioIsPlayActive(DeviceObject);
                            }
#line 7223
                            if ((int )tmp___4 == 1) {
#line 7224
                              deviceExtension->PlayActive = (unsigned char)1;
#line 7225
                              status = 0L;
#line 7226
                              Irp->IoStatus.Information = 0UL;
                              goto SetStatusAndReturn;
                            } else {
                              {
#line 7230
                              deviceExtension->PlayActive = (unsigned char)0;
#line 7231
                              tmp___3 = CdAudioSendToNextDriver(DeviceObject, Irp);
                              }
#line 7233
                              return (tmp___3);
                            }
                            goto switch_20_break;
                            switch_20_default: 
                            {
#line 7238
                            tmp___5 = CdAudioSendToNextDriver(DeviceObject, Irp);
                            }
#line 7240
                            return (tmp___5);
                            goto switch_20_break;
                          } else {
                            switch_20_break: ;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  SetStatusAndReturn: 
#line 7259
  if (status == -2147483626L) {
#line 7262
    Irp->IoStatus.Information = 0UL;
  } else {

  }
  {
#line 7268
  Irp->IoStatus.__annonCompField4.Status = status;
#line 7269
  myStatus = (int )status;
#line 7270
  IofCompleteRequest(Irp, (char)0);
  }
#line 7272
  return (status);
}
}
#line 7275 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioAtapiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ NTSTATUS status ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PIO_STACK_LOCATION currentIrpStack ;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb ;
  NTSTATUS tmp ;

  {
#line 7284
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7285
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7286
  cdb = (union _HITACHICDB *)(srb.Cdb);
#line 7287
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((2 << 16) | (1 << 14)) | (2 << 2))) {
    {
#line 7289
    Irp->IoStatus.Information = 0UL;
#line 7290
    deviceExtension->PlayActive = (unsigned char)0;
#line 7291
    memset((void *)(& srb), 0, sizeof(SCSI_PASS_THROUGH ));
#line 7292
    cdb->STOP_PLAY.OperationCode = (unsigned char)78;
#line 7293
    srb.CdbLength = (unsigned char)12;
#line 7294
    srb.TimeOutValue = 10UL;
#line 7295
    status = SendSrbSynchronous(deviceExtension, & srb, (void *)0, 0UL);
    }
#line 7297
    if (! (status >= 0L)) {
      {
#line 7299
      Irp->IoStatus.__annonCompField4.Status = status;
#line 7300
      myStatus = (int )status;
#line 7301
      IofCompleteRequest(Irp, (char)0);
      }
#line 7303
      return (status);
    } else {

    }
  } else {
    {
#line 7309
    tmp = CdAudioSendToNextDriver(DeviceObject, Irp);
    }
#line 7311
    return (tmp);
  }
  {
#line 7314
  Irp->IoStatus.__annonCompField4.Status = status;
#line 7315
  myStatus = (int )status;
#line 7316
  IofCompleteRequest(Irp, (char)0);
  }
#line 7318
  return (status);
}
}
#line 7321 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void HpCdrProcessLastSession(PCDROM_TOC Toc ) 
{ ULONG index ;

  {
#line 7325
  index = (unsigned long )Toc->FirstTrack;
#line 7326
  if (index) {
#line 7327
    index -= 1UL;
#line 7328
    Toc->FirstTrack = Toc->TrackData[0].Reserved;
#line 7329
    Toc->LastTrack = Toc->TrackData[index].Reserved;
#line 7330
    Toc->TrackData[0] = Toc->TrackData[index];
  } else {
#line 7332
    Toc->LastTrack = (unsigned char)0;
#line 7333
    Toc->FirstTrack = Toc->LastTrack;
  }
#line 7335
  return;
}
}
#line 7338 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS HPCdrCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ) 
{ 

  {
#line 7342
  if (myIrp_PendingReturned) {
#line 7343
    if (pended == 0) {
#line 7344
      pended = 1;
    } else {
      {
#line 7347
      errorFn();
      }
    }
#line 7350
    (Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control = (unsigned char )((int )(Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation)->Control | 1);
  } else {

  }
#line 7354
  if ((long )myStatus >= 0L) {
    {
#line 7356
    HpCdrProcessLastSession((struct _CDROM_TOC *)Irp->AssociatedIrp.SystemBuffer);
    }
  } else {

  }
#line 7361
  return ((long )myStatus);
}
}
#line 7364 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioHPCdrDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PIO_STACK_LOCATION currentIrpStack ;
  PIO_STACK_LOCATION nextIrpStack ;
  PCD_DEVICE_EXTENSION deviceExtension ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___0 ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 7375
  currentIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7376
  nextIrpStack = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7377
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7378
  if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode == (unsigned long )(((2 << 16) | (1 << 14)) | (14 << 2))) {
    {
#line 7380
    irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7381
    nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7382
    memcpy((void *)nextIrpSp, (void const   *)irpSp, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 7383
    nextIrpSp->Control = (unsigned char)0;
    }
#line 7385
    if (s != NP) {
      {
#line 7387
      errorFn();
      }
    } else {
#line 7390
      if (compRegistered != 0) {
        {
#line 7392
        errorFn();
        }
      } else {
#line 7395
        compRegistered = 1;
#line 7396
        routine = 0;
#line 7397
        compFptr = & HPCdrCompletion;
      }
    }
    {
#line 7401
    irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7402
    irpSp___0->CompletionRoutine = & HPCdrCompletion;
#line 7403
    irpSp___0->Context = (void *)deviceExtension;
#line 7404
    irpSp___0->Control = (unsigned char)0;
#line 7405
    irpSp___0->Control = (unsigned char)64;
#line 7406
    irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 128);
#line 7407
    irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 32);
#line 7408
    tmp = IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
    }
#line 7410
    return (tmp);
  } else {
    {
#line 7413
    tmp___0 = CdAudioSendToNextDriver(DeviceObject, Irp);
    }
#line 7415
    return (tmp___0);
  }
#line 7417
  return (-1073741823L);
}
}
#line 7420 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioForwardIrpSynchronous(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  KEVENT event ;
  NTSTATUS status ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;
  PIO_STACK_LOCATION irpSp___0 ;

  {
  {
#line 7431
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7432
  irpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation;
#line 7433
  nextIrpSp = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7434
  memcpy((void *)nextIrpSp, (void const   *)irpSp, (unsigned int )((long )(& ((IO_STACK_LOCATION *)0)->CompletionRoutine)));
#line 7435
  nextIrpSp->Control = (unsigned char)0;
  }
#line 7437
  if (s != NP) {
    {
#line 7439
    errorFn();
    }
  } else {
#line 7442
    if (compRegistered != 0) {
      {
#line 7444
      errorFn();
      }
    } else {
#line 7447
      compRegistered = 1;
#line 7448
      routine = 1;
#line 7449
      compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))(& CdAudioSignalCompletion);
    }
  }
  {
#line 7453
  irpSp___0 = Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation - 1;
#line 7454
  irpSp___0->CompletionRoutine = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp ,
                                               PVOID Context ))(& CdAudioSignalCompletion);
#line 7455
  irpSp___0->Context = (void *)(& event);
#line 7456
  irpSp___0->Control = (unsigned char)0;
#line 7457
  irpSp___0->Control = (unsigned char)64;
#line 7458
  irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 128);
#line 7459
  irpSp___0->Control = (unsigned char )((int )irpSp___0->Control | 32);
#line 7460
  status = IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
#line 7461
  status = 259L;
  }
#line 7463
  if (status) {
    {
#line 7465
    KeWaitForSingleObject((void *)(& event), (enum _KWAIT_REASON )0, (char)0, (unsigned char)0,
                          (LARGE_INTEGER *)((void *)0));
#line 7466
    status = Irp->IoStatus.__annonCompField4.Status;
#line 7467
    status = (long )myStatus;
    }
  } else {

  }
#line 7472
  return (status);
}
}
#line 7475 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void CdAudioUnload(PDRIVER_OBJECT DriverObject ) 
{ 

  {
#line 7479
  return;
}
}
#line 7482 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS CdAudioPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ PCD_DEVICE_EXTENSION deviceExtension ;
  NTSTATUS tmp ;

  {
#line 7490
  if (s == NP) {
#line 7491
    s = SKIP1;
  } else {
    {
#line 7494
    errorFn();
    }
  }
  {
#line 7498
  Irp->CurrentLocation = (char )((int )Irp->CurrentLocation + 1);
#line 7499
  Irp->Tail.Overlay.__annonCompField17.__annonCompField16.CurrentStackLocation += 1;
#line 7500
  deviceExtension = (struct _CD_DEVICE_EXTENSION *)DeviceObject->DeviceExtension;
#line 7501
  tmp = PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
  }
#line 7503
  return (tmp);
}
}
#line 7510
#pragma warning(push)
#line 7511
#pragma warning(disable:4035)
#line 7512
#pragma warning(pop)
#line 7514
#pragma warning(disable:4103)
#line 7515
#pragma warning(disable:4103)
#line 7516
#pragma warning(push)
#line 7517
#pragma warning(disable:4035)
#line 7518
#pragma warning(pop)
#line 7519
#pragma warning(disable:4035)
#line 7520
#pragma warning(push)
#line 7521
#pragma warning(disable:4164)
#line 7522
#pragma function(_enable)
#line 7523
#pragma function(_disable)
#line 7524
#pragma warning(pop)
#line 7525
#pragma warning(disable:4103)
#line 7526
#pragma warning(disable:4103)
#line 7527
#pragma warning(disable:4103)
#line 7528
#pragma warning(disable:4103)
#line 7529
#pragma warning(disable:4103)
#line 7530
#pragma warning(disable:4103)
#line 7531
#pragma warning(disable:4200)
#line 7532
#pragma warning(default:4200)
#line 7533 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
IRP *pirp  ;
#line 7534 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void stub_driver_init(void) 
{ 

  {
#line 7538
  s = NP;
#line 7539
  customIrp = 0;
#line 7540
  setEventCalled = customIrp;
#line 7541
  lowerDriverReturn = setEventCalled;
#line 7542
  compRegistered = lowerDriverReturn;
#line 7543
  compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 7544
  pended = (int )compFptr;
#line 7545
  return;
}
}
#line 7548 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
int main(void) 
{ NTSTATUS status ;
  IRP irp ;
  int we_should_unload ;
  int __BLAST_NONDET___0 ;
  int irp_choice ;
  DEVICE_OBJECT devobj ;

  {
  {
#line 7559
  pirp = & irp;
#line 7560
  _BLAST_init();
  }
#line 7562
  if (status >= 0L) {
#line 7563
    s = NP;
#line 7564
    customIrp = 0;
#line 7565
    setEventCalled = customIrp;
#line 7566
    lowerDriverReturn = setEventCalled;
#line 7567
    compRegistered = lowerDriverReturn;
#line 7568
    compFptr = (NTSTATUS (*)(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context ))compRegistered;
#line 7569
    pended = (int )compFptr;
#line 7570
    pirp->IoStatus.__annonCompField4.Status = 0L;
#line 7571
    myStatus = 0;
#line 7572
    if (irp_choice == 0) {
#line 7573
      pirp->IoStatus.__annonCompField4.Status = -1073741637L;
#line 7574
      myStatus = -1073741637;
    } else {

    }
    {
#line 7579
    stub_driver_init();
    }
#line 7581
    if (! (status >= 0L)) {
#line 7582
      return (-1);
    } else {

    }
#line 7586
    if (__BLAST_NONDET___0 == 2) {
      goto switch_22_2;
    } else {
#line 7589
      if (__BLAST_NONDET___0 == 3) {
        goto switch_22_3;
      } else {
#line 7592
        if (__BLAST_NONDET___0 == 4) {
          goto switch_22_4;
        } else {
          goto switch_22_default;
#line 7597
          if (0) {
            switch_22_2: 
            {
#line 7600
            status = CdAudioDeviceControl(& devobj, pirp);
            }
            goto switch_22_break;
            switch_22_3: 
            {
#line 7605
            status = CdAudioPnp(& devobj, pirp);
            }
            goto switch_22_break;
            switch_22_4: 
            {
#line 7610
            status = CdAudioPower(& devobj, pirp);
            }
            goto switch_22_break;
            switch_22_default: ;
#line 7614
            return (-1);
          } else {
            switch_22_break: ;
          }
        }
      }
    }
#line 7622
    if (we_should_unload) {

    } else {

    }
  } else {

  }
#line 7632
  if (pended == 1) {
#line 7633
    if (s == NP) {
#line 7634
      s = NP;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
#line 7640
    if (pended == 1) {
#line 7641
      if (s == MPR3) {
#line 7642
        s = MPR3;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 7648
      if (s == UNLOADED) {

      } else {
#line 7651
        if (status == -1L) {

        } else {
#line 7654
          if (s != SKIP2) {
#line 7655
            if (s != IPC) {
#line 7656
              if (s != DC) {
                {
#line 7658
                errorFn();
                }
              } else {
                goto _L___0;
              }
            } else {
              goto _L___0;
            }
          } else {
            _L___0: 
#line 7668
            if (pended == 1) {
#line 7669
              if (status != 259L) {
                {
#line 7671
                errorFn();
                }
              } else {

              }
            } else {
#line 7677
              if (s == DC) {
#line 7678
                if (status == 259L) {
                  {
#line 7680
                  errorFn();
                  }
                } else {

                }
              } else {
#line 7686
                if (status != (long )lowerDriverReturn) {
                  {
#line 7688
                  errorFn();
                  }
                } else {

                }
              }
            }
          }
        }
      }
    }
  }
#line 7700
  return ((int )status);
}
}
#line 7703 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
char _SLAM_alloc_dummy  ;
#line 7704
extern int qdpt_malloc() ;
#line 7705 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
char *nondet_malloc(int i ) 
{ int __BLAST_NONDET___0 ;
  int tmp ;

  {
#line 7710
  if (__BLAST_NONDET___0) {
#line 7711
    return ((char *)0);
  } else {
    {
#line 7714
    tmp = qdpt_malloc(i);
    }
#line 7716
    return ((char *)tmp);
  }
}
}
#line 7721 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void ExAcquireFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 7725
  return;
}
}
#line 7729 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void ExReleaseFastMutex(PFAST_MUTEX FastMutex ) 
{ 

  {
#line 7733
  return;
}
}
#line 7739 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) 
{ PVOID x ;
  char *tmp ;

  {
  {
#line 7746
  tmp = nondet_malloc((int )NumberOfBytes);
#line 7747
  x = (void *)tmp;
  }
#line 7749
  return (x);
}
}
#line 7753 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void ExFreePool(PVOID P ) 
{ 

  {
#line 7757
  return;
}
}
#line 7763 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 7769
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7775 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY ListEntry ,
                                         PKSPIN_LOCK Lock ) 
{ 

  {
#line 7781
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7786 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) 
{ 

  {
#line 7791
  return ((struct _LIST_ENTRY *)((void *)0));
}
}
#line 7797 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length , BOOLEAN SecondaryBuffer ,
                   BOOLEAN ChargeQuota , PIRP Irp ) 
{ int __BLAST_NONDET___0 ;
  char *tmp ;

  {
#line 7803
  if (__BLAST_NONDET___0 == 0) {
    goto switch_23_0;
  } else {
    goto switch_23_default;
#line 7808
    if (0) {
      switch_23_0: 
      {
#line 7811
      tmp = nondet_malloc((int )sizeof(MDL ));
      }
#line 7813
      return ((struct _MDL *)((void *)tmp));
      switch_23_default: ;
#line 7815
      return ((struct _MDL *)((void *)0));
    } else {

    }
  }
}
}
#line 7825 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice , PDEVICE_OBJECT TargetDevice ) 
{ int __BLAST_NONDET___0 ;

  {
#line 7829
  if (__BLAST_NONDET___0 == 0) {
    goto switch_24_0;
  } else {
    goto switch_24_default;
#line 7834
    if (0) {
      switch_24_0: ;
#line 7836
      return (TargetDevice);
      switch_24_default: ;
#line 7838
      return ((struct _DEVICE_OBJECT *)((void *)0));
    } else {

    }
  }
}
}
#line 7852 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction , PDEVICE_OBJECT DeviceObject ,
                                   PVOID Buffer , ULONG Length , PLARGE_INTEGER StartingOffset ,
                                   PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET___0 ;
  int tmp ;

  {
#line 7859
  customIrp = 1;
#line 7860
  if (__BLAST_NONDET___0 == 0) {
    goto switch_25_0;
  } else {
    goto switch_25_default;
#line 7865
    if (0) {
      switch_25_0: 
      {
#line 7868
      tmp = qdpt_malloc(sizeof(IRP ));
      }
#line 7870
      return ((struct _IRP *)((void *)tmp));
      switch_25_default: ;
#line 7872
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 7889 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode , PDEVICE_OBJECT DeviceObject ,
                                   PVOID InputBuffer , ULONG InputBufferLength , PVOID OutputBuffer ,
                                   ULONG OutputBufferLength , BOOLEAN InternalDeviceIoControl ,
                                   PKEVENT Event , PIO_STATUS_BLOCK IoStatusBlock ) 
{ int __BLAST_NONDET___0 ;
  int tmp ;

  {
#line 7897
  customIrp = 1;
#line 7898
  if (__BLAST_NONDET___0 == 0) {
    goto switch_26_0;
  } else {
    goto switch_26_default;
#line 7903
    if (0) {
      switch_26_0: 
      {
#line 7906
      tmp = qdpt_malloc(sizeof(IRP ));
      }
#line 7908
      return ((struct _IRP *)((void *)tmp));
      switch_26_default: ;
#line 7910
      return ((struct _IRP *)((void *)0));
    } else {

    }
  }
}
}
#line 7923 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject , ULONG DeviceExtensionSize ,
                        PUNICODE_STRING DeviceName , ULONG DeviceType , ULONG DeviceCharacteristics ,
                        BOOLEAN Exclusive , PDEVICE_OBJECT *DeviceObject ) 
{ int __BLAST_NONDET___0 ;
  int tmp ;

  {
#line 7930
  if (__BLAST_NONDET___0 == 0) {
    goto switch_27_0;
  } else {
    goto switch_27_default;
#line 7935
    if (0) {
      switch_27_0: 
      {
#line 7938
      tmp = qdpt_malloc(sizeof(DEVICE_OBJECT ));
#line 7939
      *DeviceObject = (struct _DEVICE_OBJECT *)((void *)tmp);
      }
#line 7941
      return (0L);
      switch_27_default: ;
#line 7943
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7953 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) 
{ int __BLAST_NONDET___0 ;

  {
#line 7957
  if (__BLAST_NONDET___0 == 0) {
    goto switch_28_0;
  } else {
    goto switch_28_default;
#line 7962
    if (0) {
      switch_28_0: ;
#line 7964
      return (0L);
      switch_28_default: ;
#line 7966
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 7975 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 7979
  return;
}
}
#line 7983 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET___0 ;

  {
#line 7987
  if (__BLAST_NONDET___0 == 0) {
    goto switch_29_0;
  } else {
    goto switch_29_default;
#line 7992
    if (0) {
      switch_29_0: ;
#line 7994
      return (0L);
      switch_29_default: ;
#line 7996
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8005 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) 
{ 

  {
#line 8009
  return;
}
}
#line 8013 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoFreeIrp(PIRP Irp ) 
{ 

  {
#line 8017
  return;
}
}
#line 8021 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoFreeMdl(PMDL Mdl ) 
{ 

  {
#line 8025
  return;
}
}
#line 8029 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void) 
{ char *tmp ;

  {
  {
#line 8034
  tmp = nondet_malloc((int )sizeof(CONFIGURATION_INFORMATION ));
  }
#line 8036
  return ((struct _CONFIGURATION_INFORMATION *)((void *)tmp));
}
}
#line 8057 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType , PULONG BusNumber , PCONFIGURATION_TYPE ControllerType ,
                                  PULONG ControllerNumber , PCONFIGURATION_TYPE PeripheralType ,
                                  PULONG PeripheralNumber , NTSTATUS (*CalloutRoutine)(PVOID Context ,
                                                                                       PUNICODE_STRING PathName ,
                                                                                       INTERFACE_TYPE BusType ,
                                                                                       ULONG BusNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *BusInformation ,
                                                                                       CONFIGURATION_TYPE ControllerType ,
                                                                                       ULONG ControllerNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *ControllerInformation ,
                                                                                       CONFIGURATION_TYPE PeripheralType ,
                                                                                       ULONG PeripheralNumber ,
                                                                                       PKEY_VALUE_FULL_INFORMATION *PeripheralInformation ) ,
                                  PVOID Context ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8074
  if (__BLAST_NONDET___0 == 0) {
    goto switch_30_0;
  } else {
    goto switch_30_default;
#line 8079
    if (0) {
      switch_30_0: ;
#line 8081
      return (0L);
      switch_30_default: ;
#line 8083
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8095 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , GUID const   *InterfaceClassGuid ,
                                   PUNICODE_STRING ReferenceString , PUNICODE_STRING SymbolicLinkName ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8102
  if (__BLAST_NONDET___0 == 0) {
    goto switch_31_0;
  } else {
    goto switch_31_default;
#line 8107
    if (0) {
      switch_31_0: ;
#line 8109
      return (0L);
      switch_31_default: ;
#line 8111
      return (-1073741808L);
    } else {

    }
  }
}
}
#line 8120 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoReleaseCancelSpinLock(KIRQL Irql ) 
{ 

  {
#line 8124
  return;
}
}
#line 8129 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8133
  if (__BLAST_NONDET___0 == 0) {
    goto switch_32_0;
  } else {
    goto switch_32_default;
#line 8138
    if (0) {
      switch_32_0: ;
#line 8140
      return (0L);
      switch_32_default: ;
#line 8142
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8151 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IoSetHardErrorOrVerifyDevice(PIRP Irp , PDEVICE_OBJECT DeviceObject ) 
{ 

  {
#line 8155
  return;
}
}
#line 8158 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void stubMoreProcessingRequired(void) 
{ 

  {
#line 8162
  if (s == NP) {
#line 8163
    s = MPR1;
  } else {
    {
#line 8166
    errorFn();
    }
  }
#line 8169
  return;
}
}
#line 8174 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET___0 ;
  NTSTATUS returnVal2 ;
  int compRetStatus ;
  PVOID lcontext ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 8184
  if (compRegistered) {
#line 8185
    if (routine == 0) {
      {
#line 8187
      tmp = HPCdrCompletion(DeviceObject, Irp, lcontext);
#line 8188
      compRetStatus = (int )tmp;
      }
    } else {
#line 8191
      if (routine == 1) {
        {
#line 8193
        tmp___0 = CdAudioSignalCompletion(DeviceObject, Irp, (struct _KEVENT *)lcontext);
#line 8194
        compRetStatus = (int )tmp___0;
        }
      } else {

      }
    }
#line 8200
    if ((long )compRetStatus == -1073741802L) {
      {
#line 8202
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 8210
  if (myIrp_PendingReturned) {
#line 8211
    returnVal2 = 259L;
  } else {
#line 8213
    if (__BLAST_NONDET___0 == 0) {
      goto switch_33_0;
    } else {
#line 8216
      if (__BLAST_NONDET___0 == 1) {
        goto switch_33_1;
      } else {
        goto switch_33_default;
#line 8221
        if (0) {
          switch_33_0: 
#line 8223
          returnVal2 = 0L;
          goto switch_33_break;
          switch_33_1: 
#line 8226
          returnVal2 = -1073741823L;
          goto switch_33_break;
          switch_33_default: 
#line 8229
          returnVal2 = 259L;
          goto switch_33_break;
        } else {
          switch_33_break: ;
        }
      }
    }
  }
#line 8238
  if (s == NP) {
#line 8239
    s = IPC;
#line 8240
    lowerDriverReturn = (int )returnVal2;
  } else {
#line 8242
    if (s == MPR1) {
#line 8243
      if (returnVal2 == 259L) {
#line 8244
        s = MPR3;
#line 8245
        lowerDriverReturn = (int )returnVal2;
      } else {
#line 8247
        s = NP;
#line 8248
        lowerDriverReturn = (int )returnVal2;
      }
    } else {
#line 8251
      if (s == SKIP1) {
#line 8252
        s = SKIP2;
#line 8253
        lowerDriverReturn = (int )returnVal2;
      } else {
        {
#line 8256
        errorFn();
        }
      }
    }
  }
#line 8261
  return (returnVal2);
}
}
#line 8266 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) 
{ 

  {
#line 8270
  if (s == NP) {
#line 8271
    s = DC;
  } else {
    {
#line 8274
    errorFn();
    }
  }
#line 8277
  return;
}
}
#line 8280
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) ;
#line 8281 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 8285
  return ((unsigned char)0);
}
}
#line 8291 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Interval ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8295
  if (__BLAST_NONDET___0 == 0) {
    goto switch_34_0;
  } else {
    goto switch_34_default;
#line 8300
    if (0) {
      switch_34_0: ;
#line 8302
      return (0L);
      switch_34_default: ;
#line 8304
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8314 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type , BOOLEAN State ) 
{ 

  {
#line 8318
  return;
}
}
#line 8323 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) 
{ 

  {
#line 8327
  return;
}
}
#line 8331 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void KeInitializeSpinLock(PKSPIN_LOCK SpinLock ) 
{ 

  {
#line 8335
  return;
}
}
#line 8340 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment , LONG Adjustment ,
                        BOOLEAN Wait ) 
{ LONG r ;

  {
#line 8345
  return (r);
}
}
#line 8350 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql ) 
{ 

  {
#line 8354
  return;
}
}
#line 8359 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait ) 
{ LONG l ;

  {
#line 8363
  setEventCalled = 1;
#line 8364
  return (l);
}
}
#line 8371 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason , KPROCESSOR_MODE WaitMode ,
                               BOOLEAN Alertable , PLARGE_INTEGER Timeout ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8376
  if (s == MPR3) {
#line 8377
    if (setEventCalled == 1) {
#line 8378
      s = NP;
#line 8379
      setEventCalled = 0;
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 8385
    if (customIrp == 1) {
#line 8386
      s = NP;
#line 8387
      customIrp = 0;
    } else {
#line 8389
      if (s == MPR3) {
        {
#line 8391
        errorFn();
        }
      } else {

      }
    }
  }
#line 8398
  if (__BLAST_NONDET___0 == 0) {
    goto switch_35_0;
  } else {
    goto switch_35_default;
#line 8403
    if (0) {
      switch_35_0: ;
#line 8405
      return (0L);
      switch_35_default: ;
#line 8407
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8417 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes , PHYSICAL_ADDRESS HighestAcceptableAddress ) 
{ int __BLAST_NONDET___0 ;
  int tmp ;

  {
#line 8422
  if (__BLAST_NONDET___0 == 0) {
    goto switch_36_0;
  } else {
#line 8425
    if (__BLAST_NONDET___0 == 1) {
      goto switch_36_1;
    } else {
#line 8428
      if (0) {
        switch_36_0: 
        {
#line 8431
        tmp = qdpt_malloc(NumberOfBytes);
        }
#line 8433
        return ((void *)tmp);
        switch_36_1: ;
#line 8435
        return ((void *)0);
      } else {

      }
    }
  }
#line 8441
  return ((void *)0);
}
}
#line 8445 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void MmFreeContiguousMemory(PVOID BaseAddress ) 
{ 

  {
#line 8449
  return;
}
}
#line 8458 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList , KPROCESSOR_MODE AccessMode ,
                                   MEMORY_CACHING_TYPE CacheType , PVOID BaseAddress ,
                                   ULONG BugCheckOnFailure , MM_PAGE_PRIORITY Priority ) 
{ 

  {
#line 8464
  return ((void *)0);
}
}
#line 8468 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
PVOID MmPageEntireDriver(PVOID AddressWithinSection ) 
{ 

  {
#line 8472
  return ((void *)0);
}
}
#line 8476 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void MmResetDriverPaging(PVOID AddressWithinSection ) 
{ 

  {
#line 8480
  return;
}
}
#line 8484 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void MmUnlockPages(PMDL MemoryDescriptorList ) 
{ 

  {
#line 8488
  return;
}
}
#line 8497 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle , ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType ,
                                   KPROCESSOR_MODE AccessMode , PVOID *Object , POBJECT_HANDLE_INFORMATION HandleInformation ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8502
  if (__BLAST_NONDET___0 == 0) {
    goto switch_37_0;
  } else {
    goto switch_37_default;
#line 8507
    if (0) {
      switch_37_0: ;
#line 8509
      return (0L);
      switch_37_default: ;
#line 8511
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8520 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void ObfDereferenceObject(PVOID Object ) 
{ 

  {
#line 8524
  return;
}
}
#line 8529 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) 
{ int __BLAST_NONDET___0 ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext ;
  NTSTATUS tmp ;
  NTSTATUS tmp___0 ;

  {
#line 8538
  if (compRegistered) {
#line 8539
    if (routine == 0) {
      {
#line 8541
      tmp = HPCdrCompletion(DeviceObject, Irp, lcontext);
#line 8542
      compRetStatus = (int )tmp;
      }
    } else {
#line 8545
      if (routine == 1) {
        {
#line 8547
        tmp___0 = CdAudioSignalCompletion(DeviceObject, Irp, (struct _KEVENT *)lcontext);
#line 8548
        compRetStatus = (int )tmp___0;
        }
      } else {

      }
    }
#line 8554
    if ((long )compRetStatus == -1073741802L) {
      {
#line 8556
      stubMoreProcessingRequired();
      }
    } else {

    }
  } else {

  }
#line 8564
  if (__BLAST_NONDET___0 == 0) {
    goto switch_38_0;
  } else {
#line 8567
    if (__BLAST_NONDET___0 == 1) {
      goto switch_38_1;
    } else {
      goto switch_38_default;
#line 8572
      if (0) {
        switch_38_0: 
#line 8574
        returnVal = 0L;
        goto switch_38_break;
        switch_38_1: 
#line 8577
        returnVal = -1073741823L;
        goto switch_38_break;
        switch_38_default: 
#line 8580
        returnVal = 259L;
        goto switch_38_break;
      } else {
        switch_38_break: ;
      }
    }
  }
#line 8588
  if (s == NP) {
#line 8589
    s = IPC;
#line 8590
    lowerDriverReturn = (int )returnVal;
  } else {
#line 8592
    if (s == MPR1) {
#line 8593
      if (returnVal == 259L) {
#line 8594
        s = MPR3;
#line 8595
        lowerDriverReturn = (int )returnVal;
      } else {
#line 8597
        s = NP;
#line 8598
        lowerDriverReturn = (int )returnVal;
      }
    } else {
#line 8601
      if (s == SKIP1) {
#line 8602
        s = SKIP2;
#line 8603
        lowerDriverReturn = (int )returnVal;
      } else {
        {
#line 8606
        errorFn();
        }
      }
    }
  }
#line 8611
  return (returnVal);
}
}
#line 8615 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void PoStartNextPowerIrp(PIRP Irp ) 
{ 

  {
#line 8619
  return;
}
}
#line 8629 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
                              HANDLE ProcessHandle , PCLIENT_ID ClientId , void (*StartRoutine)(PVOID StartContext ) ,
                              PVOID StartContext ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8635
  if (__BLAST_NONDET___0 == 0) {
    goto switch_39_0;
  } else {
    goto switch_39_default;
#line 8640
    if (0) {
      switch_39_0: ;
#line 8642
      return (0L);
      switch_39_default: ;
#line 8644
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8653 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8657
  if (__BLAST_NONDET___0 == 0) {
    goto switch_40_0;
  } else {
    goto switch_40_default;
#line 8662
    if (0) {
      switch_40_0: ;
#line 8664
      return (0L);
      switch_40_default: ;
#line 8666
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8677 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString , PANSI_STRING SourceString ,
                                      BOOLEAN AllocateDestinationString ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8683
  if (__BLAST_NONDET___0 == 0) {
    goto switch_41_0;
  } else {
    goto switch_41_default;
#line 8688
    if (0) {
      switch_41_0: ;
#line 8690
      return (0L);
      switch_41_default: ;
#line 8692
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8703 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
SIZE_T RtlCompareMemory(void const   *Source1 , void const   *Source2 , SIZE_T Length ) 
{ SIZE_T r ;

  {
#line 8708
  return (r);
}
}
#line 8713 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void RtlCopyUnicodeString(PUNICODE_STRING DestinationString , PUNICODE_STRING SourceString ) 
{ 

  {
#line 8718
  return;
}
}
#line 8724 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo , PCWSTR Path , PCWSTR ValueName ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8729
  if (__BLAST_NONDET___0 == 0) {
    goto switch_42_0;
  } else {
    goto switch_42_default;
#line 8734
    if (0) {
      switch_42_0: ;
#line 8736
      return (0L);
      switch_42_default: ;
#line 8738
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8747 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ) 
{ 

  {
#line 8751
  return;
}
}
#line 8756 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void RtlInitString(PSTRING DestinationString , PCSZ SourceString ) 
{ 

  {
#line 8760
  return;
}
}
#line 8765 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
void RtlInitUnicodeString(PUNICODE_STRING DestinationString , PCWSTR SourceString ) 
{ 

  {
#line 8770
  return;
}
}
#line 8778 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo , PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable ,
                                PVOID Context , PVOID Environment ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8784
  if (__BLAST_NONDET___0 == 0) {
    goto switch_43_0;
  } else {
    goto switch_43_default;
#line 8789
    if (0) {
      switch_43_0: ;
#line 8791
      return (0L);
      switch_43_default: ;
#line 8793
      return (-1073741823L);
    } else {

    }
  }
}
}
#line 8802 "/home/holzera/cpachecker/cpachecker/branches/qdpt-hacking/test/albertos_tests/test/ntdrivers/cdaudio/cdaudio.i.cil.c"
NTSTATUS ZwClose(HANDLE Handle ) 
{ int __BLAST_NONDET___0 ;

  {
#line 8806
  if (__BLAST_NONDET___0 == 0) {
    goto switch_44_0;
  } else {
    goto switch_44_default;
#line 8811
    if (0) {
      switch_44_0: ;
#line 8813
      return (0L);
      switch_44_default: ;
#line 8815
      return (-1073741823L);
    } else {

    }
  }
}
}
