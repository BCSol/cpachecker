# only paths to error locations are analyzed
cfa.removeIrrelevantForErrorLocations = true

analysis.useRefinement = true

cegar.refiner = cpa.predicateabstraction.PredicateAbstractionRefiner

# ARTCPA is necessary for refinement and has to be the top-level CPA
cpa = cpa.art.ARTCPA

ARTCPA.cpa = compositeCPA.CompositeCPA

CompositeCPA.cpas = cpa.location.LocationCPA, cpa.errorlocation.ErrorLocationCPA, cpa.predicateabstraction.PredicateAbstractionCPA

# merge-sep for ARTCPA is possible because the other CPAs also have merge-sep, and it's faster
cpas.art.merge = sep

# whether to use a Boolean or a Cartesian abstraction
cpas.symbpredabs.abstraction.cartesian = true

cpas.symbpredabs.shortestCexTrace = true
cpas.symbpredabs.shortestCexTraceUseSuffix = true

# which SMT solver to use for computing the cartesian abstraction (mathsat, yices, simplify)
cpas.symbpredabs.explicit.abstraction.solver = simplify

# if true, mimick the behaviour of Blast on refinement: collect all the
# predicates from all the cuts of the abstract counterexample, and add all of
# them to all relevant locations
cpas.symbpredabs.refinement.useBlastWay = true

# if true, apply deletion-filter to the abstract counterexample, to get a
# minimal set of blocks, before applying interpolation-based refinement
cpas.symbpredabs.explicit.getUsefulBlocks = true

# if false, don't use a combination of theories (this is incomplete)
cpas.symbpredabs.mathsat.useDtc = true
