# where to save the log file
log.path = test/output/CPALog.txt

# set the log level, only on, off supported currently to switch on or off
log.level = off

# do we want to print cfa as .dot, true or false
dot.export = false

# where to save the dot file
dot.path = test/output/

# do we want to simplify cfa?
cfa.simplify = false

# run consistency checks on the cfa?
cfa.check = true

# do we want to combine multiple assignments and 
# if cpa.simplify is set to true and cfa.combineBlockStatements is set
# to false only blank edges will be removed while simplifying

cfa.combineBlockStatements = false

# set to true if you want to run an interprocedural analysis
analysis.interprocedural = true
analysis.useSummaryLocations = false
analysis.useGlobalVars = true
# true if we want to use block edges
analysis.useBlockEdges = true

# if true, don't create call/return edges for external function calls
analysis.noExternalCalls = true

# don't use a composite CPA
analysis.noCompositeCPA = true

# remove nodes that are not reachable from the error
cfa.removeIrrelevantForErrorLocations = true

# entry function
analysis.entryFunction = main
    
# which strategy to adopt for visiting states? DFS or BFS? BFS, unless
# bfs is false
analysis.bfs = false

# which CPAs do we want to use? where is the CPA class that represents the corresponding analysis?
analysis.cpas = cpa.symbpredabs.explicit.ExplicitCPA

# what merge operator do we want to use for each cpa? give the merge types in respective order with analysis.cpas property
# use sep for MergeSep and join for MergeJoin
analysis.mergeOperators = sep, sep

# what stop operator do we want to use for each cpa? give the merge types in respective order with analysis.cpas property
# use sep for StopSep and join for StopJoin
analysis.stopOperators = sep, sep

# if true, don't print the set of reachable states at the end of the analysis
analysis.dontPrintReachableStates = true

#------------------------------------------------------------------------------
# some custom options for Symbolic Predicate Abstraction with Summaries
#------------------------------------------------------------------------------

# if true, refinement will add all discovered predicates to all the locations
# in the abstract trace
cpas.symbpredabs.refinement.addPredicatesGlobally = false

# if true, encode program variables as INTEGERs in MathSAT, instead of using
# REALs. Since interpolation is not really supported by the laz solver, when
# computing interpolants we still use the LA solver, but encoding variables
# as ints might still be a good idea: we can tighten strict inequalities, and
# split negated equalities
cpas.symbpredabs.mathsat.useIntegers = false

# if true, refinement will try to build "well-scoped" predicates, by cutting
# spurious traces as explained in Section 5.2 of the paper "Abstractions From
# Proofs"
cpas.symbpredabs.refinement.addWellScopedPredicates = false

# where to dump the counterexample formula in case the error location is reached
cpas.symbpredabs.refinement.msatCexPath = test/output/cex.msat

# if true, try to add some useful static-learning-like axioms for bitwise
# operations (which are encoded as UFs): essentially, we simply collect all
# the numbers used in bitwise operations, and add axioms like (0 & n = 0)
cpas.symbpredabs.useBitwiseAxioms = false

# if true, initialize all variables to 0 when they are declared
cpas.symbpredabs.initAllVars = false

# if initAllVars is true, we get rid of all non-determinism. This might not be
# desirable. If the following property is set to a non-empty value, all
# variables starting with this prefix will not be initialized automatically
cpas.symbpredabs.noAutoInitPrefix = __BLAST_NONDET

# where to dump the final predicate map in case the error location is not
# reached
cpas.symbpredabs.refinement.finalPredMapPath = test/output/predmap.txt

# whether to use a Boolean or a Cartesian abstraction
cpas.symbpredabs.abstraction.cartesian = true

cpas.symbpredabs.smallSummaries = false

cpas.symbpredabs.shortestCexTrace = true
cpas.symbpredabs.shortestCexTraceUseSuffix = true

#cpas.symbpredabs.abstraction.norefinement = true
# if set, will be used to initialize the predicate map
#cpas.symbpredabs.abstraction.fixedPredMap = fixedpredmap.msat

cpas.symbpredabs.refinement.splitItpAtoms = false

cpas.symbpredabs.mathsat.useCache = true

# which SMT solver to use for computing the cartesian abstraction
#cpas.symbpredabs.explicit.abstraction.solver = mathsat
#cpas.symbpredabs.explicit.abstraction.solver = yices
cpas.symbpredabs.explicit.abstraction.solver = simplify

# if true, mimick the behaviour of Blast on refinement: collect all the
# predicates from all the cuts of the abstract counterexample, and add all of
# them to all relevant locations
cpas.symbpredabs.refinement.useBlastWay = true

# if true, apply deletion-filter to the abstract counterexample, to get a
# minimal set of blocks, before applying interpolation-based refinement
cpas.symbpredabs.explicit.getUsefulBlocks = true

# if true, collect and print detailed statistics (at the moment, only the
# number of abstraction steps for each location)
#cpas.symbpredabs.explicit.extendedStats = true

# if true, use incrementality in computing Cartesian abstraction
#cpas.symbpredabs.mathsat.incremental = true

# if false, don't use a combination of theories (this is incomplete)
cpas.symbpredabs.mathsat.useDtc = true
