# where to save all output
output.path = test/output/

# name of the output file for logging
log.file = CPALog.txt

# set log level of cpa log file. lower log levels include all higher ones.
# possibilities in descending order: 
# OFF: 		no logs published
# SEVERE: 	error messages
# WARNING: 	warnings
# INFO: 	messages
# FINE: 	logs on main application level
# FINER: 	logs on central CPA algorithm level
# FINEST: 	logs published by specific CPAs
# ALL: 		debugging information
# Care must be taken with levels of FINER or lower, as output files may 
# become quite large and memory usage might become an issue. 

# log level of file output
log.level = OFF

# set log level of console output
log.consoleLevel = INFO

# optionally, list levels to be excluded from being logged
#log.fileExclude = FINER, INFO
#log.consoleExclude = FINER

# do we want to print cfa as .dot, true or false
cfa.export = true

# filename for cfa export
cfa.file = cfa.dot

# export reached set to text file?
reachedSet.export = true
reachedSet.file = reached.txt

# export ART as graph? (only if analysis.useART == true)
ART.export = true
ART.file = ART.dot

parser.dialect = GNUC

# do we want to simplify cfa?
cfa.simplify = false

# run consistency checks on the cfa?
cfa.check = true

# use ART CPA (needed for refinement)
analysis.useART = true

analysis.useRefinement = true

# use CBMC to check counter examples (needs cbmc installed in path)
analysis.useCBMC = false

# use global variables?
analysis.useGlobalVars = true

# set to true if you want to run an interprocedural analysis
analysis.interprocedural = true

# if true, don't create call/return edges for external function calls
analysis.noExternalCalls = true

# don't use a composite CPA
analysis.noCompositeCPA = true

# entry function
analysis.entryFunction = main
    
# which strategy to adopt for visiting states? dfs, bfs, or topsort
analysis.traversal = topsort

# where to keep the programs to run, this is the workspacedata if
# you use eclipse to run CPAChecker. if it changes, you should change this
# parameter.
#analysis.programs = test/

# which CPAs do we want to use? where is the CPA class that represents the corresponding analysis?
# if additional location information is necessary, locationCPA must be the first given in the list
# e.g. analysis.cpas = cpa.location.LocationCPA, ...
analysis.cpas = cpa.location.LocationCPA, cpa.errorlocation.ErrorLocationCPA, cpa.symbpredabsCPA.SymbPredAbsCPA

# what merge operator do we want to use for each cpa? give the merge types in respective order with analysis.cpas property
# use sep for MergeSep and join for MergeJoin
analysis.mergeOperators = sep, sep, join

# what stop operator do we want to use for each cpa? give the merge types in respective order with analysis.cpas property
# use sep for StopSep and join for StopJoin
analysis.stopOperators = sep, sep, join

# the class used for refinement
cegar.refiner = cpa.symbpredabsCPA.SymbPredAbsRefiner

# if true, perform a (very) simple "cone-of-influence" reduction, to get rid
# of all the nodes and edges that are not reachable from the error locations
cfa.removeIrrelevantForErrorLocations = true

# use location mapped reached set
cpa.useSpecializedReachedSet = true

#------------------------------------------------------------------------------
# some custom options for Symbolic Predicate Abstraction with Summaries
#------------------------------------------------------------------------------

# where are predicates
#predicates.path = predicates/

# if true, cache queries to mathsat as much as possible
cpas.symbpredabs.mathsat.useCache = true

# if true, refinement will add all discovered predicates to all the locations
# in the abstract trace
cpas.symbpredabs.refinement.addPredicatesGlobally = false

# if true, encode program variables as INTEGERs in MathSAT, instead of using
# REALs. Since interpolation is not really supported by the laz solver, when
# computing interpolants we still use the LA solver, but encoding variables
# as ints might still be a good idea: we can tighten strict inequalities, and
# split negated equalities
cpas.symbpredabs.mathsat.useIntegers = false

# if true, refinement will try to build "well-scoped" predicates, by cutting
# spurious traces as explained in Section 5.2 of the paper "Abstractions From
# Proofs"
cpas.symbpredabs.refinement.addWellScopedPredicates = false

# where to dump the counterexample formula in case the error location is reached
cpas.symbpredabs.refinement.msatCexFile = cex.msat

# if true, try to add some useful static-learning-like axioms for bitwise
# operations (which are encoded as UFs): essentially, we simply collect all
# the numbers used in bitwise operations, and add axioms like (0 & n = 0)
cpas.symbpredabs.useBitwiseAxioms = false

# if true, initialize all variables to 0 when they are declared
cpas.symbpredabs.initAllVars = false

# if initAllVars is true, we get rid of all non-determinism. This might not be
# desirable. If the following property is set to a non-empty value, all
# variables starting with this prefix will not be initialized automatically
cpas.symbpredabs.noAutoInitPrefix = __BLAST_NONDET

# where to dump the final predicate map in case the error location is not
# reached
cpas.symbpredabs.refinement.finalPredMapFile = predmap.txt

# whether to use a Boolean or a Cartesian abstraction
cpas.symbpredabs.abstraction.cartesian = false

# if true, use incremental search in counterexample analysis, to find the
# minimal infeasible prefix
cpas.symbpredabs.shortestCexTrace = false

# if true, don't use abstraction refinement, but read predicates from the map
# specified below
cpas.symbpredabs.abstraction.norefinement = false

# when not using refinement, where to get the list of predicates from
#cpas.symbpredabs.abstraction.fixedPredMap = fixedpredmap.msat

# if true, split arithmetic equalities when extracting predicates from
# interpolants
cpas.symbpredabs.refinement.splitItpAtoms = false

# if true, dump the abstraction formulas in both .msat and .smv formats
cpas.symbpredabs.mathsat.dumpHardAbstractionQueries = false

# if false, don't use a combination of theories (this is incomplete)
cpas.symbpredabs.mathsat.useDtc = false

# maximum blocksize before abstraction is forced (0 = LBE; 1 = SBE)
cpas.symbpredabs.blocksize = 0

# inline functions (i.e. for LBE do no abstraction on function call/return, for SBE nothing changes)
cpas.symbpredabs.inlineFunction = false
