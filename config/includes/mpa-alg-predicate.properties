cpa.predicate.refinement.performInitialStaticRefinement=false
cpa.predicate.predmap.export=true
predicate.predmap.file=precision.prec
cpa.predicate.refinement.predicateBasisStrategy=ALL
cpa.predicate.precision.sharing=GLOBAL

# This is necessary for supporting encoding of properties with the abstract domain of the analysis
cpa.predicate.ignoreIrrelevantVariables=false

# We do not use the old coverage mechanism. We use CoverageCPA! 
coverage.stdout.enabled=false
coverage.mode=REACHED

# The outer analysis loop should terminate
#   also if there are states remaining in the set reached
#   (this might be the case if no new partitioning was found)
analysis.stopAfterError=true

analysis.checkCounterexamples=false
analysis.checkMultipleProperties=true

# MultiEdges are not supported by the current implementation
#   of the ControlAutomataCPA (bug/broken implementation)
cfa.useMultiEdges=false

cpa.automaton.prec.localPrecisionUpdate=true

cpa.automaton.breakOnTargetState=1
cpa.automaton.merge.onTop=false
cpa.automaton.merge.onInactive=true

# Do not disable properties within the precision adjustment
#   based on the number of violations! 
#   This is done by the MPA algorithm itself.
cpa.automaton.prec.targetHandledAfterViolations=1

# No bound on the number of refinements per property!
cpa.automaton.prec.targetDisabledAfterRefinements=0

# Our automata do not perform a 'split' on target states.
#   Target states are always abstraction locations.
#   Using a transition to 'INACTIVE' in combination with 
#   automata that split at target locations could result 
#   in wrong safety proofs (if no feasibility check is 
#   performed for the split branch).
cpa.automaton.prec.onHandledTarget=INACTIVE

cpa.automaton.stopAfterOneFeasiblePathPerProperty=false

cpa.predicate.solver=MATHSAT5

