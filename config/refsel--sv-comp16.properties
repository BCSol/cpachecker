# --------------------------------------------------------------------
# This configuration file uses value analysis and a predicate analysis
# in parallel. Both analysis perform refinement selection, and inter-
# analysis refinement selection is performed for deciding which
# analysis to refine for a given infeasible error path.
# Bitprecise predicate analysis is used to check counterexamples.
# --------------------------------------------------------------------

#include valueAnalysis.properties

# specification
specification = specification/sv-comp-reachability.spc

# analyses
CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.functionpointer.FunctionPointerCPA, cpa.value.ValueAnalysisCPA, cpa.predicate.PredicateCPA

# fixed set of option for whole analysis
analysis.checkCounterexamples = true
analysis.summaryEdges         = true

# options for VA
cpa.value.refinement.prefixPreference = DOMAIN_GOOD_WIDTH_NARROW_SHORT
cpa.value.refinement.restart          = ROOT

# options for PA
cpa.predicate.abstraction.computation                   = BOOLEAN
cpa.predicate.blk.alwaysAtJoin                          = true
cpa.predicate.blk.alwaysAtFunctions                     = false
cpa.predicate.blk.alwaysAtLoops                         = true
cpa.predicate.refinement.performInitialStaticRefinement = true
cpa.predicate.refinement.prefixPreference               = DOMAIN_GOOD_LONG
cpa.predicate.refinement.restartAfterRefinements        = 1
# irrelevant if pointer aliasing is disabled (as for DD64)
cpa.predicate.memoryAllocationsAlwaysSucceed            = true
cpa.predicate.precision.sharing                         = SCOPE

# options for combination
cegar.refiner                         = cpa.value.refiner.ValueAnalysisDelegatingRefiner
cegar.useRefinementSelection          = true
cegar.maxScoreOfValueDomainRefinement = 2

# counterexample-check
counterexample.checker.config = cex-checks/predicateAnalysis-as-bitprecise-cex-check.properties

# decide on recursion ..?
# -> some recursion (cpa.callstack.skipVoidRecursion=true, cpa.callstack.skipFunctionPointerRecursion=true) is better than skipping all
# decide on multi edges ..?
# -> does not matter, really -> better disable to have better witnesses
# decide on cpa.predicate.handlePointerAliasing=false for DD64 ..?
# -> TODO
# decide on bit-precise PA or not?
# -> bit-precise scores 380 more, solves 50 less, but also 11 incorrect true, and 6 incorrect falses less
# decide on float, rational encoding
# decide on symbolic execution
# add wittness options ..?
