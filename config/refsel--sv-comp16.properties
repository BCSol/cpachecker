# --------------------------------------------------------------------
# This configuration file uses value analysis and a predicate analysis
# in parallel. Both analysis perform refinement selection, and inter-
# analysis refinement selection is performed for deciding which
# analysis to refine for a given infeasible error path.
# Bitprecise predicate analysis is used to check counterexamples.
# --------------------------------------------------------------------

#include valueAnalysis.properties

# process
output.disable = true
statistics.memory = false

# specification
specification = specification/sv-comp-reachability.spc

# witness-support and witness-optimization
cpa.arg.errorPath.file                                        = ErrorPath.txt
cpa.arg.errorPath.graphml                                     = witness.graphml
cfa.useMultiEdges                                             = false
cfa.simplifyCfa                                               = false
cfa.allowBranchSwapping                                       = false
counterexample.export.assumptions.includeConstantsForPointers = false

# analyses
CompositeCPA.cpas = cpa.location.LocationCPA, cpa.callstack.CallstackCPA, cpa.functionpointer.FunctionPointerCPA, cpa.value.ValueAnalysisCPA, cpa.predicate.PredicateCPA

# fixed set of option for whole analysis
analysis.checkCounterexamples = true
analysis.summaryEdges         = true

# options for VA
cpa.value.refinement.prefixPreference = DOMAIN_GOOD_WIDTH_NARROW_SHORT
cpa.value.refinement.restart          = ROOT

# options for PA
cpa.predicate.abstraction.computation                   = BOOLEAN
cpa.predicate.blk.alwaysAtJoin                          = true
cpa.predicate.blk.alwaysAtFunctions                     = false
cpa.predicate.blk.alwaysAtLoops                         = true
cpa.predicate.refinement.performInitialStaticRefinement = true
cpa.predicate.refinement.prefixPreference               = DOMAIN_GOOD_LONG
cpa.predicate.refinement.restartAfterRefinements        = 1
cpa.predicate.memoryAllocationsAlwaysSucceed            = true
cpa.predicate.precision.sharing                         = SCOPE

# options for combination
cegar.refiner                         = cpa.value.refiner.ValueAnalysisDelegatingRefiner
cegar.useRefinementSelection          = true
cegar.maxScoreOfValueDomainRefinement = 2

# counterexample-check
counterexample.checker.config = cex-checks/predicateAnalysis-as-bitprecise-cex-check.properties

# decide on recursion ..?
# -> some recursion (cpa.callstack.skipVoidRecursion=true, cpa.callstack.skipFunctionPointerRecursion=true) is better than skipping all
# decide on bit-precise PA or not?
# -> bit-precise scores 380 more, solves 50 less, but also 11 incorrect true, and 6 incorrect falses less
# decide on symbolic execution
# decide on counterexample-check when using PA-bitprec
