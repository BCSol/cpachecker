
package fql.frontend.parser;

import java_cup.runtime.*;

import fql.frontend.ast.coverage.States;
import fql.frontend.ast.coverage.Edges;
import fql.frontend.ast.coverage.Paths;
import fql.frontend.ast.coverage.Coverage;
import fql.frontend.ast.coverage.ConditionalCoverage;
import fql.frontend.ast.filter.Identity;
import fql.frontend.ast.filter.File;
import fql.frontend.ast.filter.BasicBlockEntry;
import fql.frontend.ast.filter.ConditionEdge;
import fql.frontend.ast.filter.DecisionEdge;
import fql.frontend.ast.filter.ConditionGraph;
import fql.frontend.ast.filter.Line;
import fql.frontend.ast.filter.FunctionCalls;
import fql.frontend.ast.filter.Column;
import fql.frontend.ast.filter.Function;
import fql.frontend.ast.filter.Label;
import fql.frontend.ast.filter.FunctionCall;
import fql.frontend.ast.filter.FunctionEntry;
import fql.frontend.ast.filter.FunctionExit;
import fql.frontend.ast.filter.EnclosingScopes;
import fql.frontend.ast.filter.Compose;
import fql.frontend.ast.filter.Expression;
import fql.frontend.ast.filter.RegularExpression;
import fql.frontend.ast.filter.Filter;
import fql.frontend.ast.filter.SetMinus;
import fql.frontend.ast.filter.Intersection;
import fql.frontend.ast.filter.Union;
import fql.frontend.ast.filter.Complement;
import fql.frontend.ast.predicate.Predicate;
import fql.frontend.ast.predicate.Term;
import fql.frontend.ast.predicate.CIdentifier;
import fql.frontend.ast.predicate.NaturalNumber;
import fql.frontend.ast.predicate.Predicates;

parser code
{:
:}

action code
{:
:}

/* general */
terminal TOK_L_PARENTHESIS;
terminal TOK_R_PARENTHESIS;
terminal TOK_COMMA;

/* filter functions */
terminal TOK_IDENTITY;
terminal TOK_FILE;
terminal TOK_LINE;
terminal Integer TOK_LINE_ABBREV;
terminal TOK_COLUMN;
terminal TOK_FUNC;
terminal TOK_LABEL;
terminal TOK_CALL;
terminal TOK_CALLS;
terminal TOK_ENTRY;
terminal TOK_EXIT;
terminal TOK_EXPR;
terminal TOK_REGEXP;
terminal TOK_BASICBLOCKENTRY;
terminal TOK_CONDITIONEDGE;
terminal TOK_DECISIONEDGE;
terminal TOK_CONDITIONGRAPH;
/*terminal TOK_DEF;*/
/*terminal TOK_USE;*/
/*terminal TOK_STMTTYPE;*/
/*terminal TOK_STT_IF;*/
/*terminal TOK_STT_FOR;*/
/*terminal TOK_STT_WHILE;*/
/*terminal TOK_STT_SWITCH;*/
/*terminal TOK_STT_CONDOP;*/
/*terminal TOK_STT_ASSERT;*/

/* operations on target graphs */
terminal TOK_COMPLEMENT;
terminal TOK_UNION;
terminal TOK_INTERSECT;
terminal TOK_SETMINUS;
terminal TOK_ENCLOSING_SCOPES;
terminal TOK_COMPOSE;

/* abstraction/predicates */
terminal TOK_L_BRACE;
terminal TOK_R_BRACE;
terminal TOK_GREATER_OR_EQ;
terminal TOK_GREATER;
terminal TOK_EQ;
terminal TOK_LESS_OR_EQ;
terminal TOK_LESS;
terminal TOK_NEQ;

/* coverage specification */
terminal TOK_STATECOV;
terminal TOK_EDGECOV;
terminal TOK_PATHCOV;
terminal TOK_L_SEQ;
terminal TOK_R_SEQ;

/* path monitors */
terminal TOK_NEXT;
terminal TOK_CONCAT;
terminal TOK_ALTERNATIVE;
terminal TOK_KLEENE;

/* query */
terminal TOK_IN;
terminal TOK_COVER;
terminal TOK_PASSING;

/* C identifier */
terminal String TOK_C_IDENT;
terminal String TOK_QUOTED_STRING;

/* a natural number */
terminal Integer TOK_NAT_NUMBER;


non terminal 	Query;
non terminal 	Scope;
non terminal 	Cover;
non terminal	Passing;
non terminal 	Test_Goal_Sequence;
non terminal	Path_Monitor;
non terminal	Path_Monitor_Term;
non terminal	Path_Monitor_Factor;
non terminal	Path_Monitor_Symbol;
non terminal    Conditional_Test_Goal_Set;
non terminal	Test_Goal_Set;
non terminal	Preconditions;
non terminal	Predicates;
non terminal	Predicate;
non terminal	c_LHS;
non terminal	Comparison;
non terminal	Filter;
non terminal	Filter_Function;

start with Query;

Query				::= 
						Scope:scope Cover Passing
						{:
							if (scope != null) {
							
							}
						:}
					;
				
Scope				::= 
					| 	TOK_IN Filter:filter
						{:
							RESULT = filter;
						:}
					;

Cover				::= 
						TOK_COVER Test_Goal_Sequence
						{:
						:}
					;
				
Passing				::= 
					| 	TOK_PASSING Path_Monitor
						{:
						:}
					;
				
Test_Goal_Sequence 	::=	
						Conditional_Test_Goal_Set
						{:
						:} 
					| 	Test_Goal_Sequence TOK_L_SEQ Path_Monitor TOK_R_SEQ Conditional_Test_Goal_Set
						{:
						:}
					|	Test_Goal_Sequence TOK_NEXT Conditional_Test_Goal_Set
						{:
						:}
					;
					
Path_Monitor		::= 
						Path_Monitor_Term 
					  	{:
					  	:}
					  | Path_Monitor TOK_ALTERNATIVE Path_Monitor_Term
						{:
						:}
					;
					
Path_Monitor_Term	::= 
						Path_Monitor_Factor
						{:
						:} 
					| 	Path_Monitor_Term TOK_CONCAT Path_Monitor_Factor
						{:
						:}
					|	Path_Monitor_Term TOK_NEXT Path_Monitor_Factor
						{:
						:}
					;
					
Path_Monitor_Factor	::= 
						Preconditions Path_Monitor_Symbol 
						{:
						:}
					| 	Preconditions TOK_L_PARENTHESIS Path_Monitor TOK_R_PARENTHESIS
						{:
						:}
					| 	Path_Monitor_Factor Predicate
						{:
						:}
					| 	Path_Monitor_Factor TOK_KLEENE
						{:
						:}
					| 	Path_Monitor_Factor TOK_LESS_OR_EQ TOK_NAT_NUMBER
						{:
						:}
					| 	Path_Monitor_Factor TOK_GREATER_OR_EQ TOK_NAT_NUMBER
						{:
						:}
					;
					
Path_Monitor_Symbol	::= 
					  	Filter
						{:
						:}
					;
					
Conditional_Test_Goal_Set
					::= Predicates:preconditions Test_Goal_Set:coverage Predicates:postconditions
						{:
							assert(preconditions != null);
							assert(coverage != null);
							assert(postconditions != null);
							
							assert(preconditions instanceof Predicates);
							assert(coverage instanceof Coverage);
							assert(postconditions instanceof Predicates);
							
							RESULT = new ConditionalCoverage((Predicates)preconditions, (Coverage)coverage, (Predicates)postconditions);
						:}
					;
					
Test_Goal_Set		::=
						TOK_UNION TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							RESULT = new fql.frontend.ast.coverage.Union((Coverage)coverage1, (Coverage)coverage2);
						:}
					|   TOK_INTERSECT TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							RESULT = new fql.frontend.ast.coverage.Intersection((Coverage)coverage1, (Coverage)coverage2);
						:}
					| 	TOK_SETMINUS TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							RESULT = new fql.frontend.ast.coverage.SetMinus((Coverage)coverage1, (Coverage)coverage2);
						:}
					| 	TOK_STATECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new States((Filter)filter, new Predicates());
						:}
					| 	TOK_STATECOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(predicates != null);
							
							assert(filter instanceof Filter);
							assert(predicates instanceof Predicates);
							
							RESULT = new States((Filter)filter, (Predicates)predicates);
						:}
					| 	TOK_EDGECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new Edges((Filter)filter, new Predicates());
						:}
					| 	TOK_EDGECOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(predicates != null);
							assert(predicates instanceof Predicates);
							
							RESULT = new Edges((Filter)filter, (Predicates)predicates);
						:}
					| 	TOK_PATHCOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA TOK_NAT_NUMBER:bound TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
														
							RESULT = new Paths((Filter)filter, bound.intValue(), new Predicates()); 
						:}
					| 	TOK_PATHCOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA TOK_NAT_NUMBER:bound TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(predicates != null);
							assert(predicates instanceof Predicates);
							
							RESULT = new Paths((Filter)filter, bound.intValue(), (Predicates)predicates);
						:}
					;
					
Predicates			::= 
						{:
							RESULT = new Predicates();
						:}
					| 	Predicate:predicate
						{:
							assert(predicate != null);
							assert(predicate instanceof Predicate);
							
							Predicates lPredicates = new Predicates();
							
							lPredicates.add((Predicate)predicate);
							
							RESULT = lPredicates;
						:} 
					| 	Predicates:predicates TOK_COMMA Predicate:predicate
						{:
							assert(predicates != null);
							assert(predicate != null);
							
							assert(predicates instanceof Predicates);
							assert(predicate instanceof Predicate);
							
							Predicates lPredicates = (Predicates)predicates;
							Predicate lPredicate = (Predicate)predicate;
							
							lPredicates.add(lPredicate);
							
							RESULT = lPredicates;
						:}
					;
					
Predicate			::=
						TOK_L_BRACE c_LHS:leftterm Comparison:comparison c_LHS:rightterm TOK_R_BRACE
						{:
							assert(leftterm != null);
							assert(comparison != null);
							assert(rightterm != null);
							
							assert(leftterm instanceof Term);
							assert(comparison instanceof Predicate.Comparison);
							assert(rightterm instanceof Term);
							
							RESULT = new Predicate((Term)leftterm, (Predicate.Comparison)comparison, (Term)rightterm);
						:}
					;
					
c_LHS				::= 
						TOK_C_IDENT:identifier
						{:
							RESULT = new CIdentifier(identifier);
						:}
					| 	TOK_NAT_NUMBER:number
						{:
							RESULT = new NaturalNumber(number);
						:}
					;
					
Comparison			::= 
						TOK_GREATER_OR_EQ
						{:
							RESULT = Predicate.Comparison.GREATER_OR_EQUAL;
						:} 
					| 	TOK_GREATER
						{:
							RESULT = Predicate.Comparison.GREATER;
						:} 
					| 	TOK_EQ
						{:
							RESULT = Predicate.Comparison.EQUAL;
						:} 
					| 	TOK_LESS_OR_EQ
						{:
							RESULT = Predicate.Comparison.LESS_OR_EQUAL;
						:} 
					| 	TOK_LESS
						{:
							RESULT = Predicate.Comparison.LESS;
						:}
					| 	TOK_NEQ
						{:
							RESULT = Predicate.Comparison.NOT_EQUAL;
						:}
					;
					
Filter				::=
						Filter_Function:filter
						{:
							RESULT = filter;
						:}
					|	TOK_COMPLEMENT TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new Complement((Filter)filter);
						:}
					| 	TOK_UNION TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Union((Filter)filter1, (Filter)filter2);
						:}
					|	TOK_INTERSECT TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Intersection((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_SETMINUS TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new SetMinus((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_ENCLOSING_SCOPES TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new EnclosingScopes((Filter)filter);
						:}
					| 	TOK_COMPOSE TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Compose((Filter)filter1, (Filter)filter2);
						:}
					;
					
Filter_Function		::=
						TOK_IDENTITY
						{:
							RESULT = Identity.getInstance();
						:}
					|	TOK_FILE TOK_L_PARENTHESIS TOK_QUOTED_STRING:filename TOK_R_PARENTHESIS
						{:
							RESULT = new File(filename);
						:}
					|	TOK_LINE TOK_L_PARENTHESIS TOK_NAT_NUMBER:linenumber TOK_R_PARENTHESIS
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_LINE_ABBREV:linenumber
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_COLUMN TOK_L_PARENTHESIS TOK_NAT_NUMBER:columnnumber TOK_R_PARENTHESIS
						{:
							RESULT = new Column(columnnumber);
						:}
					| 	TOK_FUNC TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new Function(function);
						:}
					|	TOK_LABEL TOK_L_PARENTHESIS TOK_C_IDENT:label TOK_R_PARENTHESIS
						{:
							RESULT = new Label(label);
						:}
					| 	TOK_CALL TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionCall(function);
						:}
					|	TOK_CALLS
						{:
							RESULT = FunctionCalls.getInstance();
						:}
					| 	TOK_ENTRY TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionEntry(function);
						:}
					|	TOK_EXIT TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionExit(function);
						:}
					|	TOK_EXPR TOK_L_PARENTHESIS TOK_QUOTED_STRING:expression TOK_R_PARENTHESIS
						{:
							RESULT = new Expression(expression);
						:}
					|	TOK_REGEXP TOK_L_PARENTHESIS TOK_QUOTED_STRING:regularexpression TOK_R_PARENTHESIS
						{:
							RESULT = new RegularExpression(regularexpression);
						:}
					|	TOK_BASICBLOCKENTRY
						{:
							RESULT = BasicBlockEntry.getInstance();
						:}
					| 	TOK_CONDITIONEDGE
						{:
							RESULT = ConditionEdge.getInstance();
						:}
					|	TOK_DECISIONEDGE
						{:
							RESULT = DecisionEdge.getInstance();
						:}
					|	TOK_CONDITIONGRAPH
						{:
							RESULT = ConditionGraph.getInstance();
						:}
					;
