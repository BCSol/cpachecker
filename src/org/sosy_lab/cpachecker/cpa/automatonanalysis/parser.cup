/*
 *  CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2010  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cpa.automatonanalysis;

import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import java.util.List;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.Map;
import org.sosy_lab.common.LogManager;
import java.util.logging.Level;
import java.util.Collections;

/* Preliminaries to use the scanner.  */
scan with {: return scanner.next_token(); :};

parser code {:
  /* this map is used to collect the local variables. It is then passed to each "VarAccess" and "Assignment" Expression.
   * ( I don't want to pass the Variable-Instance directly, because it might be defined after the Expression in the input Document.)
   */
  protected Map<String, AutomatonVariable> variablesMap = new HashMap<String, AutomatonVariable>();
  public boolean syntaxErrors;
  AutomatonScanner scanner;
  LogManager logger;

  public AutomatonParser(AutomatonScanner scanner, SymbolFactory sf, LogManager pLogger) {
      super(scanner, sf);
      this.scanner = scanner;
      this.logger = pLogger;
  }
  @Override
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    String errorString = message;
    errorString = errorString + " Line: " + (scanner.getLine()+1) + " Column: " + scanner.getColumn();

    if (info instanceof Symbol) {
    	Symbol symbol = (Symbol) info;
    	if (!( symbol.left < 0 || symbol.right < 0 ))
    		errorString = errorString + "\n at line "+symbol.left+", column "+symbol.right;
    }
    logger.log(Level.INFO, errorString);
  }
:};



terminal EXCLAMATION, AND, OR, ARROW, SEMICOLON, COLON, OPEN_BRACKETS, CLOSE_BRACKETS, AUTOMATON, LOCAL, INITIAL, STATE, ERROR, STOP, ASS, MATCH, LABEL, CHECK, EVAL, MODIFY, DO, PRINT, GOTO, IDENTIFIER, INTEGER_LITERAL, NEQ, EQ, EQEQ, PLUS, MINUS, TRUE, FALSE, STRING_LITERAL, CURLYEXPR, SQUAREEXPR, NONDET ;

non terminal Automaton initial ;
non terminal String InitDef ;
non terminal Automaton Body ;
non terminal Map<String, AutomatonVariable> LocalDefs ;
non terminal List<AutomatonInternalState> StateDefs ;
non terminal List<AutomatonTransition> Transitions ;
non terminal List<AutomatonBoolExpr> Assertions ;
non terminal List<AutomatonActionExpr> Actions ;

non terminal AutomatonVariable LocalDef ;
non terminal AutomatonInternalState StateDef ;
non terminal AutomatonTransition Transition ;
non terminal AutomatonBoolExpr Assertion ;
non terminal AutomatonActionExpr Action ;

non terminal List<AutomatonExpression> PrintArguments ;

non terminal AutomatonIntExpr.Constant ConstantInt ;
non terminal AutomatonIntExpr Int ;
non terminal AutomatonIntExpr InnerInt ;
non terminal AutomatonBoolExpr Bool ;
non terminal AutomatonExpression Expression ;

precedence left PLUS, MINUS;
precedence left AND, OR;
precedence left EQEQ, NEQ;
precedence left EXCLAMATION;
//precedence left EVAL;

initial ::= AUTOMATON IDENTIFIER:id Body:b {: b.setName(id.toString()); RESULT = b; :}
            ;

Body      ::= LocalDefs:vars InitDef:init StateDefs:states
              {: RESULT = new Automaton(vars, states, init, parser.logger); :}
            ;

InitDef    ::= INITIAL STATE IDENTIFIER:id SEMICOLON {: RESULT = id.toString(); :};

LocalDefs ::= LocalDef:d LocalDefs:lst {: lst.put(d.getName(), d); RESULT = lst; :}
              | /* empty */ {: RESULT = parser.variablesMap; /* RESULT = new HashMap<String, AutomatonVariable>(); */ :}
              ;

LocalDef  ::= LOCAL IDENTIFIER:type IDENTIFIER:name  SEMICOLON {: RESULT = new AutomatonVariable(type.toString(), name.toString()); :}
            | LOCAL IDENTIFIER:type IDENTIFIER:name  EQ ConstantInt:ci SEMICOLON 
            {: RESULT = new AutomatonVariable(type.toString(), name.toString()); RESULT.setValue(ci.getIntValue()); :}
            ;

StateDefs ::= StateDef:s StateDefs:lst  {: lst.add(s); RESULT = lst; :} // elements will be in reversed order (irrelevant ?)
            | /* empty */ {: RESULT = new LinkedList<AutomatonInternalState>(); :}
              ;

StateDef  ::= STATE IDENTIFIER:id COLON  Transitions:ts   {: RESULT = new AutomatonInternalState(id.toString(), ts); :}
            | STATE NONDET IDENTIFIER:id COLON  Transitions:ts   {: RESULT = new AutomatonInternalState(id.toString(), ts, true); :}
            ;

Transitions   ::= Transition:t Transitions:lst {: lst.add(0, t); RESULT = lst; :}
            | /* empty */ {: RESULT = new LinkedList<AutomatonTransition>(); :}
            ;

Transition   ::= Bool:trigger  ARROW Assertions:ass Actions:acts GOTO IDENTIFIER:follow SEMICOLON
              {: RESULT = new AutomatonTransition(trigger, ass, acts, follow.toString()); :}
               | Bool:trigger  ARROW Assertions:ass Actions:acts ERROR SEMICOLON
              {: RESULT = new AutomatonTransition(trigger, ass, acts, AutomatonInternalState.ERROR); :}
               | Bool:trigger  ARROW Assertions:ass Actions:acts STOP SEMICOLON
              {: RESULT = new AutomatonTransition(trigger, ass, acts, AutomatonInternalState.BOTTOM); :}
              ;

Assertions ::= Assertion:a Assertions:lst {: lst.add(0,a); RESULT = lst; :}
             | /* empty */ {: RESULT = new LinkedList<AutomatonBoolExpr>(); :}
             ;
Assertion  ::= ASS  Bool:b   {: RESULT = b; :};

Actions   ::= Action:a Actions:lst {: lst.add(0,a); RESULT = lst; :} // insert at the beginning of the list to preserve the order.
            | /* empty */ {: RESULT = new LinkedList<AutomatonActionExpr>(); :}
            ;
Action    ::= DO  IDENTIFIER:var EQ InnerInt:i   {: RESULT = new AutomatonActionExpr.Assignment(var.toString(), i); :}
			// InnerInt in this position allows for x = EVAL(..) Statements
            | PRINT PrintArguments:args {: RESULT = new AutomatonActionExpr.Print(args); :}
            | MODIFY OPEN_BRACKETS IDENTIFIER:cpa OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS CLOSE_BRACKETS
              {: RESULT = new AutomatonActionExpr.CPAModification(cpa.toString(), query.toString()); :}
            ;
            
PrintArguments ::= Expression:a PrintArguments:lst {: lst.add(0,a); RESULT = lst; :}
             | /* empty */ {: RESULT = new LinkedList<AutomatonExpression>(); :}
             ;
            
Int       ::= ConstantInt:c  {: RESULT = c; :}
			| OPEN_BRACKETS Int:i CLOSE_BRACKETS {: RESULT = i; :}
            | IDENTIFIER:x  {: RESULT = new AutomatonIntExpr.VarAccess(x.toString()); :}
            | InnerInt:a PLUS InnerInt:b  {: RESULT = new AutomatonIntExpr.Plus(a,b); :}
            | InnerInt:a MINUS InnerInt:b  {: RESULT = new AutomatonIntExpr.Minus(a,b); :}
            ;
            
// the int Expression "( EVAL(...) )" is forbidden (would conflict with the same BoolExpression if Bool would use EVAL instead of CHECK)

InnerInt  ::= Int:i {: RESULT = i; :}
			| EVAL OPEN_BRACKETS IDENTIFIER:cpa OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS CLOSE_BRACKETS
             {: RESULT = new AutomatonIntExpr.CPAQuery(cpa.toString(), query.toString()); :}
             ; 
            
ConstantInt ::= INTEGER_LITERAL:c  {: RESULT = new AutomatonIntExpr.Constant(c.toString()); :}
			;

Bool      ::= TRUE  {: RESULT = new AutomatonBoolExpr.True(); :}
            | FALSE  {: RESULT = new AutomatonBoolExpr.False(); :}
            | EXCLAMATION Bool:b  {: RESULT = new AutomatonBoolExpr.Negation(b); :}
            | OPEN_BRACKETS Bool:b CLOSE_BRACKETS {: RESULT = b; :}
            | InnerInt:a EQEQ InnerInt:b  {: RESULT = new AutomatonBoolExpr.IntEqTest(a,b); :}
            | InnerInt:a NEQ InnerInt:b  {: RESULT = new AutomatonBoolExpr.IntNotEqTest(a,b); :}
            | Bool:a EQEQ Bool:b  {: RESULT = new AutomatonBoolExpr.BoolEqTest(a,b); :}
            | Bool:a NEQ Bool:b  {: RESULT = new AutomatonBoolExpr.BoolNotEqTest(a,b); :}
            | Bool:a AND Bool:b {: RESULT = new AutomatonBoolExpr.And(a,b); :}
            | Bool:a OR Bool:b {: RESULT = new AutomatonBoolExpr.Or(a,b); :}
            | MATCH STRING_LITERAL:lit
              {: RESULT = new AutomatonBoolExpr.MatchCFAEdgeExact(lit.toString()); :}
            | MATCH CURLYEXPR:expr
              {: RESULT = new AutomatonBoolExpr.MatchCFAEdgeASTComparison(expr.toString()); :}
            | MATCH SQUAREEXPR:expr
              {: RESULT = new AutomatonBoolExpr.MatchCFAEdgeRegEx(expr.toString()); :}
            | MATCH LABEL SQUAREEXPR:expr
              {: RESULT = new AutomatonBoolExpr.MatchLabelRegEx(expr.toString()); :}
            | CHECK OPEN_BRACKETS IDENTIFIER:cpa OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS CLOSE_BRACKETS
              {: RESULT = new AutomatonBoolExpr.CPAQuery(cpa.toString(), query.toString()); :}
            | CHECK OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS
              {: RESULT = new AutomatonBoolExpr.ALLCPAQuery(query.toString()); :}
            ;
            
Expression	  ::= Int:i {: RESULT = i; :}
			| Bool:b {: RESULT = b; :}
			| STRING_LITERAL:lit {: RESULT = new AutomatonExpression.StringExpression(lit.toString()); :}
			| EVAL OPEN_BRACKETS IDENTIFIER:cpa OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS CLOSE_BRACKETS
             {: RESULT = new AutomatonExpression.CPAQuery(cpa.toString(), query.toString()); :}
             ; 
