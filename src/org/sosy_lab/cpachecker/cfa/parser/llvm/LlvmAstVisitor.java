/*
 * CPAchecker is a tool for configurable software verification.
 *  This file is part of CPAchecker.
 *
 *  Copyright (C) 2007-2017  Dirk Beyer
 *  All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 *  CPAchecker web page:
 *    http://cpachecker.sosy-lab.org
 */
package org.sosy_lab.cpachecker.cfa.parser.llvm;

import java.util.function.Function;
import org.llvm.*;

/**
 * Visitor for the AST generated by our LLVM parser
 *
 * @see LlvmParser
 */
public abstract class LlvmAstVisitor {

  public enum Behavior { CONTINUE, STOP }

  public void visit(final Module pItem) {
    Behavior behavior = visitModule(pItem);
    if (behavior == Behavior.STOP) {
      return;
    } else {
      assert behavior == Behavior.CONTINUE : "Unhandled behavior type " + behavior;
    }

    Value globalItem = pItem.getFirstGlobal();
    while (globalItem != null) {
      if (globalItem.isBasicBlock()) {
        visitGlobal0(globalItem.asBasicBlock());

      } else {
        behavior = visitGlobalItem(globalItem);
        if (behavior == Behavior.CONTINUE) {
          globalItem = globalItem.getNextGlobal();

        } else {
          assert behavior == Behavior.STOP : "Unhandled behavior type " + behavior;
          return;
        }
      }
    }

    Value localItem = pItem.getFirstFunction();
    while (localItem != null) {
      if (localItem.isBasicBlock()) {
        visitInFunction0(localItem.asBasicBlock());

      } else {
        behavior = visitInFunction(localItem);
        if (behavior == Behavior.CONTINUE) {
          localItem = localItem.getNextGlobal();

        } else {
          assert behavior == Behavior.STOP : "Unhandled behavior type " + behavior;
          return;
        }
      }
    }
  }

  private void visitGlobal0(final BasicBlock pItem) {
    Behavior behavior = visitGlobalItem(pItem);

    if (behavior == Behavior.CONTINUE) {
      iterateOverItems(pItem, this::visitGlobalItem);
    } else {
      assert behavior == Behavior.STOP : "Unhandled behavior type " + behavior;
    }
  }

  private void visitInFunction0(final BasicBlock pItem) {
    Behavior behavior = visitInFunction(pItem);

    if (behavior == Behavior.CONTINUE) {
      iterateOverItems(pItem, this::visitInFunction);
    } else {
      assert behavior == Behavior.STOP : "Unhandled behavior type " + behavior;

    }
  }

  private void iterateOverItems(final BasicBlock pItem, final Function<Value, Behavior> pVisitMethod) {
    Behavior behavior;
    Value nextInstr = pItem.getFirstInstruction();
    while (nextInstr != null) {
      if (nextInstr.isBasicBlock()) {
        visitGlobal0(nextInstr.asBasicBlock());

      } else {
        behavior = pVisitMethod.apply(nextInstr);

        if (behavior == Behavior.CONTINUE) {
          nextInstr = nextInstr.getNextInstruction(/* FIXME */ null);

        } else {
          assert behavior == Behavior.STOP : "Unhandled behavior type " + behavior;
          nextInstr = null;
        }
      }
    }
  }

  protected abstract Behavior visitModule(final Module pItem);
  protected abstract Behavior visitGlobalItem(final BasicBlock pItem);
  protected abstract Behavior visitInFunction(final BasicBlock pItem);
  protected abstract Behavior visitInFunction(final Value pItem);
  protected abstract Behavior visitGlobalItem(final Value pItem);
}
