package cpa.observeranalysis;

import java_cup.runtime.Symbol;
import java_cup.runtime.SymbolFactory;
import java.util.List;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.Map;
import cpa.common.LogManager;
import java.util.logging.Level;

/* Preliminaries to use the scanner.  */
scan with {: return scanner.next_token(); :};

parser code {: 
  /* this map is used to collect the local variables. It is then passed to each "VarAccess" and "Assignment" Expression.
   * ( I don't want to pass the Variable-Instance directly, because it might be defined after the Expression in the input Document.) 
   */
  protected Map<String, ObserverVariable> variablesMap = new HashMap<String, ObserverVariable>();
  public boolean syntaxErrors;
  ObserverScanner scanner;
  LogManager logger;

  public ObserverParser(ObserverScanner scanner, SymbolFactory sf, LogManager pLogger) {
      super(scanner, sf);
      this.scanner = scanner;
      this.logger = pLogger;
  }
  
  @Override
  public void report_error(String message, Object info) {
    syntaxErrors = true;
    String errorString = message;
    errorString = errorString + "ScannerLine: " + (scanner.getLine()+1) + " ScannerColumn: " + scanner.getColumn();
    
    if (info instanceof Symbol) { 
    	Symbol symbol = (Symbol) info;
    	if (!( symbol.left < 0 || symbol.right < 0 )) 
    		errorString = errorString + "\n at line "+symbol.left+", column "+symbol.right;
    }
    logger.log(Level.FINER, errorString);
  }
:}; 



terminal ARROW, SEMICOLON, COLON, OPEN_BRACKETS, CLOSE_BRACKETS, AUTOMATON, LOCAL, INITIAL, STATE, ASS, MATCH, CHECK, DO, PRINT, GOTO, IDENTIFIER, INTEGER_LITERAL, NEQ, EQ, EQEQ, PLUS, MINUS, TRUE, FALSE, STRING_LITERAL, CURLYEXPR, SQUAREEXPR ;

non terminal ObserverAutomaton initial ;
non terminal String Naming, InitDef ;
non terminal ObserverAutomaton Body ;
non terminal Map<String, ObserverVariable> LocalDefs ;
non terminal List<ObserverInternalState> StateDefs ;
non terminal List<ObserverTransition> Transitions ;
non terminal List<ObserverBoolExpr> Triggers ;
non terminal List<ObserverBoolExpr> Assertions ;
non terminal List<ObserverActionExpr> Actions ;

non terminal ObserverVariable LocalDef ;
non terminal ObserverInternalState StateDef ;
non terminal ObserverTransition Transition ;
non terminal ObserverBoolExpr Trigger ;
non terminal ObserverBoolExpr Assertion ;
non terminal ObserverActionExpr Action ;

non terminal ObserverIntExpr.Constant ConstantInt ;
non terminal ObserverIntExpr Int ;
non terminal ObserverBoolExpr Bool ; 

precedence left PLUS, MINUS;

initial ::= Naming:n Body:b {: b.setName(n); RESULT = b; :}
              | Body:b {: RESULT = b; :}
              ;

Naming    ::= AUTOMATON IDENTIFIER:id {: RESULT = id.toString(); :};

Body      ::= LocalDefs:vars InitDef:init StateDefs:states
              {: RESULT = new ObserverAutomaton(vars, states, init, parser.logger); :}
            ;
            
InitDef    ::= INITIAL STATE IDENTIFIER:id SEMICOLON {: RESULT = id.toString(); :};

LocalDefs ::= LocalDef:d LocalDefs:lst {: lst.put(d.getName(), d); RESULT = lst; :}
              | /* empty */ {: RESULT = parser.variablesMap; /* RESULT = new HashMap<String, ObserverVariable>(); */ :}
              ;
              
LocalDef  ::= LOCAL IDENTIFIER:type IDENTIFIER:name  SEMICOLON {: RESULT = new ObserverVariable(type.toString(), name.toString()); :}
            | LOCAL IDENTIFIER:type IDENTIFIER:name  EQ ConstantInt:ci SEMICOLON {: RESULT = new ObserverVariable(type.toString(), name.toString()); RESULT.setValue(ci.eval()); :}
            ;
            
StateDefs ::= StateDef:s StateDefs:lst  {: lst.add(s); RESULT = lst; :} // elements will be in reversed order (irrelevant ?)
            | /* empty */ {: RESULT = new LinkedList<ObserverInternalState>(); :}
              ;

StateDef  ::= STATE IDENTIFIER:id COLON  Transitions:ts   {: RESULT = new ObserverInternalState(id.toString(), ts); :} 
            ;
            
Transitions   ::= Transition:t Transitions:lst {: lst.add(0, t); RESULT = lst; :}
            | /* empty */ {: RESULT = new LinkedList<ObserverTransition>(); :}
            ;
            
Transition   ::= Triggers:triggers  ARROW Assertions:ass Actions:acts GOTO IDENTIFIER:follow SEMICOLON 
              {: RESULT = new ObserverTransition(triggers, ass, acts, follow.toString()); :}
              ;

Triggers   ::= Trigger:t Triggers:lst {: lst.add(0,t); RESULT = lst; :}
             | /* empty */ {: RESULT = new LinkedList<ObserverBoolExpr>(); :}
             ;
Trigger   ::= MATCH STRING_LITERAL:lit 
              {: RESULT = new ObserverBoolExpr.MatchCFAEdgeExact(lit.toString()); :} 
            | MATCH CURLYEXPR:expr
              {: RESULT = new ObserverBoolExpr.MatchCFAEdgeASTComparison(expr.toString()); :} 
            | MATCH SQUAREEXPR:expr
              {: RESULT = new ObserverBoolExpr.MatchCFAEdgeRegEx(expr.toString()); :}
            | CHECK OPEN_BRACKETS IDENTIFIER:cpa OPEN_BRACKETS STRING_LITERAL:query CLOSE_BRACKETS CLOSE_BRACKETS
              {: RESULT = new ObserverBoolExpr.CPAQuery(cpa.toString(), query.toString()); :}
            ;                           

Assertions ::= Assertion:a Assertions:lst {: lst.add(0,a); RESULT = lst; :}
             | /* empty */ {: RESULT = new LinkedList<ObserverBoolExpr>(); :}
             ;
Assertion  ::= ASS  Bool:b   {: RESULT = b; :};

Actions   ::= Action:a Actions:lst {: lst.add(0,a); RESULT = lst; :} // insert at the beginning of the list to preserve the order.
            | /* empty */ {: RESULT = new LinkedList<ObserverActionExpr>(); :} 
            ;
Action    ::= DO  IDENTIFIER:var EQ Int:i   {: RESULT = new ObserverActionExpr.Assignment(var.toString(), i); :} 
            | PRINT  STRING_LITERAL:lit {: RESULT = new ObserverActionExpr.Print(lit.toString()); :}
            | PRINT  Int:int_expr {: RESULT = new ObserverActionExpr.PrintInt(int_expr); :}
            ;

Int       ::= ConstantInt:c  {: RESULT = c; :}
            | IDENTIFIER:x  {: RESULT = new ObserverIntExpr.VarAccess(x.toString()); :}
            | Int:a PLUS Int:b  {: RESULT = new ObserverIntExpr.Plus(a,b); :}
            | Int:a MINUS Int:b  {: RESULT = new ObserverIntExpr.Minus(a,b); :}
            ;
            
ConstantInt ::= INTEGER_LITERAL:c  {: RESULT = new ObserverIntExpr.Constant(c.toString()); :}
			;

Bool      ::= TRUE  {: RESULT = new ObserverBoolExpr.True(); :}
            | FALSE  {: RESULT = new ObserverBoolExpr.False(); :}
            | Int:a EQEQ Int:b  {: RESULT = new ObserverBoolExpr.EqTest(a,b); :}
            | Int:a NEQ Int:b  {: RESULT = new ObserverBoolExpr.NotEqTest(a,b); :}
            ;