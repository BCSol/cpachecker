package cpa.observeranalysis;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.cdt.core.dom.ICodeReaderFactory;
import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
import org.eclipse.cdt.core.dom.ast.IASTName;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.IASTProblem;
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.model.ILanguage;
import org.eclipse.cdt.core.parser.CodeReader;
import org.eclipse.cdt.core.parser.IParserLogService;
import org.eclipse.cdt.core.parser.IScannerInfo;
import org.eclipse.cdt.core.parser.ParserFactory;
import org.eclipse.core.runtime.CoreException;

import cmdline.stubs.CLanguage;
import cmdline.stubs.StubCodeReaderFactory;
import cmdline.stubs.StubScannerInfo;

/**
 * Provides methods for generating, comparing and printing the ASTs generated from String.
 * The ASTs are generated by the Eclipse CDT IDE plugin.
 * @author rhein
 */
public class ObserverASTComparator {

  /**
   * Every occurrence of the joker expression $? in the pattern is substituted by JOKER_EXPR.
   * This is necessary because the C-parser cannot parse the pattern if it contains Dollar-Symbols.
   * The JOKER_EXPR must be a valid C-Identifier. It will be used to recognize the jokers in the generated AST.   
   */
  private static final String JOKER_EXPR = " CPAChecker_ObserverAnalysis_JokerExpression ";
  private static final String NUMBERED_JOKER_EXPR = " CPAChecker_ObserverAnalysis_JokerExpression_Num";
  private static final Pattern NUMBERED_JOKER_PATTERN = Pattern.compile("\\$\\d+");
  
  static String preparePatternString(String pPattern) {
    // $?-Jokers, $1-Jokers and function declaration
    return addFunctionDeclaration(replaceJokersInPattern(pPattern));
  }
  
  static String prepareSourceString(String pSource) {
    // only function declaration
    return addFunctionDeclaration(pSource);
  }

  static boolean generateAndCompareASTs(String pSourceExpression,
      IASTTranslationUnit pPatternAST, ObserverExpressionArguments pArgs) {
    IASTTranslationUnit a = ObserverASTComparator.parse(prepareSourceString(pSourceExpression));
        
    boolean result = ObserverASTComparator.compareASTs(a, pPatternAST, pArgs);
    return result;
  }

  static String replaceJokersInPattern(String pPattern) {
    String tmp = pPattern.replaceAll("\\$\\?", JOKER_EXPR);
    Matcher matcher = NUMBERED_JOKER_PATTERN.matcher(tmp);
    StringBuffer result = new StringBuffer();
    while (matcher.find()) {
      matcher.appendReplacement(result, "");
      String key = tmp.substring(matcher.start()+1, matcher.end());
      try {
        int varKey = Integer.parseInt(key);
        result.append(NUMBERED_JOKER_EXPR + varKey + " ");
      } catch (NumberFormatException e) {
        // did not work, but i cant log it down here. Should not be able to happen anyway (regex captures only ints)
        result.append(matcher.group());
      }
    }
    matcher.appendTail(result);
    return result.toString();
  }
  
  static IASTTranslationUnit generatePatternAST(String pPattern) {
    String tmp = preparePatternString(pPattern);
    return ObserverASTComparator.parse(tmp);
  }
  static IASTTranslationUnit generateSourceAST(String pSource) {
    String tmp = prepareSourceString(pSource);
    return ObserverASTComparator.parse(tmp);
  }
  
  /**
   * Returns the Problem Message if this AST has a problem node.
   * Returns null otherwise.
   * @param pAST
   * @return
   */
  static String ASTcontatinsProblems(IASTNode pAST) {
    if (pAST instanceof IASTProblem) {
      return ((IASTProblem)pAST).getMessage();
    } else {
      String problem;
      for (IASTNode n : pAST.getChildren()) {
        problem = ASTcontatinsProblems(n);
          if (problem != null) {
            return problem;
        }
      }
    }
    return null;
  }
  
  
  /**
   * Surrounds the argument with a function declaration. 
   * This is necessary so the string can be parsed by the CDT parser. 
   * @param pBody
   * @return "void test() { " + body + ";}";
   */
  private static String addFunctionDeclaration(String pBody) {
    if (pBody.trim().endsWith(";")) {
      return "void test() { " + pBody + "}";
    } else {
      return "void test() { " + pBody + ";}";
    }
      
  }
  
  
  /** Recursive method for comparing the ASTs.
   * pB is the pattern AST
   */
  static boolean compareASTs(IASTNode pA, IASTNode pB, ObserverExpressionArguments pArgs) {
    
    boolean result = true;
    if (isJoker(pB)) {
      result = true;
    } else if (handleNumberJoker(pA, pB, pArgs)) {
      result = true;
    } else if (pA.getClass().equals(pB.getClass())) {
      if (pA instanceof IASTName && ! IASTNamesAreEqual((IASTName)pA, (IASTName)pB)) {
        result = false;
      } else if (pA instanceof IASTLiteralExpression && ! IASTLiteralExpressionsAreEqual((IASTLiteralExpression)pA, (IASTLiteralExpression)pB)) {
        result = false;
      } else if (pA.getChildren().length != pB.getChildren().length) {
        result = false;
      } else {
        for (int i = 0; i < pA.getChildren().length; i++) {
          if (compareASTs(pA.getChildren()[i], pB.getChildren()[i], pArgs) == false)
            result = false;
          }
      }
    } else {
      result = false;
    }
    return result;
  }

  private static boolean handleNumberJoker(IASTNode pSource, IASTNode pPotentialJoker,
      ObserverExpressionArguments pArgs) {
    boolean isJoker = false;
    String number = "";
    if (pPotentialJoker instanceof IASTName) {
      IASTName name = (IASTName) pPotentialJoker;
      if (String.copyValueOf(name.getSimpleID()).startsWith(NUMBERED_JOKER_EXPR.trim())) {
        isJoker = true;
        number =  String.copyValueOf(name.getSimpleID()).substring(NUMBERED_JOKER_EXPR.trim().length());
      }
      // are there more IASTsomethings that could be Jokers?
    } else if (pPotentialJoker instanceof IASTIdExpression) {
      IASTIdExpression name = (IASTIdExpression) pPotentialJoker;
      if (name.getRawSignature().startsWith(NUMBERED_JOKER_EXPR.trim())) {
        isJoker = true;
        number =  name.getRawSignature().substring(NUMBERED_JOKER_EXPR.trim().length());
      }
    }
    if (isJoker) {
      // RawSignature returns the raw code before preprocessing.
      // This does not matter in this case because only very small sniplets, generated by method "addFunctionDeclaration" are tested, no preprocessing
      String value = pSource.getRawSignature();
      pArgs.putTransitionVariable(Integer.parseInt(number),value);
      return true;
    } else {
      return false; 
    }
  }
  
  public static void printAST(IASTTranslationUnit pAST) {
    printAST(pAST, 0);
  }
  /** Recursive method for printing an AST to System.out .
   */
  private static void printAST (IASTNode pNode, int pInd) {
    String x = "";
    for (int i = 0; i<pInd; i++) {
      x = x + "  ";
    }
    x = x + pNode.getClass().getName() + " "+ pNode.getRawSignature();
    System.out.println(x);
    for (IASTNode n : pNode.getChildren()) {
      printAST(n, pInd +1);
    }
  }

  private static boolean isJoker(IASTNode pNode) {
    if (pNode instanceof IASTName) {
      IASTName name = (IASTName) pNode;
      return String.copyValueOf(name.getSimpleID()).equals(JOKER_EXPR.trim());
      // are there more IASTsomethings that could be Jokers?
    } else if (pNode instanceof IASTName) {
      IASTName name = (IASTName) pNode;
      return String.copyValueOf(name.getSimpleID()).equals(JOKER_EXPR.trim());
    } else if (pNode instanceof IASTIdExpression) {
      IASTIdExpression name = (IASTIdExpression) pNode;
      return name.getRawSignature().equals(JOKER_EXPR.trim());
    } else return false;
  }

  private static boolean IASTNamesAreEqual(IASTName pA, IASTName pB) {
   return String.copyValueOf(pA.getSimpleID()).equals(String.copyValueOf(pB.getSimpleID()));
  }
  
  private static boolean IASTLiteralExpressionsAreEqual(IASTLiteralExpression pA, IASTLiteralExpression pB) {
    return String.copyValueOf(pA.getValue()).equals(String.copyValueOf(pB.getValue()));
   }

  /**
   * Parse the content of a file into an AST with the Eclipse CDT parser.
   * If an error occurs, the program is halted.
   * 
   * @param code The C code to parse.
   * @return The AST.
   */
  private static IASTTranslationUnit parse(String code) {
    CodeReader reader = new CodeReader(code.toCharArray());

    IScannerInfo scannerInfo = StubScannerInfo.getInstance();
    ICodeReaderFactory codeReaderFactory = new StubCodeReaderFactory();
    IParserLogService parserLog = ParserFactory.createDefaultLogService();

    ILanguage lang = new CLanguage("C99");

    try {
      return lang.getASTTranslationUnit(reader, scannerInfo, codeReaderFactory, null, parserLog);
    } catch (CoreException e) {
      // FIXME add error handling
      e.printStackTrace();
      assert false;
      return null;
    }
  }
}
