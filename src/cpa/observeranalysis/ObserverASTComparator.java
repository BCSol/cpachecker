package cpa.observeranalysis;

import org.eclipse.cdt.core.dom.ICodeReaderFactory;
import org.eclipse.cdt.core.dom.ast.IASTIdExpression;
import org.eclipse.cdt.core.dom.ast.IASTLiteralExpression;
import org.eclipse.cdt.core.dom.ast.IASTName;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.IASTProblem;
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.model.ILanguage;
import org.eclipse.cdt.core.parser.CodeReader;
import org.eclipse.cdt.core.parser.IParserLogService;
import org.eclipse.cdt.core.parser.IScannerInfo;
import org.eclipse.cdt.core.parser.ParserFactory;
import org.eclipse.core.runtime.CoreException;

import cmdline.stubs.CLanguage;
import cmdline.stubs.StubCodeReaderFactory;
import cmdline.stubs.StubConfiguration;

/**
 * Provides methods for generating, comparing and printing the ASTs generated from String.
 * The ASTs are generated by the Eclipse CDT IDE plugin.
 * @author rhein
 */
public class ObserverASTComparator {

  /**
   * Every occurrence of the joker expression $? in the pattern is substituted by JOKER_EXPR.
   * This is necessary because the C-parser cannot parse the pattern if it contains Dollar-Symbols.
   * The JOKER_EXPR must be a valid C-Identifier. It will be used to recognize the jokers in the generated AST.   
   */
  private static final String JOKER_EXPR = " CPAChecker_ObserverAnalysis_JokerExpression ";

  /**
   * Returns whether the ASTs for the argument strings are considered equal.
   * Substitutes wildcard expressions in pattern, generates the 2 ASTs and compares them.
   * 
   * The strings can be any C-Statement/Expression that may appear inside of a block.
   * @param pSourceExpression
   * @param pPattern
   * @return
   */
  static boolean generateAndCompareASTs(String pSourceExpression, String pPattern) {
    String tmp = addFunctionDeclaration(pSourceExpression);
    IASTTranslationUnit a = ObserverASTComparator.parse(tmp);
    
    tmp = addFunctionDeclaration(pPattern).replaceAll("\\$\\?", JOKER_EXPR);
    IASTTranslationUnit b = ObserverASTComparator.parse(tmp);
    
    boolean result = ObserverASTComparator.compareASTs(a, b);
    return result;
  }

  public static boolean generateAndCompareASTs(String pSourceExpression,
      IASTTranslationUnit pPatternAST) {
    String tmp = addFunctionDeclaration(pSourceExpression);
    IASTTranslationUnit a = ObserverASTComparator.parse(tmp);
        
    boolean result = ObserverASTComparator.compareASTs(a, pPatternAST);
    return result;
  }

  static IASTTranslationUnit generatePatternAST(String pPattern) {
    String tmp = addFunctionDeclaration(pPattern).replaceAll("\\$\\?", JOKER_EXPR);
    return ObserverASTComparator.parse(tmp);
  }
  
  /**
   * Returns the Problem Message if this AST has a problem node.
   * Returns null otherwise.
   * @param pAST
   * @return
   */
  static String ASTcontatinsProblems(IASTNode pAST) {
    if (pAST instanceof IASTProblem) {
      return ((IASTProblem)pAST).getMessage();
    } else {
      String problem;
      for (IASTNode n : pAST.getChildren()) {
        problem = ASTcontatinsProblems(n);
          if (problem != null) {
            return problem;
        }
      }
    }
    return null;
  }
  
  static void printAST(String pPattern) {
    printAST(generatePatternAST(pPattern), 0);
  }
  
  
  /**
   * Surrounds the argument with a function declaration. 
   * This is necessary so the string can be parsed by the CDT parser. 
   * @param pBody
   * @return "void test() { " + body + ";}";
   */
  private static String addFunctionDeclaration(String pBody) {
    if (pBody.trim().endsWith(";")) {
      return "void test() { " + pBody + "}";
    } else {
      return "void test() { " + pBody + ";}";
    }
      
  }
  
  
  /** Recursive method for comparing the ASTs.
   */
  private static boolean compareASTs(IASTNode pA, IASTNode pB) {
    boolean result = true;
    if (isJoker(pA) || isJoker(pB)) result = true;
    else if (pA.getClass().equals(pB.getClass())) {
      if (pA instanceof IASTName && ! IASTNamesAreEqual((IASTName)pA, (IASTName)pB)) {
        result = false;
      } else if (pA instanceof IASTLiteralExpression && ! IASTLiteralExpressionsAreEqual((IASTLiteralExpression)pA, (IASTLiteralExpression)pB)) {
        result = false;
      } else if (pA.getChildren().length != pB.getChildren().length) {
        result = false;
      } else {
        for (int i = 0; i < pA.getChildren().length; i++) {
          if (compareASTs(pA.getChildren()[i], pB.getChildren()[i]) == false)
            result = false;
          }
      }
    } else {
      result = false;
    }
    return result;
  }

  /** Recursive method for printing an AST to System.out .
   */
  private static void printAST (IASTNode pNode, int pInd) {
    String x = "";
    for (int i = 0; i<pInd; i++) {
      x = x + "  ";
    }
    x = x + pNode.getClass().getName() + " "+ pNode.getRawSignature();
    System.out.println(x);
    for (IASTNode n : pNode.getChildren()) {
      printAST(n, pInd +1);
    }
  }

  private static boolean isJoker(IASTNode pNode) {
    if (pNode instanceof IASTName) {
      IASTName name = (IASTName) pNode;
      return String.copyValueOf(name.getSimpleID()).equals(JOKER_EXPR.trim());
      // are there more IASTsomethings that could be Jokers?
    } else if (pNode instanceof IASTName) {
      IASTName name = (IASTName) pNode;
      return String.copyValueOf(name.getSimpleID()).equals(JOKER_EXPR.trim());
    } else if (pNode instanceof IASTIdExpression) {
      IASTIdExpression name = (IASTIdExpression) pNode;
      return name.getRawSignature().equals(JOKER_EXPR.trim());
    } else return false;
  }

  private static boolean IASTNamesAreEqual(IASTName pA, IASTName pB) {
   return String.copyValueOf(pA.getSimpleID()).equals(String.copyValueOf(pB.getSimpleID()));
  }
  
  private static boolean IASTLiteralExpressionsAreEqual(IASTLiteralExpression pA, IASTLiteralExpression pB) {
    return String.copyValueOf(pA.getValue()).equals(String.copyValueOf(pB.getValue()));
   }

  /**
   * Parse the content of a file into an AST with the Eclipse CDT parser.
   * If an error occurs, the program is halted.
   * 
   * @param code The C code to parse.
   * @return The AST.
   */
  private static IASTTranslationUnit parse(String code) {
    CodeReader reader = new CodeReader(code.toCharArray());

    IScannerInfo scannerInfo = StubConfiguration.getStubScannerInfo();
    ICodeReaderFactory codeReaderFactory = new StubCodeReaderFactory();
    IParserLogService parserLog = ParserFactory.createDefaultLogService();

    ILanguage lang = new CLanguage("C99");

    try {
      return lang.getASTTranslationUnit(reader, scannerInfo, codeReaderFactory, null, parserLog);
    } catch (CoreException e) {
      // FIXME add error handling
      e.printStackTrace();
      assert false;
      return null;
    }
  }
}
