
package fql.frontend.parser;

import java_cup.runtime.*;

import fql.frontend.ast.coverage.States;
import fql.frontend.ast.coverage.Edges;
import fql.frontend.ast.coverage.Paths;
import fql.frontend.ast.coverage.Coverage;
import fql.frontend.ast.coverage.ConditionalCoverage;
import fql.frontend.ast.filter.Identity;
import fql.frontend.ast.filter.File;
import fql.frontend.ast.filter.BasicBlockEntry;
import fql.frontend.ast.filter.ConditionEdge;
import fql.frontend.ast.filter.DecisionEdge;
import fql.frontend.ast.filter.ConditionGraph;
import fql.frontend.ast.filter.Line;
import fql.frontend.ast.filter.FunctionCalls;
import fql.frontend.ast.filter.Column;
import fql.frontend.ast.filter.Function;
import fql.frontend.ast.filter.Label;
import fql.frontend.ast.filter.FunctionCall;
import fql.frontend.ast.filter.FunctionEntry;
import fql.frontend.ast.filter.FunctionExit;
import fql.frontend.ast.filter.EnclosingScopes;
import fql.frontend.ast.filter.Compose;
import fql.frontend.ast.filter.Expression;
import fql.frontend.ast.filter.RegularExpression;
import fql.frontend.ast.filter.Filter;
import fql.frontend.ast.filter.SetMinus;
import fql.frontend.ast.filter.Intersection;
import fql.frontend.ast.filter.Union;
import fql.frontend.ast.filter.Complement;
import fql.frontend.ast.predicate.Predicate;
import fql.frontend.ast.predicate.Term;
import fql.frontend.ast.predicate.CIdentifier;
import fql.frontend.ast.predicate.NaturalNumber;
import fql.frontend.ast.predicate.Predicates;
import fql.frontend.ast.pathmonitor.PathMonitor;
import fql.frontend.ast.pathmonitor.ConditionalMonitor;
import fql.frontend.ast.pathmonitor.LowerBound;
import fql.frontend.ast.pathmonitor.UpperBound;
import fql.frontend.ast.pathmonitor.Concatenation;
import fql.frontend.ast.pathmonitor.Alternative;
import fql.frontend.ast.coverage.Sequence;
import fql.frontend.ast.query.Query;
import fql.frontend.ast.query.FilterPropagator;
import fql.frontend.ast.FQLNode;

import java.io.Reader;
import java.io.InputStream;
import java.io.StringReader;

parser code
{:
	public FQLParser(String pQueryString) {
      this(new StringReader(pQueryString));
	}
	
	public FQLParser(Reader pReader) {
	  this(new FQLLexer(pReader));
	}
	
	public FQLParser(InputStream pInputStream) {
	  this(new FQLLexer(pInputStream));
	}
:}

action code
{:
:}

/* general */
terminal TOK_L_PARENTHESIS;
terminal TOK_R_PARENTHESIS;
terminal TOK_COMMA;

/* filter functions */
terminal TOK_IDENTITY;
terminal TOK_FILE;
terminal TOK_LINE;
terminal Integer TOK_LINE_ABBREV;
terminal TOK_COLUMN;
terminal TOK_FUNC;
terminal TOK_LABEL;
terminal TOK_CALL;
terminal TOK_CALLS;
terminal TOK_ENTRY;
terminal TOK_EXIT;
terminal TOK_EXPR;
terminal TOK_REGEXP;
terminal TOK_BASICBLOCKENTRY;
terminal TOK_CONDITIONEDGE;
terminal TOK_DECISIONEDGE;
terminal TOK_CONDITIONGRAPH;
/*terminal TOK_DEF;*/
/*terminal TOK_USE;*/
/*terminal TOK_STMTTYPE;*/
/*terminal TOK_STT_IF;*/
/*terminal TOK_STT_FOR;*/
/*terminal TOK_STT_WHILE;*/
/*terminal TOK_STT_SWITCH;*/
/*terminal TOK_STT_CONDOP;*/
/*terminal TOK_STT_ASSERT;*/

/* operations on target graphs */
terminal TOK_COMPLEMENT;
terminal TOK_UNION;
terminal TOK_INTERSECT;
terminal TOK_SETMINUS;
terminal TOK_ENCLOSING_SCOPES;
terminal TOK_COMPOSE;

/* abstraction/predicates */
terminal TOK_L_BRACE;
terminal TOK_R_BRACE;
terminal TOK_GREATER_OR_EQ;
terminal TOK_GREATER;
terminal TOK_EQ;
terminal TOK_LESS_OR_EQ;
terminal TOK_LESS;
terminal TOK_NEQ;

/* coverage specification */
terminal TOK_STATECOV;
terminal TOK_EDGECOV;
terminal TOK_PATHCOV;
terminal TOK_L_SEQ;
terminal TOK_R_SEQ;


/* path monitors */
terminal TOK_NEXT;
terminal TOK_CONCAT;
terminal TOK_ALTERNATIVE;
terminal TOK_KLEENE;

/* query */
terminal TOK_IN;
terminal TOK_COVER;
terminal TOK_PASSING;

/* C identifier */
terminal String TOK_C_IDENT;
terminal String TOK_QUOTED_STRING;

/* a natural number */
terminal Integer TOK_NAT_NUMBER;


non terminal 	Query;
non terminal 	Scope;
non terminal 	Cover;
non terminal	Passing;
non terminal 	Test_Goal_Sequence;
non terminal	Path_Monitor;
non terminal	Path_Monitor_Term;
non terminal	Path_Monitor_Factor;
non terminal	Test_Goal_Set;
non terminal	Preconditions;
non terminal	Predicates;
non terminal	Predicate;
non terminal	c_LHS;
non terminal	Comparison;
non terminal	Filter;
non terminal	Filter_Function;

start with Query;

Query				::= 
						Scope:filter Cover:coverage Passing:monitor
						{:
							assert(coverage != null);
							assert(coverage instanceof Coverage);
							
							Coverage lCoverage;
							
							if (filter != null) {
								assert(filter instanceof Filter);
							
								FQLNode lNode = ((Coverage)coverage).accept(new FilterPropagator((Filter)filter));
								
								assert(lNode != null);
								assert(lNode instanceof Coverage);
								
								lCoverage = (Coverage)lNode;
							}
							else {
								lCoverage = (Coverage)coverage;
							}
							
							// determine passing monitor
							PathMonitor lMonitor;
							
							if (monitor == null) {
								lMonitor = new LowerBound(Identity.getInstance(), 0);
							}
							else {
								assert(monitor instanceof PathMonitor);
								
								lMonitor = (PathMonitor)monitor;
							}

							RESULT = new Query(lCoverage, lMonitor);							
						:}
					;
				
Scope				::= 
					| 	TOK_IN Filter:filter
						{:
							RESULT = filter;
						:}
					;

Cover				::= 
						TOK_COVER Test_Goal_Sequence:sequence
						{:
							RESULT = sequence;
						:}
					;
				
Passing				::= 
					| 	TOK_PASSING Path_Monitor:monitor
						{:
							RESULT = monitor;
						:}
					;
				
Test_Goal_Sequence 	::=	
						Test_Goal_Set:coverage
						{:
							assert(coverage != null);
							assert(coverage instanceof Coverage);
							
							PathMonitor lInitialMonitor = new LowerBound(Identity.getInstance(), 0);
							PathMonitor lFinalMonitor = new LowerBound(Identity.getInstance(), 0);
							
							RESULT = new Sequence(lInitialMonitor, (Coverage)coverage, lFinalMonitor);
						:} 
					| 	Test_Goal_Sequence:sequence TOK_L_SEQ Path_Monitor:monitor TOK_R_SEQ Test_Goal_Set:coverage
						{:
							assert(sequence != null);
							assert(sequence instanceof Sequence);
							
							assert(monitor != null);
							assert(monitor instanceof PathMonitor);
							
							assert(coverage != null);
							assert(coverage instanceof Coverage);
							
							Sequence lSequence = (Sequence)sequence;
							
							lSequence.extend((PathMonitor)monitor, (Coverage)coverage);
							
							RESULT = lSequence;
						:}
					|	Test_Goal_Sequence:sequence TOK_NEXT Test_Goal_Set:coverage
						{:
							assert(sequence != null);
							assert(sequence instanceof Sequence);
							
							assert(coverage != null);
							assert(coverage instanceof Coverage);
							
							Sequence lSequence = (Sequence)sequence;
							
							lSequence.extend(new LowerBound(Identity.getInstance(), 0), (Coverage)coverage);
							
							RESULT = lSequence;
						:}
					;
					
Path_Monitor		::= 
						Path_Monitor_Term:monitor 
					  	{:
					  		RESULT = monitor;
					  	:}
					  | Path_Monitor:monitor1 TOK_ALTERNATIVE Path_Monitor_Term:monitor2
						{:
							assert(monitor1 != null);
							assert(monitor2 != null);
							
							assert(monitor1 instanceof PathMonitor);
							assert(monitor2 instanceof PathMonitor);
							
							RESULT = new Alternative((PathMonitor)monitor1, (PathMonitor)monitor2);
						:}
					;
					
Path_Monitor_Term	::= 
						Path_Monitor_Factor:monitor
						{:
							RESULT = monitor;
						:} 
					| 	Path_Monitor_Term:monitor1 TOK_CONCAT Path_Monitor_Factor:monitor2
						{:
							assert(monitor1 != null);
							assert(monitor1 instanceof PathMonitor);
							
							assert(monitor2 != null);
							assert(monitor2 instanceof PathMonitor);
							
							RESULT = new Concatenation((PathMonitor)monitor1, (PathMonitor)monitor2);
						:}
					|	Path_Monitor_Term:monitor1 TOK_NEXT Path_Monitor_Factor:monitor2
						{:
							/* Shorthand for monitor1.ID*.monitor2 */
							
							assert(monitor1 != null);
							assert(monitor1 instanceof PathMonitor);
							
							assert(monitor2 != null);
							assert(monitor2 instanceof PathMonitor);
							
							PathMonitor lIdStar = new LowerBound(Identity.getInstance(), 0);
							
							PathMonitor lConcatenation = new Concatenation((PathMonitor)monitor1, lIdStar);
							RESULT = new Concatenation(lConcatenation, (PathMonitor)monitor2);
						:}
					;
					
Path_Monitor_Factor	::= 
						Preconditions:preconditions Filter:filter
						{:
							RESULT = filter;
						:}
					| 	Preconditions:preconditions TOK_L_PARENTHESIS Path_Monitor:monitor TOK_R_PARENTHESIS
						{:
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							assert(monitor != null);
							assert(monitor instanceof PathMonitor);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							PathMonitor lSubmonitor = (PathMonitor)monitor;
							
							PathMonitor lMonitor;
							
							if (lPreconditions.isEmpty()) {
								lMonitor = lSubmonitor;
							}
							else {
								if (lSubmonitor instanceof ConditionalMonitor) {
									ConditionalMonitor lConditionalMonitor = (ConditionalMonitor)lSubmonitor;
									
									Predicates lSubpreconditions = lConditionalMonitor.getPreconditions();
									
									lSubpreconditions.add(lPreconditions);
									
									lMonitor = lConditionalMonitor;
								}
								else {
									lMonitor = new ConditionalMonitor(lPreconditions, lSubmonitor, new Predicates());
								}
							}
							
							RESULT = lMonitor;
						:}
					| 	Path_Monitor_Factor:factor Predicate:predicate
						{:
							assert(factor != null);
							assert(predicate != null);
							
							assert(factor instanceof PathMonitor);
							assert(predicate instanceof Predicate);
							
							ConditionalMonitor lMonitor;
							
							if (factor instanceof ConditionalMonitor) {
							  ConditionalMonitor lConditionalMonitor = (ConditionalMonitor)factor;
							  
							  Predicates lPostconditions = lConditionalMonitor.getPostconditions();
							  lPostconditions.add((Predicate)predicate);
							  
							  lMonitor = lConditionalMonitor;
							}
							else {
							  Predicates lPostconditions = new Predicates();
							  lPostconditions.add((Predicate)predicate);
							  
							  lMonitor = new ConditionalMonitor(new Predicates(), (PathMonitor)factor, lPostconditions);
							}
							
							RESULT = lMonitor;
						:}
					| 	Path_Monitor_Factor:factor TOK_KLEENE
						{:
							assert(factor != null);
							assert(factor instanceof PathMonitor);
							
							RESULT = new LowerBound((PathMonitor)factor, 0);
						:}
					| 	Path_Monitor_Factor:factor TOK_LESS_OR_EQ TOK_NAT_NUMBER:bound
						{:
							assert(factor != null);
							assert(factor instanceof PathMonitor);
							
							RESULT = new UpperBound((PathMonitor)factor, bound.intValue());
						:}
					| 	Path_Monitor_Factor:factor TOK_GREATER_OR_EQ TOK_NAT_NUMBER:bound
						{:
							assert(factor != null);
							assert(factor instanceof PathMonitor);
							
							RESULT = new LowerBound((PathMonitor)factor, bound.intValue());
						:}
					;
					
Test_Goal_Set		::=
						Preconditions:preconditions TOK_L_PARENTHESIS Test_Goal_Set:tgs TOK_R_PARENTHESIS
						{:
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPredicates = (Predicates)preconditions;
							
							if (lPredicates.isEmpty()) {
								RESULT = tgs;
							}
							else {
								assert(tgs != null);
								assert(tgs instanceof Coverage);
							
								RESULT = new ConditionalCoverage(lPredicates, (Coverage)tgs, new Predicates());
							}
						:} 
					| 	Test_Goal_Set:tgs Predicate:predicate
						{:
							assert(tgs != null);
							assert(tgs instanceof Coverage);
							
							assert(predicate != null);
							assert(predicate instanceof Predicate);
							
							Coverage lCoverage;
							
							if (tgs instanceof ConditionalCoverage) {
								ConditionalCoverage lConditionalCoverage = (ConditionalCoverage)tgs;
								
								Predicates lPostconditions = lConditionalCoverage.getPostconditions();
								lPostconditions.add((Predicate)predicate);
								
								lCoverage = (Coverage)tgs;
							}
							else {
								Predicates lPostconditions = new Predicates();
								lPostconditions.add((Predicate)predicate);
								
								lCoverage = new ConditionalCoverage(new Predicates(), (Coverage)tgs, lPostconditions);
							}
							
							RESULT = lCoverage;
						:}
					|	Preconditions:preconditions TOK_UNION TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lUnion = new fql.frontend.ast.coverage.Union((Coverage)coverage1, (Coverage)coverage2); 
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lUnion;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lUnion, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					|   Preconditions:preconditions TOK_INTERSECT TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lIntersection = new fql.frontend.ast.coverage.Intersection((Coverage)coverage1, (Coverage)coverage2); 
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lIntersection;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lIntersection, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_SETMINUS TOK_L_PARENTHESIS Test_Goal_Set:coverage1 TOK_COMMA Test_Goal_Set:coverage2 TOK_R_PARENTHESIS
						{:
							assert(coverage1 != null);
							assert(coverage2 != null);
							
							assert(coverage1 instanceof Coverage);
							assert(coverage2 instanceof Coverage);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lSetMinus = new fql.frontend.ast.coverage.SetMinus((Coverage)coverage1, (Coverage)coverage2); 
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lSetMinus;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lSetMinus, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_STATECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lStates = new States((Filter)filter, new Predicates()); 
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lStates;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lStates, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_STATECOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(predicates != null);
							
							assert(filter instanceof Filter);
							assert(predicates instanceof Predicates);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lStates = new States((Filter)filter, (Predicates)predicates);
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lStates;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lStates, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_EDGECOV TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lEdges = new Edges((Filter)filter, new Predicates());
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lEdges;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lEdges, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_EDGECOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(predicates != null);
							assert(predicates instanceof Predicates);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lEdges = new Edges((Filter)filter, (Predicates)predicates);
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lEdges;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lEdges, new Predicates());
							}
							
							RESULT = lCoverage;
						:}
					| 	Preconditions:preconditions TOK_PATHCOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA TOK_NAT_NUMBER:bound TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
														
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lPaths = new Paths((Filter)filter, bound.intValue(), new Predicates());
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lPaths;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lPaths, new Predicates());
							}
							
							RESULT = lCoverage; 
						:}
					| 	Preconditions:preconditions TOK_PATHCOV TOK_L_PARENTHESIS Filter:filter TOK_COMMA TOK_NAT_NUMBER:bound TOK_COMMA Predicates:predicates TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							assert(predicates != null);
							assert(predicates instanceof Predicates);
							
							assert(preconditions != null);
							assert(preconditions instanceof Predicates);
							
							Predicates lPreconditions = (Predicates)preconditions;
							
							Coverage lPaths = new Paths((Filter)filter, bound.intValue(), (Predicates)predicates);
							
							Coverage lCoverage;
							
							if (lPreconditions.isEmpty()) {
								lCoverage =  lPaths;
							}
							else {
								lCoverage = new ConditionalCoverage(lPreconditions, lPaths, new Predicates());
							}
							
							RESULT = lCoverage; 
						:}
					;
					
Preconditions		::= 
						{:
							RESULT = new Predicates();
						:}
					|	Preconditions:predicates Predicate:predicate
						{:
							assert(predicates != null);
							assert(predicate != null);
							
							assert(predicates instanceof Predicates);
							assert(predicate instanceof Predicate);
							
							Predicates lPredicates = (Predicates)predicates;
							Predicate lPredicate = (Predicate)predicate;
							
							lPredicates.add(lPredicate);
							
							RESULT = lPredicates;
						:}
					;
					
Predicates			::= 
						Predicate:predicate
						{:
							assert(predicate != null);
							assert(predicate instanceof Predicate);
							
							Predicates lPredicates = new Predicates();
							
							lPredicates.add((Predicate)predicate);
							
							RESULT = lPredicates;
						:} 
					| 	Predicates:predicates TOK_COMMA Predicate:predicate
						{:
							assert(predicates != null);
							assert(predicate != null);
							
							assert(predicates instanceof Predicates);
							assert(predicate instanceof Predicate);
							
							Predicates lPredicates = (Predicates)predicates;
							Predicate lPredicate = (Predicate)predicate;
							
							lPredicates.add(lPredicate);
							
							RESULT = lPredicates;
						:}
					;
					
Predicate			::=
						TOK_L_BRACE c_LHS:leftterm Comparison:comparison c_LHS:rightterm TOK_R_BRACE
						{:
							assert(leftterm != null);
							assert(comparison != null);
							assert(rightterm != null);
							
							assert(leftterm instanceof Term);
							assert(comparison instanceof Predicate.Comparison);
							assert(rightterm instanceof Term);
							
							RESULT = new Predicate((Term)leftterm, (Predicate.Comparison)comparison, (Term)rightterm);
						:}
					;
					
c_LHS				::= 
						TOK_C_IDENT:identifier
						{:
							RESULT = new CIdentifier(identifier);
						:}
					| 	TOK_NAT_NUMBER:number
						{:
							RESULT = new NaturalNumber(number);
						:}
					;
					
Comparison			::= 
						TOK_GREATER_OR_EQ
						{:
							RESULT = Predicate.Comparison.GREATER_OR_EQUAL;
						:} 
					| 	TOK_GREATER
						{:
							RESULT = Predicate.Comparison.GREATER;
						:} 
					| 	TOK_EQ
						{:
							RESULT = Predicate.Comparison.EQUAL;
						:} 
					| 	TOK_LESS_OR_EQ
						{:
							RESULT = Predicate.Comparison.LESS_OR_EQUAL;
						:} 
					| 	TOK_LESS
						{:
							RESULT = Predicate.Comparison.LESS;
						:}
					| 	TOK_NEQ
						{:
							RESULT = Predicate.Comparison.NOT_EQUAL;
						:}
					;
					
Filter				::=
						Filter_Function:filter
						{:
							RESULT = filter;
						:}
					|	TOK_COMPLEMENT TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new Complement((Filter)filter);
						:}
					| 	TOK_UNION TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Union((Filter)filter1, (Filter)filter2);
						:}
					|	TOK_INTERSECT TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Intersection((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_SETMINUS TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new SetMinus((Filter)filter1, (Filter)filter2);
						:}
					| 	TOK_ENCLOSING_SCOPES TOK_L_PARENTHESIS Filter:filter TOK_R_PARENTHESIS
						{:
							assert(filter != null);
							assert(filter instanceof Filter);
							
							RESULT = new EnclosingScopes((Filter)filter);
						:}
					| 	TOK_COMPOSE TOK_L_PARENTHESIS Filter:filter1 TOK_COMMA Filter:filter2 TOK_R_PARENTHESIS
						{:
							assert(filter1 != null);
							assert(filter2 != null);
							assert(filter1 instanceof Filter);
							assert(filter2 instanceof Filter);
						
							RESULT = new Compose((Filter)filter1, (Filter)filter2);
						:}
					;
					
Filter_Function		::=
						TOK_IDENTITY
						{:
							RESULT = Identity.getInstance();
						:}
					|	TOK_FILE TOK_L_PARENTHESIS TOK_QUOTED_STRING:filename TOK_R_PARENTHESIS
						{:
							RESULT = new File(filename);
						:}
					|	TOK_LINE TOK_L_PARENTHESIS TOK_NAT_NUMBER:linenumber TOK_R_PARENTHESIS
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_LINE_ABBREV:linenumber
						{:
							RESULT = new Line(linenumber);
						:}
					|	TOK_COLUMN TOK_L_PARENTHESIS TOK_NAT_NUMBER:columnnumber TOK_R_PARENTHESIS
						{:
							RESULT = new Column(columnnumber);
						:}
					| 	TOK_FUNC TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new Function(function);
						:}
					|	TOK_LABEL TOK_L_PARENTHESIS TOK_C_IDENT:label TOK_R_PARENTHESIS
						{:
							RESULT = new Label(label);
						:}
					| 	TOK_CALL TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionCall(function);
						:}
					|	TOK_CALLS
						{:
							RESULT = FunctionCalls.getInstance();
						:}
					| 	TOK_ENTRY TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionEntry(function);
						:}
					|	TOK_EXIT TOK_L_PARENTHESIS TOK_C_IDENT:function TOK_R_PARENTHESIS
						{:
							RESULT = new FunctionExit(function);
						:}
					|	TOK_EXPR TOK_L_PARENTHESIS TOK_QUOTED_STRING:expression TOK_R_PARENTHESIS
						{:
							RESULT = new Expression(expression);
						:}
					|	TOK_REGEXP TOK_L_PARENTHESIS TOK_QUOTED_STRING:regularexpression TOK_R_PARENTHESIS
						{:
							RESULT = new RegularExpression(regularexpression);
						:}
					|	TOK_BASICBLOCKENTRY
						{:
							RESULT = BasicBlockEntry.getInstance();
						:}
					| 	TOK_CONDITIONEDGE
						{:
							RESULT = ConditionEdge.getInstance();
						:}
					|	TOK_DECISIONEDGE
						{:
							RESULT = DecisionEdge.getInstance();
						:}
					|	TOK_CONDITIONGRAPH
						{:
							RESULT = ConditionGraph.getInstance();
						:}
					;
