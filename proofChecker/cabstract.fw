@=~
~p maximum_input_line_length = infinity
~O~<convert.specs~>~{
$/Name/CScope.gnrc:inst
parserInterface.h
parserInterface.c
~}
~O~<convert.head~>~{
#include "parserInterface.h"

~}
~O~<convert.gla~>~{
ident: C_IDENTIFIER [mkidn]
integer: C_INT_DENOTATION [mkidn]
include_string: $\<[a-zA-Z\.]*\> [mkstr]
C_COMMENT 
~}
~O~<convert.con~>~{
root: 
  source . 

source:
  file . 

file: 
  translation_unit .
 
translation_unit:
  external_declaration /
  translation_unit external_declaration .

external_declaration: 
  pre_include / function_definition / declaration . 

pre_include:
  '#' 'include' include_string .

function_definition:
  type_specifier ident '(' parameter_list_opt ')' compound_statement_opt /
  type_specifier ident '(' parameter_list_opt ')' compound_statement_opt .

type_specifier:
  'long' /
  'unsigned' 'long' / 
  'int' / 
  'unsigned' 'int' /
  'bool' / 
  'void' /
  'extern' 'long' /
  'extern' 'int' / 
  'extern' 'bool' / 
  'extern' 'void' . 

parameter_list_opt: 
  / 'void' / 
  parameter_list .

parameter_list: 
  parameter / 
  parameter_list ',' parameter . 

parameter: 
  type_specifier ident .

declaration_list: 
  declaration / 
  declaration_list declaration . 

declaration: 
  type_specifier init_declarator_list ';' .

init_declarator_list: 
  init_declarator / 
  init_declarator_list ',' init_declarator . 

init_declarator:
  ident / 
  ident '=' integer_constant 'of' type_specifier /
  ident '=' initializer . 

initializer:
  conditional_expression .

compound_statement_opt: 
  ';' / 
  compound_statement . 

compound_statement: 
  '{' declaration_list statement_list_opt '}' / 
  '{' statement_list_opt '}' . 

statement_list_opt: 
  / 
  statement_list . 

statement_list: 
  statement / 
  statement_list statement . 

statement: 
  labeled_statement / 
  compound_statement / 
  expression_statement / 
  selection_statement / 
  jump_statement . 

labeled_statement: 
  ident ':' statement .

expression_statement:
  expression_opt ';' .

expression_opt: 
  / 
  assignment_expression .

assignment_expression: 
  function_call_expression / 
  IdUse assignment_operator function_call_expression . 

function_call_expression: 
  '(' type_specifier ')' ident '(' argument_expression_list_opt ')' / 
  ident '(' argument_expression_list_opt ')' / 
  conditional_expression .

assignment_operator:
  '=' / 
  '*=' / 
  '/=' / 
  '%=' / 
  '+=' / 
  '-=' . 

logical_OR_operator:
  '||' .

logical_XOR_operator: 
  '^^' .

logical_AND_operator: 
  '&&' .

inclusive_OR_operator:
  '|' .

exclusive_OR_operator:
  '^' .

and_operator:
  '&' .

equality_operator:
  '==' | '!=' .

relational_operator:
  '<'  /
  '<=' /
  '>' /
  '>=' .

shift_operator:
  '<<' /
  '>>' .

additive_operator:
  '+' /
  '-' .

multiplicative_operator:
  '*' /
  '/' /
  '%'  . 

conditional_expression: 
  logical_OR_expression . 
#  logical_OR_expression '?' expression ':' conditional_expression .

logical_OR_expression: 
  logical_XOR_expression / 
  logical_OR_expression logical_OR_operator logical_XOR_expression .

logical_XOR_expression: 
  logical_AND_expression / 
  logical_XOR_expression logical_XOR_operator logical_AND_expression .

logical_AND_expression: 
  inclusive_OR_expression / 
  logical_AND_expression logical_AND_operator inclusive_OR_expression .

inclusive_OR_expression: 
  exclusive_OR_expression / 
  inclusive_OR_expression inclusive_OR_operator exclusive_OR_expression .

exclusive_OR_expression: 
  AND_expression / 
  exclusive_OR_expression exclusive_OR_operator AND_expression .

AND_expression: 
  equality_expression / 
  AND_expression and_operator equality_expression .

equality_expression: 
  relational_expression / 
  equality_expression equality_operator relational_expression .

relational_expression: 
  shift_expression / 
  relational_expression relational_operator shift_expression .

shift_expression: 
  additive_expression / 
  shift_expression shift_operator additive_expression .

additive_expression: 
  multiplicative_expression / 
  additive_expression additive_operator multiplicative_expression .

multiplicative_expression: 
  cast_expression / 
  multiplicative_expression multiplicative_operator cast_expression .

cast_expression: 
  '(' type_specifier ')' cast_expression / 
  unary_expression .

unary_expression: 
  postfix_expression / 
  '++' unary_expression / 
  '--' unary_expression / 
  '&' unary_expression /
  '*' unary_expression /  
  unary_operator cast_expression . 

unary_operator:  
  '-' / 
  '!' . 

postfix_expression: 
  primary_expression / 
  postfix_expression '++' / 
  postfix_expression '--' . 

argument_expression_list_opt:
  /
  argument_expression_list .

argument_expression_list:
  conditional_expression /
  argument_expression_list ',' conditional_expression.

primary_expression: 
  IdUse / 
  constant / 
  '(' conditional_expression ')' .

IdUse: 
  ident .

constant: 
  integer_constant /
  'false' /
  'true' .

integer_constant:
  integer . 

selection_statement:
  'if' '(' conditional_expression ')' statement $'else' /
  'if' '(' conditional_expression ')' statement 'else' statement .

jump_statement:
  'goto' ident ';' /
  'return' expression_opt ';' .

~}

~O~<convert.map~>~{
	MAPSYM 
	Expression ::= primary_expression postfix_expression unary_expression cast_expression multiplicative_expression  additive_expression shift_expression relational_expression equality_expression AND_expression exclusive_OR_expression inclusive_OR_expression logical_AND_expression logical_OR_expression logical_XOR_expression conditional_expression .
	BinOp ::= multiplicative_operator additive_operator relational_operator equality_operator logical_AND_operator logical_OR_operator logical_XOR_operator .
~}

~O~<convert.lido~>~{
ATTR input: UINT;
ATTR result: UINT;
ATTR jumpsResolved: VOID;
ATTR labelsDefined: VOID;

ATTR mark1 : UINT;
ATTR mark2 : UINT;
ATTR mark3 : UINT;

RULE: function_definition ::= type_specifier ident '(' parameter_list_opt ')' compound_statement_opt COMPUTE
	.mark1 = new_node(); #root of function CFA
	compound_statement_opt.input = .mark1;
	function_definition.labelsDefined = compound_statement_opt.result;
	.s1 = CONSTITUENTS jump_statement.jumpsResolved <- function_definition.labelsDefined;
	traverse_cfa(.mark1, StringTable(ident)) <- .s1;
END;

RULE: function_definition ::= type_specifier '(' ident ')' '(' parameter_list_opt ')' compound_statement_opt COMPUTE
	.mark1 = new_node(); #root of function CFA
	compound_statement_opt.input = .mark1;
	function_definition.labelsDefined = compound_statement_opt.result;
	.s1 = CONSTITUENTS jump_statement.jumpsResolved <- function_definition.labelsDefined;
	traverse_cfa(.mark1, StringTable(ident)) <- .s1;
END;

RULE: compound_statement_opt ::= ';' COMPUTE
	compound_statement_opt.result = compound_statement_opt.input;
END;

RULE: compound_statement_opt ::= compound_statement COMPUTE
	compound_statement.input = compound_statement_opt.input;
	compound_statement_opt.result = compound_statement.result;
END;

RULE: compound_statement ::= '{' declaration_list statement_list_opt '}' COMPUTE
	statement_list_opt.input = compound_statement.input;
	compound_statement.result = statement_list_opt.result;
END;

RULE: compound_statement ::= '{' statement_list_opt '}' COMPUTE
	statement_list_opt.input = compound_statement.input;
	compound_statement.result = statement_list_opt.result;
END;

RULE: statement_list_opt ::= COMPUTE
	statement_list_opt.result = statement_list_opt.input;
END;

RULE: statement_list_opt ::= statement_list COMPUTE
	statement_list.input = statement_list_opt.input;
	statement_list_opt.result = statement_list.result;
END;

RULE: statement_list ::= statement COMPUTE
	statement.input = statement_list.input;
	statement_list.result = statement.result;
END;

RULE: statement_list ::= statement_list statement COMPUTE
	statement_list[2].input = statement_list[1].input;
	statement[1].input = statement_list[2].result;
	statement_list[1].result =  statement[1].result;
END;

RULE: statement ::= labeled_statement COMPUTE
	labeled_statement.input = statement.input;
	statement.result = labeled_statement.result;
END;

RULE: statement ::= compound_statement COMPUTE
	compound_statement.input = statement.input;
	statement.result = compound_statement.result;
END;

RULE: statement ::= expression_statement COMPUTE
	expression_statement.input = statement.input;
	statement.result = expression_statement.result;
END;

RULE: statement ::= selection_statement COMPUTE
	selection_statement.input = statement.input;
	statement.result = selection_statement.result;
END;

RULE: statement ::= jump_statement COMPUTE
	jump_statement.input = statement.input;
	statement.result = jump_statement.result;
END;

RULE: labeled_statement ::= ident ':' statement COMPUTE
	register_node(StringTable(ident), labeled_statement.input);
	statement.input = labeled_statement.input;
	labeled_statement.result = statement.result;
END;

RULE: expression_statement ::= expression_opt ';' COMPUTE
	expression_opt.input = expression_statement.input;
	expression_statement.result = expression_opt.result;
END;

RULE: expression_opt ::= COMPUTE
	expression_opt.result = expression_opt.input;
END;

RULE: expression_opt ::= assignment_expression COMPUTE
	assignment_expression.input = expression_opt.input;
	expression_opt.result = assignment_expression.result;
END;

RULE: assignment_expression ::= IdUse assignment_operator function_call_expression COMPUTE
	function_call_expression.input = assignment_expression.input;
	assignment_expression.result = function_call_expression.result;
END;

RULE: assignment_expression ::= function_call_expression COMPUTE
	function_call_expression.input = assignment_expression.input;
	assignment_expression.result = function_call_expression.result;
END;

RULE: selection_statement ::= 'if' '(' Expression ')' statement COMPUTE
	.mark1 = new_node(); # state for first branch
	.mark2 = new_node(); # merge state

	statement.input = .mark1;
	.s1 = create_edge(selection_statement.input, .mark1, "if branch start");
	.s2 = create_edge(statement.result, .mark2, "if branch merge") <- .s1;	
	.s3 = create_edge(selection_statement.input, .mark2, "if branch skip") <- .s2;	
	
	selection_statement.result = .mark2 <- (statement.result, .s3);
END;

RULE: selection_statement ::= 'if' '(' Expression ')' statement 'else' statement COMPUTE
	.mark1 = new_node(); # state for first branch
	.mark2 = new_node(); # state for second branch
	.mark3 = new_node(); # merge state

	statement[1].input = .mark1;
	.s1 = create_edge(selection_statement.input, .mark1, "if branch 1 start");
	.s2 = create_edge(statement[1].result, .mark3, "if branch 1 merge") <- .s1;		
	
	statement[2].input = .mark2;
	.s3 = create_edge(selection_statement.input, .mark2, "if branch 2 start") <- .s2;
	.s4 = create_edge(statement[2].result, .mark3, "if branch 2 merge") <- .s3;		
	
	selection_statement.result = .mark3 <- (statement[1].result, statement[2].result, .s4);
END;

RULE: jump_statement ::= 'goto' ident ';' COMPUTE	
	jump_statement.jumpsResolved = create_edge(jump_statement.input, resolve_label(StringTable(ident)), StringTable(ident))  <- INCLUDING function_definition.labelsDefined;
	jump_statement.result = new_node() <- jump_statement.input;
END;

RULE: jump_statement ::= 'return' expression_opt ';' COMPUTE	
	expression_opt.input = jump_statement.input;
	jump_statement.result = new_node() <- expression_opt.result; 
	jump_statement.jumpsResolved = jump_statement.result;
END;

RULE: function_call_expression ::= Expression COMPUTE
	function_call_expression.result = function_call_expression.input;
END;

RULE: function_call_expression ::= ident '(' argument_expression_list_opt ')' COMPUTE
	.mark1 = new_node();
	.s1 = create_edge(function_call_expression.input, .mark1, StringTable(ident));
	function_call_expression.result = .mark1 <- .s1;
END;

RULE: function_call_expression ::= '(' type_specifier ')' ident '(' argument_expression_list_opt ')' COMPUTE
	.mark1 = new_node();
	.s1 = create_edge(function_call_expression.input, .mark1, StringTable(ident));
	function_call_expression.result = .mark1 <- .s1;
END;


~}


